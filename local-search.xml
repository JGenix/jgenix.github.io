<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>Java 异常</title>
    <link href="/java%E5%BC%82%E5%B8%B8.html"/>
    <url>/java%E5%BC%82%E5%B8%B8.html</url>
    
    <content type="html"><![CDATA[<p>Java异常是Java提供的一种识别及响应错误的一致性机制，java异常机制可以使程序中异常处理代码和正常业务代码分离，保证程序代码更加优雅，并提高程序健壮性。</p><span id="more"></span>]]></content>
    
    
    <categories>
      
      <category>JavaSE</category>
      
    </categories>
    
    
    <tags>
      
      <tag>异常</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Java 控制语句</title>
    <link href="/java%E6%8E%A7%E5%88%B6%E8%AF%AD%E5%8F%A5.html"/>
    <url>/java%E6%8E%A7%E5%88%B6%E8%AF%AD%E5%8F%A5.html</url>
    
    <content type="html"><![CDATA[<p>Java 流程控制语句，包括if、switch、while、for等结构。</p><span id="more"></span><h1 id="Java-控制语句"><a href="#Java-控制语句" class="headerlink" title="Java 控制语句"></a>Java 控制语句</h1><p>Java 控制语句大致可分为三大类：</p><ul><li>选择语句<ul><li>if, else-if, else</li><li>switch</li></ul></li><li>循环语句<ul><li>while</li><li>do…while</li><li>for</li><li>foreach</li></ul></li><li>中断语句<ul><li>break</li><li>continue</li><li>return</li></ul></li></ul><h2 id="选择语句"><a href="#选择语句" class="headerlink" title="选择语句"></a>选择语句</h2><h3 id="if-语句"><a href="#if-语句" class="headerlink" title="if 语句"></a>if 语句</h3><p><code>if</code> 语句会判断括号中的条件是否成立，如果成立则执行 <code>if</code> 语句中的代码块，否则跳过代码块继续执行。</p><h3 id="if…else-语句"><a href="#if…else-语句" class="headerlink" title="if…else 语句"></a>if…else 语句</h3><p><code>if</code> 语句后面可以跟 <code>else</code> 语句，当 <code>if</code> 语句的布尔表达式值为 <code>false</code> 时，<code>else</code> 语句块会被执行。</p><h3 id="if…else-if…else-语句"><a href="#if…else-if…else-语句" class="headerlink" title="if…else if…else 语句"></a>if…else if…else 语句</h3><ul><li><code>if</code> 语句至多有 1 个 <code>else</code> 语句，<code>else</code> 语句在所有的 <code>else if</code> 语句之后。</li><li><code>If</code> 语句可以有若干个 <code>else if</code> 语句，它们必须在 <code>else</code> 语句之前。</li><li>一旦其中一个 <code>else if</code> 语句检测为 <code>true</code>，其他的 <code>else if</code> 以及 <code>else</code> 语句都将跳过执行。</li></ul><h3 id="嵌套的-if…else-语句"><a href="#嵌套的-if…else-语句" class="headerlink" title="嵌套的 if…else 语句"></a>嵌套的 if…else 语句</h3><p>使用嵌套的 <code>if else</code> 语句是合法的。也就是说你可以在另一个 <code>if</code> 或者 <code>else if</code> 语句中使用 <code>if</code> 或者 <code>else if</code> 语句。</p><h3 id="switch-语句"><a href="#switch-语句" class="headerlink" title="switch 语句"></a>switch 语句</h3><p><code>switch</code> 语句判断一个变量与一系列值中某个值是否相等，每个值称为一个分支。</p><p><code>switch</code> 语句有如下规则：</p><ul><li><code>switch</code> 语句中的变量类型只能为 <code>byte</code>、<code>short</code>、<code>int</code>、<code>char</code> 或者 <code>String</code>。</li><li><code>switch</code> 语句可以拥有多个 <code>case</code> 语句。每个 <code>case</code> 后面跟一个要比较的值和冒号。</li><li><code>case</code> 语句中的值的数据类型必须与变量的数据类型相同，而且只能是常量或者字面常量。</li><li>当变量的值与 <code>case</code> 语句的值相等时，那么 <code>case</code> 语句之后的语句开始执行，直到 <code>break</code> 语句出现才会跳出 <code>switch</code> 语句。</li><li>当遇到 <code>break</code> 语句时，<code>switch</code> 语句终止。程序跳转到 <code>switch</code> 语句后面的语句执行。<code>case</code> 语句不必须要包含 <code>break</code> 语句。如果没有 <code>break</code> 语句出现，程序会继续执行下一条 <code>case</code> 语句，直到出现 <code>break</code> 语句。</li><li><code>switch</code> 语句可以包含一个 <code>default</code> 分支，该分支必须是 <code>switch</code> 语句的最后一个分支。<code>default</code> 在没有 <code>case</code> 语句的值和变量值相等的时候执行。<code>default</code> 分支不需要 <code>break</code> 语句。</li></ul><p><strong>语法</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">switch</span>(expression)&#123;<br>    <span class="hljs-keyword">case</span> value :<br>       <span class="hljs-comment">//语句</span><br>       <span class="hljs-keyword">break</span>; <span class="hljs-comment">//可选</span><br>    <span class="hljs-keyword">case</span> value :<br>       <span class="hljs-comment">//语句</span><br>       <span class="hljs-keyword">break</span>; <span class="hljs-comment">//可选</span><br>    <span class="hljs-comment">//你可以有任意数量的case语句</span><br>    <span class="hljs-keyword">default</span> : <span class="hljs-comment">//可选</span><br>       <span class="hljs-comment">//语句</span><br>       <span class="hljs-keyword">break</span>; <span class="hljs-comment">//可选，但一般建议加上</span><br>&#125;<br></code></pre></td></tr></table></figure><h2 id="循环语句"><a href="#循环语句" class="headerlink" title="循环语句"></a>循环语句</h2><h3 id="while-循环"><a href="#while-循环" class="headerlink" title="while 循环"></a>while 循环</h3><p>只要布尔表达式为 <code>true</code>，<code>while</code> 循环体会一直执行下去。</p><h3 id="do-while-循环"><a href="#do-while-循环" class="headerlink" title="do while 循环"></a>do while 循环</h3><p>对于 <code>while</code> 语句而言，如果不满足条件，则不能进入循环。但有时候我们需要即使不满足条件，也至少执行一次。</p><p><code>do while</code> 循环和 <code>while</code> 循环相似，不同的是，<code>do while</code> 循环至少会执行一次。</p><h3 id="for-循环"><a href="#for-循环" class="headerlink" title="for 循环"></a>for 循环</h3><p>虽然所有循环结构都可以用 <code>while</code> 或者 <code>do while</code> 表示，但 Java 提供了另一种语句 —— <code>for</code> 循环，使一些循环结构变得更加简单。 <code>for</code> 循环执行的次数是在执行前就确定的。</p><h3 id="foreach-循环"><a href="#foreach-循环" class="headerlink" title="foreach 循环"></a>foreach 循环</h3><p>Java5 引入了一种主要用于数组的增强型 for 循环。</p><p><strong>语法</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">for</span> (声明语句 : 表达式) &#123;<br>    <span class="hljs-comment">//代码句子</span><br>&#125;<br></code></pre></td></tr></table></figure><p><strong>声明语句</strong>：声明新的局部变量，该变量的类型必须和数组元素的类型匹配。其作用域限定在循环语句块，其值与此时数组元素的值相等。</p><p><strong>表达式</strong>：表达式是要访问的数组名，或者是返回值为数组的方法。</p><h2 id="中断语句"><a href="#中断语句" class="headerlink" title="中断语句"></a>中断语句</h2><h3 id="break-关键字"><a href="#break-关键字" class="headerlink" title="break 关键字"></a>break 关键字</h3><p><code>break</code> 主要用在循环语句或者 <code>switch</code> 语句中，用来跳出整个语句块。</p><p><code>break</code> 跳出最里层的循环，并且继续执行该循环下面的语句。</p><h3 id="continue-关键字"><a href="#continue-关键字" class="headerlink" title="continue 关键字"></a>continue 关键字</h3><p><code>continue</code> 适用于任何循环控制结构中。作用是让程序立刻跳转到下一次循环的迭代。在 <code>for</code> 循环中，<code>continue</code> 语句使程序立即跳转到更新语句。在 <code>while</code> 或者 <code>do while</code> 循环中，程序立即跳转到布尔表达式的判断语句。</p><h3 id="return-关键字"><a href="#return-关键字" class="headerlink" title="return 关键字"></a>return 关键字</h3><p>跳出整个函数体，函数体后面的部分不再执行。</p><h2 id="最佳实践"><a href="#最佳实践" class="headerlink" title="最佳实践"></a>最佳实践</h2><ul><li>选择分支特别多的情况下，<code>switch</code> 语句优于 <code>if...else if...else</code> 语句。</li><li><code>switch</code> 语句不要吝啬使用 <code>default</code>。</li><li><code>switch</code> 语句中的 <code>default</code> 要放在最后。</li><li><code>foreach</code> 循环优先于传统的 <code>for</code> 循环</li><li>不要循环遍历容器元素，然后删除特定元素。正确姿势应该是遍历容器的迭代器（<code>Iterator</code>），删除元素。</li></ul><blockquote><p><a href="https://book.douban.com/subject/2130190/">Java 编程思想</a></p></blockquote>]]></content>
    
    
    <categories>
      
      <category>JavaSE</category>
      
    </categories>
    
    
    <tags>
      
      <tag>基础</tag>
      
      <tag>关键字</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Java 枚举</title>
    <link href="/java%E6%9E%9A%E4%B8%BE.html"/>
    <url>/java%E6%9E%9A%E4%B8%BE.html</url>
    
    <content type="html"><![CDATA[<p>Java 枚举，也称作 Java 枚举类型，是一种字段由一组固定常量集合组成的类型。枚举的主要目的是加强编译时类型的安全性。enum 关键字是 Java 中的保留关键字。</p><span id="more"></span><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p><code>enum</code> 的全称为 enumeration， 是 JDK5 中引入的特性。</p><p>在 Java 中，被 <code>enum</code> 关键字修饰的类型就是枚举类型。形式如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">enum</span> <span class="hljs-title class_">ColorEn</span> &#123; RED, GREEN, BLUE &#125;<br></code></pre></td></tr></table></figure><p><strong>枚举的好处</strong>：可以将常量组织起来，统一进行管理。</p><p><strong>枚举的典型应用场景</strong>：错误码、状态机等。</p><h2 id="枚举的本质"><a href="#枚举的本质" class="headerlink" title="枚举的本质"></a>枚举的本质</h2><p><strong>枚举的本质是 <code>java.lang.Enum</code> 的子类。</strong></p><p>尽管 <code>enum</code> 看起来像是一种新的数据类型，事实上，<strong>enum 是一种受限制的类，并且具有自己的方法</strong>。枚举这种特殊的类因为被修饰为 <code>final</code>，所以不能继承其他类。</p><p>定义的枚举值，会被默认修饰为 <code>public static final</code> ，从修饰关键字，即可看出枚举值本质上是静态常量。</p><blockquote><p><a href="https://www.cnblogs.com/ziph/p/13068923.html">深入理解 Java 枚举</a></p></blockquote><h2 id="枚举的方法"><a href="#枚举的方法" class="headerlink" title="枚举的方法"></a>枚举的方法</h2><p>在 enum 中，提供了一些基本方法：</p><ul><li><code>values()</code>：返回 enum 实例的数组，而且该数组中的元素严格保持在 enum 中声明时的顺序。</li><li><code>name()</code>：返回实例名。</li><li><code>ordinal()</code>：返回实例声明时的次序，从 0 开始。</li><li><code>getDeclaringClass()</code>：返回实例所属的 enum 类型。</li><li><code>equals()</code> ：判断是否为同一个对象。</li></ul><p>可以使用 <code>==</code> 来比较<code>enum</code>实例。</p><p>此外，<code>java.lang.Enum</code>实现了<code>Comparable</code>和 <code>Serializable</code> 接口，所以也提供 <code>compareTo()</code> 方法。</p><p><strong>例：展示 enum 的基本方法</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">EnumMethodDemo</span> &#123;<br>    <span class="hljs-keyword">enum</span> <span class="hljs-title class_">Color</span> &#123;RED, GREEN, BLUE;&#125;<br>    <span class="hljs-keyword">enum</span> <span class="hljs-title class_">Size</span> &#123;BIG, MIDDLE, SMALL;&#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String args[])</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;=========== Print all Color ===========&quot;</span>);<br>        <span class="hljs-keyword">for</span> (Color c : Color.values()) &#123;<br>            System.out.println(c + <span class="hljs-string">&quot; ordinal: &quot;</span> + c.ordinal());<br>        &#125;<br>        System.out.println(<span class="hljs-string">&quot;=========== Print all Size ===========&quot;</span>);<br>        <span class="hljs-keyword">for</span> (Size s : Size.values()) &#123;<br>            System.out.println(s + <span class="hljs-string">&quot; ordinal: &quot;</span> + s.ordinal());<br>        &#125;<br><br>        <span class="hljs-type">Color</span> <span class="hljs-variable">green</span> <span class="hljs-operator">=</span> Color.GREEN;<br>        System.out.println(<span class="hljs-string">&quot;green name(): &quot;</span> + green.name());<br>        System.out.println(<span class="hljs-string">&quot;green getDeclaringClass(): &quot;</span> + green.getDeclaringClass());<br>        System.out.println(<span class="hljs-string">&quot;green hashCode(): &quot;</span> + green.hashCode());<br>        System.out.println(<span class="hljs-string">&quot;green compareTo Color.GREEN: &quot;</span> + green.compareTo(Color.GREEN));<br>        System.out.println(<span class="hljs-string">&quot;green equals Color.GREEN: &quot;</span> + green.equals(Color.GREEN));<br>        System.out.println(<span class="hljs-string">&quot;green equals Size.MIDDLE: &quot;</span> + green.equals(Size.MIDDLE));<br>        System.out.println(<span class="hljs-string">&quot;green equals 1: &quot;</span> + green.equals(<span class="hljs-number">1</span>));<br>        System.out.format(<span class="hljs-string">&quot;green == Color.BLUE: %b\n&quot;</span>, green == Color.BLUE);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>输出</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java">=========== Print all Color ===========<br>RED ordinal: <span class="hljs-number">0</span><br>GREEN ordinal: <span class="hljs-number">1</span><br>BLUE ordinal: <span class="hljs-number">2</span><br>=========== Print all Size ===========<br>BIG ordinal: <span class="hljs-number">0</span><br>MIDDLE ordinal: <span class="hljs-number">1</span><br>SMALL ordinal: <span class="hljs-number">2</span><br>green <span class="hljs-title function_">name</span><span class="hljs-params">()</span>: GREEN<br>green <span class="hljs-title function_">getDeclaringClass</span><span class="hljs-params">()</span>: <span class="hljs-keyword">class</span> <span class="hljs-title class_">org</span>.zp.javase.enumeration.EnumDemo$Color<br>green <span class="hljs-title function_">hashCode</span><span class="hljs-params">()</span>: <span class="hljs-number">460141958</span><br>green compareTo Color.GREEN: <span class="hljs-number">0</span><br>green equals Color.GREEN: <span class="hljs-literal">true</span><br>green equals Size.MIDDLE: <span class="hljs-literal">false</span><br>green equals <span class="hljs-number">1</span>: <span class="hljs-literal">false</span><br>green == Color.BLUE: <span class="hljs-literal">false</span><br></code></pre></td></tr></table></figure><h2 id="枚举的特性"><a href="#枚举的特性" class="headerlink" title="枚举的特性"></a>枚举的特性</h2><p>枚举的特性，归结起来就是一句话：</p><blockquote><p><strong>除了不能继承，基本上可以将 <code>enum</code> 看做一个常规的类</strong>。</p></blockquote><h3 id="基本特性"><a href="#基本特性" class="headerlink" title="基本特性"></a>基本特性</h3><p><strong>如果枚举中没有定义方法，也可以在最后一个实例后面加逗号、分号或什么都不加。</strong></p><p>如果枚举中没有定义方法，<strong>枚举值默认为从 0 开始的有序数值</strong>。以 Color 枚举类型举例，它的枚举常量依次为 <code>RED：0，GREEN：1，BLUE：2</code>。</p><h3 id="枚举可以添加方法"><a href="#枚举可以添加方法" class="headerlink" title="枚举可以添加方法"></a>枚举可以添加方法</h3><p>前面提到，<strong>枚举值默认为从 0 开始的有序数值</strong> 。那么问题来了：如何为枚举显式的赋值。</p><ul><li><strong>Java 不允许使用 <code>=</code> 为枚举常量赋值（区别 c++）。</strong></li><li><strong>枚举可以添加普通方法、静态方法、抽象方法、构造方法。</strong></li></ul><p>Java 虽然不能直接为实例赋值，但是它有更优秀的解决方案：<strong>为 enum 添加方法来间接实现显式赋值</strong>。</p><p>创建 <code>enum</code> 时，可以为其添加多种方法，甚至可以为其添加构造方法。</p><p><strong>注意一个细节：如果要为 enum 定义方法，那么必须在 enum 的最后一个实例尾部添加一个分号。此外，在 enum 中，必须先定义实例，不能将字段或方法定义在实例前面。否则，编译器会报错。</strong></p><p>例：全面展示如何在枚举中定义普通方法、静态方法、抽象方法、构造方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">enum</span> <span class="hljs-title class_">ErrorCodeEn</span> &#123;<br>    OK(<span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-meta">@Override</span><br>        <span class="hljs-keyword">public</span> String <span class="hljs-title function_">getDescription</span><span class="hljs-params">()</span> &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;成功&quot;</span>;<br>        &#125;<br>    &#125;,<br>    ERROR_A(<span class="hljs-number">100</span>) &#123;<br>        <span class="hljs-meta">@Override</span><br>        <span class="hljs-keyword">public</span> String <span class="hljs-title function_">getDescription</span><span class="hljs-params">()</span> &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;错误A&quot;</span>;<br>        &#125;<br>    &#125;,<br>    ERROR_B(<span class="hljs-number">200</span>) &#123;<br>        <span class="hljs-meta">@Override</span><br>        <span class="hljs-keyword">public</span> String <span class="hljs-title function_">getDescription</span><span class="hljs-params">()</span> &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;错误B&quot;</span>;<br>        &#125;<br>    &#125;;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> code;<br><br>    <span class="hljs-comment">// 构造方法：enum的构造方法只能被声明为private权限或不声明权限</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-title function_">ErrorCodeEn</span><span class="hljs-params">(<span class="hljs-type">int</span> number)</span> &#123; <span class="hljs-comment">// 构造方法</span><br>        <span class="hljs-built_in">this</span>.code = number;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">getCode</span><span class="hljs-params">()</span> &#123; <span class="hljs-comment">// 普通方法</span><br>        <span class="hljs-keyword">return</span> code;<br>    &#125; <span class="hljs-comment">// 普通方法</span><br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> String <span class="hljs-title function_">getDescription</span><span class="hljs-params">()</span>; <span class="hljs-comment">// 抽象方法</span><br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String args[])</span> &#123; <span class="hljs-comment">// 静态方法</span><br>        <span class="hljs-keyword">for</span> (ErrorCodeEn s : ErrorCodeEn.values()) &#123;<br>            System.out.println(<span class="hljs-string">&quot;code: &quot;</span> + s.getCode() + <span class="hljs-string">&quot;, description: &quot;</span> + s.getDescription());<br>        &#125;<br>    &#125;<br>&#125;<br><span class="hljs-comment">// Output:</span><br><span class="hljs-comment">// code: 0, description: 成功</span><br><span class="hljs-comment">// code: 100, description: 错误A</span><br><span class="hljs-comment">// code: 200, description: 错误B</span><br></code></pre></td></tr></table></figure><h3 id="枚举可以实现接口"><a href="#枚举可以实现接口" class="headerlink" title="枚举可以实现接口"></a>枚举可以实现接口</h3><p><strong><code>enum</code> 可以像一般类一样实现接口。</strong></p><p>同样是实现上面中的错误码枚举类，通过实现接口，可以约束它的方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">INumberEnum</span> &#123;<br>    <span class="hljs-type">int</span> <span class="hljs-title function_">getCode</span><span class="hljs-params">()</span>;<br>    String <span class="hljs-title function_">getDescription</span><span class="hljs-params">()</span>;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">enum</span> <span class="hljs-title class_">ErrorCodeEn2</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">INumberEnum</span> &#123;<br>    OK(<span class="hljs-number">0</span>, <span class="hljs-string">&quot;成功&quot;</span>),<br>    ERROR_A(<span class="hljs-number">100</span>, <span class="hljs-string">&quot;错误A&quot;</span>),<br>    ERROR_B(<span class="hljs-number">200</span>, <span class="hljs-string">&quot;错误B&quot;</span>);<br><br>    ErrorCodeEn2(<span class="hljs-type">int</span> number, String description) &#123;<br>        <span class="hljs-built_in">this</span>.code = number;<br>        <span class="hljs-built_in">this</span>.description = description;<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> code;<br>    <span class="hljs-keyword">private</span> String description;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">getCode</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> code;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">getDescription</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> description;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="枚举不可以继承"><a href="#枚举不可以继承" class="headerlink" title="枚举不可以继承"></a>枚举不可以继承</h3><p><strong>enum 不可以继承另外一个类，当然，也不能继承另一个 enum 。</strong></p><p>因为 <code>enum</code> 实际上都继承自 <code>java.lang.Enum</code> 类，而 Java 不支持多重继承，所以 <code>enum</code> 不能再继承其他类，当然也不能继承另一个 <code>enum</code>。</p><h2 id="枚举的应用"><a href="#枚举的应用" class="headerlink" title="枚举的应用"></a>枚举的应用</h2><p>下面三种声明方式是等价的：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">enum</span> <span class="hljs-title class_">Color</span> &#123; RED, GREEN, BLUE &#125;<br><span class="hljs-keyword">enum</span> <span class="hljs-title class_">Color</span> &#123; RED, GREEN, BLUE, &#125;<br><span class="hljs-keyword">enum</span> <span class="hljs-title class_">Color</span> &#123; RED, GREEN, BLUE; &#125;<br></code></pre></td></tr></table></figure><h3 id="switch-状态机"><a href="#switch-状态机" class="headerlink" title="switch 状态机"></a>switch 状态机</h3><p>我们经常使用 switch 语句来写状态机。JDK7 以后，switch 已经支持 <code>int</code>、<code>char</code>、<code>String</code>、<code>enum</code> 类型的参数。这几种类型的参数比较起来，使用枚举的 switch 代码更具有可读性。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">StateMachineDemo</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">enum</span> <span class="hljs-title class_">Signal</span> &#123;<br>        GREEN, YELLOW, RED<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> String <span class="hljs-title function_">getTrafficInstruct</span><span class="hljs-params">(Signal signal)</span> &#123;<br>        <span class="hljs-type">String</span> <span class="hljs-variable">instruct</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;信号灯故障&quot;</span>;<br>        <span class="hljs-keyword">switch</span> (signal) &#123;<br>            <span class="hljs-keyword">case</span> RED:<br>                instruct = <span class="hljs-string">&quot;红灯停&quot;</span>;<br>                <span class="hljs-keyword">break</span>;<br>            <span class="hljs-keyword">case</span> YELLOW:<br>                instruct = <span class="hljs-string">&quot;黄灯请注意&quot;</span>;<br>                <span class="hljs-keyword">break</span>;<br>            <span class="hljs-keyword">case</span> GREEN:<br>                instruct = <span class="hljs-string">&quot;绿灯行&quot;</span>;<br>                <span class="hljs-keyword">break</span>;<br>            <span class="hljs-keyword">default</span>:<br>                <span class="hljs-keyword">break</span>;<br>        &#125;<br>        <span class="hljs-keyword">return</span> instruct;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        System.out.println(getTrafficInstruct(Signal.RED));<br>    &#125;<br>&#125;<br><span class="hljs-comment">// Output:</span><br><span class="hljs-comment">// 红灯停</span><br></code></pre></td></tr></table></figure><h3 id="错误码"><a href="#错误码" class="headerlink" title="错误码"></a>错误码</h3><p>枚举常被用于定义程序错误码。下面是一个简单示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ErrorCodeEnumDemo</span> &#123;<br>    <span class="hljs-keyword">enum</span> <span class="hljs-title class_">ErrorCodeEn</span> &#123;<br>        OK(<span class="hljs-number">0</span>, <span class="hljs-string">&quot;成功&quot;</span>),<br>        ERROR_A(<span class="hljs-number">100</span>, <span class="hljs-string">&quot;错误A&quot;</span>),<br>        ERROR_B(<span class="hljs-number">200</span>, <span class="hljs-string">&quot;错误B&quot;</span>);<br><br>        ErrorCodeEn(<span class="hljs-type">int</span> number, String msg) &#123;<br>            <span class="hljs-built_in">this</span>.code = number;<br>            <span class="hljs-built_in">this</span>.msg = msg;<br>        &#125;<br><br>        <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> code;<br>        <span class="hljs-keyword">private</span> String msg;<br><br>        <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">getCode</span><span class="hljs-params">()</span> &#123;<br>            <span class="hljs-keyword">return</span> code;<br>        &#125;<br><br>        <span class="hljs-keyword">public</span> String <span class="hljs-title function_">getMsg</span><span class="hljs-params">()</span> &#123;<br>            <span class="hljs-keyword">return</span> msg;<br>        &#125;<br><br>        <span class="hljs-meta">@Override</span><br>        <span class="hljs-keyword">public</span> String <span class="hljs-title function_">toString</span><span class="hljs-params">()</span> &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;ErrorCodeEn&#123;&quot;</span> + <span class="hljs-string">&quot;code=&quot;</span> + code + <span class="hljs-string">&quot;, msg=&#x27;&quot;</span> + msg + <span class="hljs-string">&#x27;\&#x27;&#x27;</span> + <span class="hljs-string">&#x27;&#125;&#x27;</span>;<br>        &#125;<br><br>        <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> String <span class="hljs-title function_">toStringAll</span><span class="hljs-params">()</span> &#123;<br>            <span class="hljs-type">StringBuilder</span> <span class="hljs-variable">sb</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">StringBuilder</span>();<br>            sb.append(<span class="hljs-string">&quot;ErrorCodeEn All Elements: [&quot;</span>);<br>            <span class="hljs-keyword">for</span> (ErrorCodeEn code : ErrorCodeEn.values()) &#123;<br>                sb.append(code.getCode()).append(<span class="hljs-string">&quot;, &quot;</span>);<br>            &#125;<br>            sb.append(<span class="hljs-string">&quot;]&quot;</span>);<br>            <span class="hljs-keyword">return</span> sb.toString();<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        System.out.println(ErrorCodeEn.toStringAll());<br>        <span class="hljs-keyword">for</span> (ErrorCodeEn s : ErrorCodeEn.values()) &#123;<br>            System.out.println(s);<br>        &#125;<br>    &#125;<br>&#125;<br><span class="hljs-comment">// Output:</span><br><span class="hljs-comment">// ErrorCodeEn All Elements: [0, 100, 200, ]</span><br><span class="hljs-comment">// ErrorCodeEn&#123;code=0, msg=&#x27;成功&#x27;&#125;</span><br><span class="hljs-comment">// ErrorCodeEn&#123;code=100, msg=&#x27;错误A&#x27;&#125;</span><br><span class="hljs-comment">// ErrorCodeEn&#123;code=200, msg=&#x27;错误B&#x27;&#125;</span><br></code></pre></td></tr></table></figure><h2 id="枚举工具类"><a href="#枚举工具类" class="headerlink" title="枚举工具类"></a>枚举工具类</h2><p>Java 中提供了两个方便操作 enum 的工具类——<code>EnumSet</code> 和 <code>EnumMap</code>。</p><p>主要接口：</p><ul><li><code>noneOf</code> - 创建一个具有指定元素类型的空 EnumSet</li><li><code>allOf</code> - 创建一个指定元素类型并包含所有枚举值的 EnumSet</li><li><code>range</code> - 创建一个包括枚举值中指定范围元素的 EnumSet</li><li><code>complementOf</code> - 初始集合包括指定集合的补集</li><li><code>of</code> - 创建一个包括参数中所有元素的 EnumSet</li><li><code>copyOf</code> - 创建一个包含参数容器中的所有元素的 EnumSet</li></ul><p>示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">EnumSetDemo</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;EnumSet展示&quot;</span>);<br>        EnumSet&lt;ErrorCodeEn&gt; errSet = EnumSet.allOf(ErrorCodeEn.class);<br>        <span class="hljs-keyword">for</span> (ErrorCodeEn e : errSet) &#123;<br>            System.out.println(e.name() + <span class="hljs-string">&quot; : &quot;</span> + e.ordinal());<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="EnumMap"><a href="#EnumMap" class="headerlink" title="EnumMap"></a>EnumMap</h3><p><code>EnumMap</code> 是专门为枚举类型量身定做的 <code>Map</code> 实现。虽然使用其它的 Map 实现（如 HashMap）也能完成枚举类型实例到值得映射，但是使用 EnumMap 会更加高效：它只能接收同一枚举类型的实例作为键值，并且由于枚举类型实例的数量相对固定并且有限，所以 EnumMap 使用数组来存放与枚举类型对应的值。这使得 EnumMap 的效率非常高。</p><p>主要接口：</p><ul><li><code>size</code> - 返回键值对数</li><li><code>containsValue</code> - 是否存在指定的 value</li><li><code>containsKey</code> - 是否存在指定的 key</li><li><code>get</code> - 根据指定 key 获取 value</li><li><code>put</code> - 取出指定的键值对</li><li><code>remove</code> - 删除指定 key</li><li><code>putAll</code> - 批量取出键值对</li><li><code>clear</code> - 清除数据</li><li><code>keySet</code> - 获取 key 集合</li><li><code>values</code> - 返回所有</li></ul><p>示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">EnumMapDemo</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">enum</span> <span class="hljs-title class_">Signal</span> &#123;<br>        GREEN, YELLOW, RED<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;EnumMap展示&quot;</span>);<br>        EnumMap&lt;Signal, String&gt; errMap = <span class="hljs-keyword">new</span> <span class="hljs-title class_">EnumMap</span>(Signal.class);<br>        errMap.put(Signal.RED, <span class="hljs-string">&quot;红灯&quot;</span>);<br>        errMap.put(Signal.YELLOW, <span class="hljs-string">&quot;黄灯&quot;</span>);<br>        errMap.put(Signal.GREEN, <span class="hljs-string">&quot;绿灯&quot;</span>);<br>        <span class="hljs-keyword">for</span> (Iterator&lt;Map.Entry&lt;Signal, String&gt;&gt; iter = errMap.entrySet().iterator(); iter.hasNext();) &#123;<br>            Map.Entry&lt;Signal, String&gt; entry = iter.next();<br>            System.out.println(entry.getKey().name() + <span class="hljs-string">&quot; : &quot;</span> + entry.getValue());<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p><a href="https://blog.csdn.net/javazejian/article/details/71333103#enumset%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86%E5%89%96%E6%9E%90">深入理解 Java 枚举类型(enum)</a></p></blockquote>]]></content>
    
    
    <categories>
      
      <category>JavaSE</category>
      
    </categories>
    
    
    <tags>
      
      <tag>枚举</tag>
      
      <tag>基础</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Java 数组</title>
    <link href="/java%E6%95%B0%E7%BB%84.html"/>
    <url>/java%E6%95%B0%E7%BB%84.html</url>
    
    <content type="html"><![CDATA[<p>数组对于每一门编程语言来说都是重要的数据结构之一，当然不同语言对数组的实现及处理也不尽相同，几乎所有程序设计语言都支持数组。</p><span id="more"></span><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>数组代表一系列对象或者基本数据类型，所有相同的类型都封装到一起，采用一个统一的标识符名称。</p><p><strong>数组的定义和使用需要通过方括号 <code>[]</code>。</strong></p><blockquote><p><strong>Java 中，数组是一种引用类型。</strong></p><p><strong>Java 中，数组是用来存储固定大小的同类型元素。</strong></p></blockquote><h3 id="数组和容器"><a href="#数组和容器" class="headerlink" title="数组和容器"></a>数组和容器</h3><p>Java 中，既然有了强大的容器，是不是就不需要数组了？</p><p>不是，数组也有其优势：</p><ul><li><p>Java 中，数组是一种效率最高的存储和随机访问对象引用序列的方式。<strong>数组的效率要高于容器</strong>（如 <code>ArrayList</code>）。</p></li><li><p><strong>数组可以持有值类型，而容器则不能</strong>（这时，就必须用到包装类）。</p></li></ul><h3 id="Java-数组的本质是对象"><a href="#Java-数组的本质是对象" class="headerlink" title="Java 数组的本质是对象"></a>Java 数组的本质是对象</h3><p>实例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">int</span>[] arr = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[<span class="hljs-number">3</span>];<br><span class="hljs-type">int</span> <span class="hljs-variable">size</span> <span class="hljs-operator">=</span> arr.length; #得到数组长度<br></code></pre></td></tr></table></figure><p>数组居然存在 length 这个属性，这很明显是对象才具有的特性。同时，数组也排除于 8 大基本数组类型之外，《java 核心卷一》中对数组的定义是：一个数据容器，用来存储相同数据类型的数据集合。</p><p>相应解释：</p><p><strong>Java 数组的本质是对象</strong>。它具有 Java 中其他对象的一些基本特点：封装了一些数据，可以访问属性，也可以调用方法。所以，数组是对象。</p><p><strong>如果有两个类 A 和 B，如果 B 继承（extends）了 A，那么 A[] 类型的引用就可以指向 B[] 类型的对象。</strong></p><h3 id="Java-数组和内存"><a href="#Java-数组和内存" class="headerlink" title="Java 数组和内存"></a>Java 数组和内存</h3><p>Java 数组在内存中的存储是这样的：</p><ul><li><p>数组对象（这里可以看成一个指针）存储在栈中。</p></li><li><p>数组元素存储在堆中。</p></li></ul><p>如下图所示：只有当 JVM 执行 <code>new String[]</code> 时，才会在堆中开辟相应的内存区域。数组对象 array 可以视为一个指针，指向这块内存的存储地址。</p><img src="https://cdn.jsdelivr.net/gh/gejoyy/Pictures@main/java%E6%95%B0%E7%BB%84%E5%92%8C%E5%86%85%E5%AD%98.png" alt="java数组和内存" style="zoom:60%;" /><h2 id="声明数组"><a href="#声明数组" class="headerlink" title="声明数组"></a>声明数组</h2><p>声明数组变量的语法如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">int</span>[] arr1; <span class="hljs-comment">// 推荐风格</span><br><span class="hljs-type">int</span> arr2[]; <span class="hljs-comment">// 效果相同</span><br></code></pre></td></tr></table></figure><h2 id="创建数组"><a href="#创建数组" class="headerlink" title="创建数组"></a>创建数组</h2><p>Java 语言使用 <code>new</code> 操作符来创建数组。有两种创建数组方式：</p><ul><li>指定数组维度<ul><li>为数组开辟指定大小的数组维度。</li><li>如果数组元素是基础数据类型，会将每个元素设为默认值；如果是引用类型，元素值为 <code>null</code>。</li></ul></li><li>不指定数组维度<ul><li>用花括号中的实际元素初始化数组，数组大小与元素数相同。</li></ul></li></ul><p>示例 1：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">int</span>[] array1 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[<span class="hljs-number">2</span>]; <span class="hljs-comment">// 指定数组维度（1维）</span><br><span class="hljs-comment">// output:&#123;0，0&#125;</span><br><br><span class="hljs-type">int</span>[] array2 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[] &#123; <span class="hljs-number">1</span>, <span class="hljs-number">2</span> &#125;; <span class="hljs-comment">// 不指定数组维度</span><br><span class="hljs-comment">// output:&#123;1, 2&#125;</span><br></code></pre></td></tr></table></figure><p>说明：请注意数组 array1 中的元素虽然没有初始化，但是 length 和指定的数组维度是一样的。这表明<strong>指定数组维度后，无论后面是否初始化数组中的元素，数组都已经开辟了相应的内存</strong>。</p><p>数组 array1 中的元素都被设为默认值。</p><p>示例 2：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ArrayDemo2</span> &#123;<br>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">User</span> &#123;&#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        User[] array1 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">User</span>[<span class="hljs-number">2</span>]; <span class="hljs-comment">// 指定数组维度</span><br>        User[] array2 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">User</span>[] &#123;<span class="hljs-keyword">new</span> <span class="hljs-title class_">User</span>(), <span class="hljs-keyword">new</span> <span class="hljs-title class_">User</span>()&#125;; <span class="hljs-comment">// 不指定数组维度</span><br><br>        System.out.println(<span class="hljs-string">&quot;array1: &quot;</span>);<br>        <span class="hljs-keyword">for</span> (User item : array1) &#123;<br>            System.out.println(item);<br>        &#125;<br>        System.out.println(<span class="hljs-string">&quot;array2: &quot;</span>);<br>        <span class="hljs-keyword">for</span> (User item : array2) &#123;<br>            System.out.println(item);<br>        &#125;<br>    &#125;<br>&#125;<br><span class="hljs-comment">// array1:</span><br><span class="hljs-comment">// null</span><br><span class="hljs-comment">// null</span><br><br><span class="hljs-comment">// array2:</span><br><span class="hljs-comment">// io.github.dunwu.javacore.array.ArrayDemo2$User@4141d797</span><br><span class="hljs-comment">// io.github.dunwu.javacore.array.ArrayDemo2$User@68f7aae2</span><br></code></pre></td></tr></table></figure><p>说明：如果使用指定数组维度方式创建数组，且数组元素为<strong>引用类型</strong>，则数组中的元素元素值为 <code>null</code>。</p><h3 id="数组维度的形式"><a href="#数组维度的形式" class="headerlink" title="数组维度的形式"></a>数组维度的形式</h3><p>创建数组时，指定的数组维度可以有多种形式：</p><ul><li>数组维度可以是整数、字符。</li><li>数组维度可以是整数型、字符型变量。</li><li>数组维度可以是计算结果为整数或字符的表达式。</li></ul><p>示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ArrayDemo3</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">length</span> <span class="hljs-operator">=</span> <span class="hljs-number">3</span>;<br>        <span class="hljs-comment">// 放开被注掉的代码，编译器会报错</span><br>        <span class="hljs-comment">// int[] array = new int[4.0];</span><br>        <span class="hljs-comment">// int[] array2 = new int[&quot;test&quot;];</span><br>        <span class="hljs-type">int</span>[] array3 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[<span class="hljs-string">&#x27;a&#x27;</span>];<br>        <span class="hljs-type">int</span>[] array4 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[length];<br>        <span class="hljs-type">int</span>[] array5 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[length + <span class="hljs-number">2</span>];<br>        <span class="hljs-type">int</span>[] array6 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[<span class="hljs-string">&#x27;a&#x27;</span> + <span class="hljs-number">2</span>];<br>        <span class="hljs-comment">// int[] array7 = new int[length + 2.1];</span><br>        System.out.println(<span class="hljs-string">&quot;array3.length = [&quot;</span> + array3.length + <span class="hljs-string">&quot;]&quot;</span>);<br>        System.out.println(<span class="hljs-string">&quot;array4.length = [&quot;</span> + array4.length + <span class="hljs-string">&quot;]&quot;</span>);<br>        System.out.println(<span class="hljs-string">&quot;array5.length = [&quot;</span> + array5.length + <span class="hljs-string">&quot;]&quot;</span>);<br>        System.out.println(<span class="hljs-string">&quot;array6.length = [&quot;</span> + array6.length + <span class="hljs-string">&quot;]&quot;</span>);<br>    &#125;<br>&#125;<br><span class="hljs-comment">// Output:</span><br><span class="hljs-comment">// array3.length = [97]</span><br><span class="hljs-comment">// array4.length = [3]</span><br><span class="hljs-comment">// array5.length = [5]</span><br><span class="hljs-comment">// array6.length = [99]</span><br></code></pre></td></tr></table></figure><p>说明：当指定的数组维度是字符时，Java 会将其转为整数。如字符 <code>a</code> 的 ASCII 码是 97。</p><p>综上，<strong>Java 数组的数组维度可以是常量、变量、表达式，只要转换为整数即可</strong>。</p><h3 id="数组维度的大小"><a href="#数组维度的大小" class="headerlink" title="数组维度的大小"></a>数组维度的大小</h3><p><strong>数组维度并非没有上限的，如果数值过大，编译时会报错。</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">int</span>[] array = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[<span class="hljs-number">6553612431</span>]; <span class="hljs-comment">// 数组维度过大，编译报错</span><br></code></pre></td></tr></table></figure><p>此外，<strong>数组过大，可能会导致栈溢出</strong>。</p><h2 id="访问数组"><a href="#访问数组" class="headerlink" title="访问数组"></a>访问数组</h2><p><strong>Java 中，可以通过在 <code>[]</code> 中指定下标，访问数组元素，下标位置从 0 开始。</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ArrayDemo4</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">int</span>[] array = &#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>&#125;;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; array.length; i++) &#123;<br>            array[i]++;<br>            System.out.println(String.format(<span class="hljs-string">&quot;array[%d] = %d&quot;</span>, i, array[i]));<br>        &#125;<br>    &#125;<br>&#125;<br><span class="hljs-comment">// Output:</span><br><span class="hljs-comment">// array[0] = 2</span><br><span class="hljs-comment">// array[1] = 3</span><br><span class="hljs-comment">// array[2] = 4</span><br></code></pre></td></tr></table></figure><h2 id="数组的引用"><a href="#数组的引用" class="headerlink" title="数组的引用"></a>数组的引用</h2><p><strong>Java 中，数组类型是一种引用类型</strong>。</p><p>因此，它可以作为引用，被 Java 函数<strong>作为函数入参或返回值</strong>。</p><p>数组作为函数入参的示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ArrayRefDemo</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">fun</span><span class="hljs-params">(<span class="hljs-type">int</span>[] array)</span> &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i : array) &#123;<br>            System.out.print(i + <span class="hljs-string">&quot;\t&quot;</span>);<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">int</span>[] array = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[] &#123;<span class="hljs-number">1</span>, <span class="hljs-number">3</span>, <span class="hljs-number">5</span>&#125;;<br>        fun(array);<br>    &#125;<br>&#125;<br><span class="hljs-comment">// Output:</span><br><span class="hljs-comment">// 135</span><br></code></pre></td></tr></table></figure><p>数组作为函数返回值的示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ArrayRefDemo2</span> &#123;<br>    <span class="hljs-comment">// 返回一个数组</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span>[] fun() &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[] &#123;<span class="hljs-number">1</span>, <span class="hljs-number">3</span>, <span class="hljs-number">5</span>&#125;;<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">int</span>[] array = fun();<br>        System.out.println(Arrays.toString(array));<br>    &#125;<br>&#125;<br><span class="hljs-comment">// Output:</span><br><span class="hljs-comment">// [1, 3, 5]</span><br></code></pre></td></tr></table></figure><h2 id="多维数组"><a href="#多维数组" class="headerlink" title="多维数组"></a>多维数组</h2><p>多维数组可以看成是数组的数组，比如二维数组就是一个特殊的一维数组，其每一个元素都是一个一维数组。</p><p>Java 可以支持二维数组、三维数组、四维数组、五维数组。。。</p><p>示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java">Integer[][] a1 = &#123; <span class="hljs-comment">// 自动装箱</span><br>    &#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>,&#125;,<br>    &#123;<span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">6</span>,&#125;,<br>&#125;;<br><span class="hljs-comment">// a1: [[1, 2, 3], [4, 5, 6]]</span><br><br>Double[][][] a2 = &#123; <span class="hljs-comment">// 自动装箱</span><br>    &#123; &#123;<span class="hljs-number">1.1</span>, <span class="hljs-number">2.2</span>&#125;, &#123;<span class="hljs-number">3.3</span>, <span class="hljs-number">4.4</span>&#125; &#125;,<br>    &#123; &#123;<span class="hljs-number">5.5</span>, <span class="hljs-number">6.6</span>&#125;, &#123;<span class="hljs-number">7.7</span>, <span class="hljs-number">8.8</span>&#125; &#125;,<br>    &#123; &#123;<span class="hljs-number">9.9</span>, <span class="hljs-number">1.2</span>&#125;, &#123;<span class="hljs-number">2.3</span>, <span class="hljs-number">3.4</span>&#125; &#125;,<br>&#125;;<br><span class="hljs-comment">// a2: [[[1.1, 2.2], [3.3, 4.4]], [[5.5, 6.6], [7.7, 8.8]], [[9.9, 1.2], [2.3, 3.4]]]</span><br><br>String[][] a3 = &#123;<br>    &#123;<span class="hljs-string">&quot;The&quot;</span>, <span class="hljs-string">&quot;Quick&quot;</span>, <span class="hljs-string">&quot;Sly&quot;</span>, <span class="hljs-string">&quot;Fox&quot;</span>&#125;,<br>    &#123;<span class="hljs-string">&quot;Jumped&quot;</span>, <span class="hljs-string">&quot;Over&quot;</span>&#125;,<br>    &#123;<span class="hljs-string">&quot;The&quot;</span>, <span class="hljs-string">&quot;Lazy&quot;</span>, <span class="hljs-string">&quot;Brown&quot;</span>, <span class="hljs-string">&quot;Dog&quot;</span>, <span class="hljs-string">&quot;and&quot;</span>, <span class="hljs-string">&quot;friend&quot;</span>&#125;,<br>&#125;;<br><span class="hljs-comment">// a3: [[The, Quick, Sly, Fox], [Jumped, Over], [The, Lazy, Brown, Dog, and, friend]]</span><br></code></pre></td></tr></table></figure><h2 id="Arrays-类"><a href="#Arrays-类" class="headerlink" title="Arrays 类"></a>Arrays 类</h2><p>Java 中，提供了一个很有用的数组工具类：Arrays。</p><p>它提供的主要操作有：</p><ul><li><code>Array.sort()</code> - 排序</li><li><code>Array.binarySearch()</code> - 查找</li><li><code>Array.equals()</code> - 比较</li><li><code>Array.fill()</code> - 填充</li><li><code>Array.asList()</code> - 转列表</li><li><code>Array.hash()</code> - 哈希</li><li><code>Array.toString()</code> - 转字符串</li></ul><blockquote><p>参考：<a href="https://developer.aliyun.com/article/280643">使用 Arrays 类操作 Java 中的数组</a></p></blockquote>]]></content>
    
    
    <categories>
      
      <category>JavaSE</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数组</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Java 方法</title>
    <link href="/java%E6%96%B9%E6%B3%95.html"/>
    <url>/java%E6%96%B9%E6%B3%95.html</url>
    
    <content type="html"><![CDATA[<p>Java 方法（又称为函数）是定义在类中的一段独立的代码块，用来实现某个功能，解决了重复性代码的问题。方法的主要作用是为了提高程序的复用性和可读性。</p><span id="more"></span><h3 id="方法定义"><a href="#方法定义" class="headerlink" title="方法定义"></a>方法定义</h3><p>方法定义语法格式：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java">[修饰符] 返回值类型 方法名([参数类型 参数名])&#123;<br>    ...<br>    方法体<br>    ...<br>    <span class="hljs-keyword">return</span> 返回值;<br>&#125;<br></code></pre></td></tr></table></figure><p>方法包含一个方法头和一个方法体。下面是一个方法的所有部分：</p><ul><li><strong>修饰符</strong> - 修饰符是可选的，它告诉编译器如何调用该方法。定义了该方法的访问类型。</li><li><strong>返回值类型</strong> - 返回值类型表示方法执行结束后，返回结果的数据类型。如果没有返回值，应设为 void。</li><li><strong>方法名</strong> - 是方法的实际名称。方法名和参数表共同构成方法签名。</li><li><strong>参数类型</strong> - 参数像是一个占位符。当方法被调用时，传递值给参数。参数列表是指方法的参数类型、顺序和参数的个数。参数是可选的，方法可以不包含任何参数。</li><li><strong>方法体</strong> - 方法体包含具体的语句，定义该方法的功能。</li><li><strong>return</strong> - 必须返回声明方法时返回值类型相同的数据类型。在 void 方法中，return 语句可有可无。</li></ul><h3 id="方法的调用"><a href="#方法的调用" class="headerlink" title="方法的调用"></a>方法的调用</h3><p>当程序调用一个方法时，程序的控制权交给了被调用的方法。当被调用方法的返回语句执行或者到达方法体闭括号时候交还控制权给程序。</p><p>Java 支持两种调用方法的方式，根据方法是否有返回值来选择。</p><ul><li>有返回值方法 - 有返回值方法通常被用来给一个变量赋值或代入到运算表达式中进行计算。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">int</span> <span class="hljs-variable">larger</span> <span class="hljs-operator">=</span> max(<span class="hljs-number">30</span>, <span class="hljs-number">40</span>);<br></code></pre></td></tr></table></figure><ul><li>无返回值方法 - 无返回值方法只能是一条语句。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">System.out.println(<span class="hljs-string">&quot;Hello World&quot;</span>);<br></code></pre></td></tr></table></figure><h2 id="方法参数"><a href="#方法参数" class="headerlink" title="方法参数"></a>方法参数</h2><p>在 C&#x2F;C++ 等编程语言中，方法的参数传递一般有两种形式：</p><ul><li>值传递 - 值传递的参数被称为形参。值传递时，传入的参数，在方法中的修改，不会在方法外部生效。</li><li>引用传递 - 引用传递的参数被称为实参。引用传递时，传入的参数，在方法中的修改，会在方法外部生效。</li></ul><p><u><strong>Java 中只有值传递，不存在引用传递!</strong></u></p><p>示例一：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MethodParamDemo</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">method</span><span class="hljs-params">(<span class="hljs-type">int</span> value)</span> &#123;<br>        value =  value + <span class="hljs-number">1</span>;<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">num</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        method(num);<br>        System.out.println(<span class="hljs-string">&quot;num = [&quot;</span> + num + <span class="hljs-string">&quot;]&quot;</span>);<br>    &#125;<br>&#125;<br><span class="hljs-comment">// Output:</span><br><span class="hljs-comment">// num = [0]</span><br></code></pre></td></tr></table></figure><p>示例二：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MethodParamDemo2</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">method</span><span class="hljs-params">(StringBuilder sb)</span> &#123;<br>        sb = <span class="hljs-keyword">new</span> <span class="hljs-title class_">StringBuilder</span>(<span class="hljs-string">&quot;B&quot;</span>);<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">StringBuilder</span> <span class="hljs-variable">sb</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">StringBuilder</span>(<span class="hljs-string">&quot;A&quot;</span>);<br>        System.out.println(<span class="hljs-string">&quot;sb = [&quot;</span> + sb.toString() + <span class="hljs-string">&quot;]&quot;</span>);<br>        method(sb);<br>        System.out.println(<span class="hljs-string">&quot;sb = [&quot;</span> + sb.toString() + <span class="hljs-string">&quot;]&quot;</span>);<br>        sb = <span class="hljs-keyword">new</span> <span class="hljs-title class_">StringBuilder</span>(<span class="hljs-string">&quot;C&quot;</span>);<br>        System.out.println(<span class="hljs-string">&quot;sb = [&quot;</span> + sb.toString() + <span class="hljs-string">&quot;]&quot;</span>);<br>    &#125;<br>&#125;<br><span class="hljs-comment">// Output:</span><br><span class="hljs-comment">// sb = [A]</span><br><span class="hljs-comment">// sb = [A]</span><br><span class="hljs-comment">// sb = [C]</span><br></code></pre></td></tr></table></figure><p>以上两个示例，<strong>无论向方法中传入的参数是基础数据类型，还是引用类型，在方法中修改的值，在外部都未生效</strong>。</p><blockquote><p>Java 对于基本数据类型，会直接拷贝值传递到方法中；对于引用数据类型，拷贝当前对象的引用地址，然后把该地址传递过去，所以也是值传递。</p><p>参考：<a href="https://zhuanlan.zhihu.com/p/24556934?refer=dreawer">图解 Java 中的参数传递</a></p></blockquote><p>String 特例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>       <span class="hljs-type">String</span> <span class="hljs-variable">str</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;11111&quot;</span>;<br>       changeStr(str);<br>       System.out.println(str);<span class="hljs-comment">//输出11111</span><br>   &#125;<br>   <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">changeStr</span><span class="hljs-params">(String str)</span>&#123;<br>       str = <span class="hljs-string">&quot;22222&quot;</span>;<br>   &#125;<br></code></pre></td></tr></table></figure><p><code>str</code> 不变，因为<strong>String 对象具有不可变性</strong>，所以针对操作<code>str = &quot;22222&quot;</code>，在 String 池中不存在的时候,就是相当于<code>str = new String()</code>，new 操作会在堆中重新创建一个对象，此时<code>str</code>指向这个对象，而原<code>str</code>不变（值传递）。</p><p><strong>在 Java 中，当基本类型作为参数传入方法时，无论该参数在方法内怎样被改变，外部的变量原型总是不变的，因为方法内部有外部变量的一份拷贝，对这个拷贝的更改不会改变外部变量的值。</strong></p><blockquote><p>结论：八个基本数据类型，String 对象，作为参数传递不会改变其原先值！</p></blockquote><p><strong>当方法传入的参数为非基本类型时（对象类型的变量），方法里面改变参数变量的同时变量原型也会随之改变。</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">StringBuffer</span> <span class="hljs-variable">strBuf</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">StringBuffer</span>(“original”);<br>changeStringBuffer(strBuf) &#123;strbuf.apend(“ is changed!”)&#125; <span class="hljs-comment">//改变送进的StringBuffer变量</span><br>System.out.println(strBuf); <span class="hljs-comment">//这时strBuf的值就变为了original is changed!</span><br></code></pre></td></tr></table></figure><p>这种特性就叫做“引用传递”，也叫做传址，即方法操作<strong>参数变量时是拷贝了变量的引用</strong>，注意下传递给方法的参数为变量的引用，<strong>其实也就是指针，而后通过这个引用找到变量（在这里是对象）的真正地址，并对其进行操作</strong>。</p><h2 id="方法修饰符"><a href="#方法修饰符" class="headerlink" title="方法修饰符"></a>方法修饰符</h2><p>Java 方法的修饰符是可选的，它告诉编译器如何调用该方法，以及定义了该方法的访问类型。</p><h3 id="访问控制修饰符"><a href="#访问控制修饰符" class="headerlink" title="访问控制修饰符"></a>访问控制修饰符</h3><p>访问权限控制的等级，从最大权限到最小权限依次为：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> &gt; <span class="hljs-keyword">protected</span> &gt; 包访问权限（没有任何关键字）&gt; <span class="hljs-keyword">private</span><br></code></pre></td></tr></table></figure><ul><li><code>public</code> - 表示任何类都可以访问；</li><li><code>包访问权限</code> - 包访问权限，没有任何关键字。它表示当前包中的所有其他类都可以访问，但是其它包的类无法访问。</li><li><code>protected</code> - 表示子类可以访问，此外，同一个包内的其他类也可以访问，即使这些类不是子类。</li><li><code>private</code> - 表示其它任何类都无法访问。</li></ul><h3 id="static"><a href="#static" class="headerlink" title="static"></a>static</h3><p><strong>被 <code>static</code> 修饰的方法被称为静态方法。</strong></p><p>静态方法相比于普通的实例方法，主要有以下区别：</p><ul><li>在外部调用静态方法时，可以使用 <code>类名.方法名</code> 的方式，也可以使用 <code>对象名.方法名</code> 的方式。而实例方法只有后面这种方式。也就是说，<strong>调用静态方法可以无需创建对象</strong>。</li><li><strong>静态方法在访问本类的成员时，只允许访问静态成员</strong>（即静态成员变量和静态方法），而不允许访问实例成员变量和实例方法；实例方法则无此限制。</li></ul><p><em>静态方法常被用于各种工具类、工厂方法类。</em></p><h3 id="final"><a href="#final" class="headerlink" title="final"></a>final</h3><p>被 <code>final</code> 修饰的方法不能被子类覆写（Override）。</p><p>final 方法示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">FinalMethodDemo</span> &#123;<br>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Father</span> &#123;<br>        <span class="hljs-keyword">protected</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">print</span><span class="hljs-params">()</span> &#123;<br>            System.out.println(<span class="hljs-string">&quot;call Father print()&quot;</span>);<br>        &#125;;<br>    &#125;<br><br>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Son</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Father</span> &#123;<br>        <span class="hljs-meta">@Override</span><br>        <span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">print</span><span class="hljs-params">()</span> &#123;<br>            System.out.println(<span class="hljs-string">&quot;call print()&quot;</span>);<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">Father</span> <span class="hljs-variable">demo</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Son</span>();<br>        demo.print();<br>    &#125;<br>&#125;<br><span class="hljs-comment">// 编译时会报错</span><br></code></pre></td></tr></table></figure><p>上面示例中，父类 Father 中定义了一个 final 方法 print()，则其子类不能 Override 这个 final 方法，否则会编译报错。</p><blockquote><ul><li>final 关键字可以用于成员变量、本地变量、方法以及类</li><li>final 成员变量必须在声明的时候初始化或者在构造器中初始化，否则就汇报编译错误</li><li>不能够对 final 变量再次赋值</li><li>本地变量必须在声明时赋值</li><li>在匿名类中所有变量都必须是 final 变量</li><li>final 方法不能被重写</li><li>final 类不能被继承</li><li>接口中声明的所有变量本身是 final 的</li><li>final 和 abstract 这两个关键字是反相关的，final 类就不可能是 abstract 的</li><li>没有在声明时初始化 final 变量的称为空白 final 变量(blank final variable)，它们必须在构造器中初始化，或者调用 this() 初始化，不这么做的话，编译器会报错 final 变量(变量名)需要进行初始化</li><li>按照 Java 代码惯例，final 变量就是常量，而且通常常量名要大写</li><li>对于集合对象声明为 final 指的是引用不能被更改</li></ul><p>参考：<a href="https://developer.aliyun.com/article/723832">深入理解 Java 中的 final 关键字</a></p></blockquote><h3 id="default"><a href="#default" class="headerlink" title="default"></a>default</h3><p><strong><code>default</code> 方法只能出现在接口 <code>Interface</code> 中</strong>。<strong>接口中被 <code>default</code> 修饰的方法被称为默认方法，实现此接口的类如果没 Override 此方法，则直接继承这个方法，不再强制必须实现此方法。</strong></p><p><code>default</code> 方法示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">DefaultMethodDemo</span> &#123;<br>    <span class="hljs-keyword">interface</span> <span class="hljs-title class_">MyInterface</span> &#123;<br>        <span class="hljs-keyword">default</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">print</span><span class="hljs-params">()</span> &#123;<br>            System.out.println(<span class="hljs-string">&quot;Hello World&quot;</span>);<br>        &#125;<br>    &#125;<br><br><br>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MyClass</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">MyInterface</span> &#123;&#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">MyInterface</span> <span class="hljs-variable">obj</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">MyClass</span>();<br>        obj.print();<br>    &#125;<br>&#125;<br><span class="hljs-comment">// Output:</span><br><span class="hljs-comment">// Hello World</span><br></code></pre></td></tr></table></figure><h3 id="abstract"><a href="#abstract" class="headerlink" title="abstract"></a>abstract</h3><p><strong>被 <code>abstract</code> 修饰的方法被称为抽象方法，方法不能有实体。抽象方法只能出现抽象类中。</strong></p><p>抽象方法示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">AbstractMethodDemo</span> &#123;<br>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">AbstractClass</span> &#123;<br>        <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">print</span><span class="hljs-params">()</span>; <span class="hljs-comment">// 不用实现</span><br>    &#125;<br><br>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ConcreteClass</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">AbstractClass</span> &#123;<br>        <span class="hljs-meta">@Override</span><br>        <span class="hljs-keyword">void</span> <span class="hljs-title function_">print</span><span class="hljs-params">()</span> &#123;<br>            System.out.println(<span class="hljs-string">&quot;call print()&quot;</span>);<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">AbstractClass</span> <span class="hljs-variable">demo</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ConcreteClass</span>();<br>        demo.print();<br>    &#125;<br><br>&#125;<br><span class="hljs-comment">// Outpu:</span><br><span class="hljs-comment">// call print()</span><br></code></pre></td></tr></table></figure><h3 id="synchronized"><a href="#synchronized" class="headerlink" title="synchronized"></a>synchronized</h3><p><code>synchronized</code> 用于并发编程。<strong>被 <code>synchronized</code> 修饰的方法在一个时刻，只允许一个线程执行，相当于锁。</strong></p><blockquote><p>在 Java 的同步容器（Vector、Stack、HashTable）中，会有大量的 synchronized 方法。不过，请记住：在 Java 并发编程中，synchronized 方法并不是一个好的选择，大多数情况下，我们会选择更加轻量级的锁 。</p></blockquote><h2 id="特殊方法"><a href="#特殊方法" class="headerlink" title="特殊方法"></a>特殊方法</h2><p>Java 中，有一些较为特殊的方法，分别使用于特殊的场景。</p><h3 id="main-方法"><a href="#main-方法" class="headerlink" title="main 方法"></a>main 方法</h3><p>Java 中的 main 方法是一种特殊的静态方法，因为所有的 Java 程序都是由 <code>public static void main(String[] args)</code> 方法开始执行，main 方法中的 args 是用来接收接收命令行输入参数的。</p><p>示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MainMethodDemo</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-keyword">for</span> (String arg : args) &#123;<br>            System.out.println(<span class="hljs-string">&quot;arg = [&quot;</span> + arg + <span class="hljs-string">&quot;]&quot;</span>);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>依次执行</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java">javac MainMethodDemo.java<br>java MainMethodDemo A B C<br></code></pre></td></tr></table></figure><p>控制台会打印输出参数：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java">arg = [A]<br>arg = [B]<br>arg = [C]<br></code></pre></td></tr></table></figure><h3 id="构造方法"><a href="#构造方法" class="headerlink" title="构造方法"></a>构造方法</h3><ul><li><p>任何类都有构造方法，构造方法的作用就是在初始化类实例时，设置实例的状态。</p></li><li><p>每个类都有构造方法。如果没有显式地为类定义任何构造方法，Java 编译器将会为该类提供一个默认构造方法。</p></li><li><p>在创建一个对象的时候，至少要调用一个构造方法。构造方法的名称必须与类同名，一个类可以有多个构造方法。</p></li></ul><p><strong>注意，构造方法可以使用 private 修饰，这种情况下，类无法调用此构造方法去实例化对象，这常常用于设计模式中的单例模式。</strong></p><h3 id="finalize-方法"><a href="#finalize-方法" class="headerlink" title="finalize() 方法"></a>finalize() 方法</h3><p><code>finalize</code> 在对象被垃圾收集器析构(回收)之前调用，用来清除回收对象。</p><p>finalizer() 通常是不可预测的，也是很危险的，一般情况下是<strong>不必要的</strong>。使用终结方法会导致行为不稳定、降低性能，以及可移植性问题。</p><blockquote><p>所以，<strong>应该尽量避免使用 <code>finalizer()</code><strong>。千万不要把它当成是 C&#x2F;C++ 中的析构函数来用。原因是：</strong>Finalizer 线程会和我们的主线程进行竞争，不过由于它的优先级较低，获取到的 CPU 时间较少，因此它永远也赶不上主线程的步伐。所以最后可能会发生 OutOfMemoryError 异常。</strong></p><p>参考：<a href="https://zhuanlan.zhihu.com/p/27850176">重载 Finalize 引发的内存泄露</a></p></blockquote><h2 id="覆写和重载"><a href="#覆写和重载" class="headerlink" title="覆写和重载"></a>覆写和重载</h2><p><strong>覆写（Override）是指子类定义了与父类中同名的方法，但是在方法覆写时必须考虑到访问权限，子类覆写的方法不能拥有比父类更加严格的访问权限。</strong></p><p>覆写示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MethodOverrideDemo</span> &#123;<br>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Animal</span> &#123;<br>        <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">move</span><span class="hljs-params">()</span> &#123;<br>            System.out.println(<span class="hljs-string">&quot;会动&quot;</span>);<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Dog</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Animal</span> &#123;<br>        <span class="hljs-meta">@Override</span><br>        <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">move</span><span class="hljs-params">()</span> &#123;<br>            <span class="hljs-built_in">super</span>.move();<br>            System.out.println(<span class="hljs-string">&quot;会跑&quot;</span>);<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">Animal</span> <span class="hljs-variable">dog</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Dog</span>();<br>        dog.move();<br>    &#125;<br>&#125;<br><span class="hljs-comment">// Output:</span><br><span class="hljs-comment">// 会动</span><br><span class="hljs-comment">// 会跑</span><br></code></pre></td></tr></table></figure><p><strong>方法的重载（Overload）是指方法名称相同，但参数的类型或参数的个数不同。通过传递参数的个数及类型的不同可以完成不同功能的方法调用。</strong></p><blockquote><p>注意：重载一定是方法的参数不完全相同。如果方法的参数完全相同，仅仅是返回值不同，Java 是无法编译通过的。</p></blockquote><p>重载示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MethodOverloadDemo</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">add</span><span class="hljs-params">(<span class="hljs-type">int</span> x, <span class="hljs-type">int</span> y)</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;x + y = &quot;</span> + (x + y));<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">add</span><span class="hljs-params">(<span class="hljs-type">double</span> x, <span class="hljs-type">double</span> y)</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;x + y = &quot;</span> + (x + y));<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        add(<span class="hljs-number">10</span>, <span class="hljs-number">20</span>);<br>        add(<span class="hljs-number">1.0</span>, <span class="hljs-number">2.0</span>);<br>    &#125;<br>&#125;<br><span class="hljs-comment">// Output:</span><br><span class="hljs-comment">// x + y = 30</span><br><span class="hljs-comment">// x + y = 3.0</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>JavaSE</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java</tag>
      
      <tag>方法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Java 面向对象</title>
    <link href="/java%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1.html"/>
    <url>/java%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1.html</url>
    
    <content type="html"><![CDATA[<p>Java 面向对象具有以下三个主要特征：一、封装（Encapsulation）；二、继承（Inheritance）；三、多态（Polymorphism）。封装使得对象的内部状态和行为对外部不可见，这不仅提高了代码的可维护性和复用性，还可以保护数据的安全性。</p><span id="more"></span><h2 id="面向对象"><a href="#面向对象" class="headerlink" title="面向对象"></a>面向对象</h2><p>每种编程语言，都有自己的操纵内存中元素的方式。Java 中提供了基本数据类型，但这还不能满足编写程序时，需要抽象更加复杂数据类型的需要。因此，Java 中，允许开发者通过类创建自定义类型。</p><p>Java 世界有一句名言：一切皆为对象。这句话，你可能第一天学 Java 时，就听过了。这不仅仅是一句口号，也体现在 Java 的设计上。</p><ul><li>首先，所有 Java 类都继承自 <code>Object</code> 类（从这个名字，就可见一斑）。</li><li>几乎所有 Java 对象初始化时，都要使用 <code>new</code> 创建对象（基本数据类型、String、枚举特殊处理），对象存储在堆中。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">String</span> <span class="hljs-variable">s</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;abc&quot;</span>;<br><span class="hljs-type">String</span> <span class="hljs-variable">s</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>(<span class="hljs-string">&quot;abc&quot;</span>);<br></code></pre></td></tr></table></figure><p>其中，<code>String s</code> 定义了一个名为 s 的引用，它指向一个 <code>String</code> 类型的对象，而实际的对象是 <code>“abc”</code> 字符串。</p><p><strong>与 C&#x2F;C++ 这类语言不同，程序员只需要通过 <code>new</code> 创建一个对象，但不必负责销毁或结束一个对象。</strong>负责运行 Java 程序的 Java 虚拟机有一个垃圾回收器，它会监视 <code>new</code> 创建的对象，一旦发现对象不再被引用，则会释放对象的内存空间。</p><h3 id="封装"><a href="#封装" class="headerlink" title="封装"></a>封装</h3><p><strong>封装（Encapsulation）是指一种将抽象性函式接口的实现细节部份包装、隐藏起来的方法。</strong></p><p>封装最主要的作用在于我们能修改自己的实现代码，而不用修改那些调用我们代码的程序片段。</p><p>封装的优点：</p><ul><li>良好的封装能够减少耦合。</li><li>类内部的结构可以自由修改。</li><li>可以对成员变量进行更精确的控制。</li><li>隐藏信息，实现细节。</li></ul><p>实现封装的步骤：</p><ol><li>修改属性的可见性来限制对属性的访问（一般限制为 private）。</li><li>对每个值属性提供对外的公共方法访问，也就是创建一对赋取值方法，用于对私有属性的访问。</li></ol><h3 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h3><p><strong>继承（Inheritance）是子类继承父类的特征和行为，使得子类对象（实例）具有父类的实例域和方法，或子类从父类继承方法，使得子类具有父类相同的行为。</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 子类继承父类</span><br>class 父类 &#123;&#125;<br>class 子类 extends 父类 &#123;&#125;<br></code></pre></td></tr></table></figure><h4 id="继承的特性"><a href="#继承的特性" class="headerlink" title="继承的特性"></a>继承的特性</h4><ul><li>子类可以继承父类的属性和方法。需要注意的是，<strong>构造方法除外，构造方法只能被调用，而不能被继承。</strong></li><li>子类可以拥有自己的属性和方法，即子类可以对父类进行<strong>扩展</strong>。</li><li>子类可以用自己的方式实现父类的方法。</li><li>Java 的继承是<strong>单继承</strong>，但是可以多重继承，单继承就是一个子类只能继承一个父类，<strong>多重继承就是，例如 A 类继承 B 类，B 类继承 C 类</strong>（传递性质），所以按照关系就是 C 类是 B 类的父类，B 类是 A 类的父类，这是 Java 继承区别于 C++ 继承的一个特性。</li><li>提高了类之间的<strong>耦合性</strong>（继承的缺点，耦合度高就会造成代码之间的联系越紧密，代码独立性越差）。</li></ul><h4 id="继承关键字"><a href="#继承关键字" class="headerlink" title="继承关键字"></a>继承关键字</h4><p>继承可以使用 <code>extends</code> 和 <code>implements</code> 这两个关键字来实现继承，而且所有的类都是继承于 <code>java.lang.Object</code>，当一个类没有继承的两个关键字，则默认继承 <code>Object</code>（这个类在 <strong><code>java.lang</code></strong> 包中，所以不需要 **<code>import</code>**）祖先类。</p><h3 id="多态"><a href="#多态" class="headerlink" title="多态"></a>多态</h3><p><strong>多态(Polymorphism）是指在面向对象编程中，同一个类的对象在不同情况下表现出不同的行为和状态</strong>。 子类可以继承父类的属性和方法，子类对象可以直接使用父类中的方法和变量。 子类可以对从父类继承的方法进行<strong>重新实现</strong>，使得子类对象调用这个方法时表现出不同的行为。</p><h2 id="类"><a href="#类" class="headerlink" title="类"></a>类</h2><p>与大多数面向对象编程语言一样，Java 使用 <code>class</code>（类）关键字来表示自定义类型。自定义类型是为了更容易抽象现实事物。</p><p>在一个类中，可以设置一静一动两种元素：属性（静）和方法（动）。</p><ul><li><strong>属性（成员、字段）</strong> - 属性抽象的是事物的状态。</li><li><strong>方法（为函数）</strong> - 方法抽象的是事物的行为。</li></ul><h2 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h2><p>Java 方法（又称为函数）是定义在类中的一段独立的代码块，用来实现某个功能，解决了重复性代码的问题。方法的主要作用是为了提高程序的复用性和可读性。</p><h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java">修饰符 返回值类型 方法名(参数类型 参数名)&#123;<br>    ...<br>    方法体<br>    ...<br>    <span class="hljs-keyword">return</span> 返回值;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="构造方法"><a href="#构造方法" class="headerlink" title="构造方法"></a>构造方法</h3><p>每个类都有构造方法。如果没有显式地为类定义任何构造方法，Java 编译器将会为该类提供一个默认构造方法。</p><p>在创建一个对象的时候，至少要调用一个构造方法。构造方法的名称必须与类同名，一个类可以有多个构造方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Puppy</span>&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">Puppy</span><span class="hljs-params">()</span>&#123;<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">Puppy</span><span class="hljs-params">(String name)</span>&#123;<br>        <span class="hljs-comment">// 这个构造器仅有一个参数：name</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h2><p>Java 支持的变量类型有：</p><ul><li><code>局部变量</code> - 类方法中的变量。</li><li><code>实例变量（也叫成员变量）</code> - 类方法外的变量，不过没有 <code>static</code> 修饰。</li><li><code>类变量（也叫静态变量）</code> - 类方法外的变量，用 <code>static</code> 修饰。</li></ul><h3 id="变量修饰符"><a href="#变量修饰符" class="headerlink" title="变量修饰符"></a>变量修饰符</h3><ul><li>访问级别修饰符 - 如果变量是实例变量或类变量，可以添加访问级别修饰符（public&#x2F;protected&#x2F;private）</li><li>静态修饰符 - 如果变量是类变量，需要添加 static 修饰</li><li>final - 如果变量使用 final 修饰符，就表示这是一个<strong>常量</strong>，<strong>不能被修改</strong>。</li></ul><h3 id="创建对象"><a href="#创建对象" class="headerlink" title="创建对象"></a>创建对象</h3><p>对象是根据类创建的。在 Java 中，使用关键字 new 来创建一个新的对象。创建对象需要以下三步：</p><ul><li><strong>声明</strong>：声明一个对象，包括对象名称和对象类型。</li><li><strong>实例化</strong>：使用关键字 new 来创建一个对象。</li><li><strong>初始化</strong>：使用 new 创建对象时，会调用构造方法初始化对象。</li></ul><h2 id="访问权限控制"><a href="#访问权限控制" class="headerlink" title="访问权限控制"></a>访问权限控制</h2><h3 id="代码组织"><a href="#代码组织" class="headerlink" title="代码组织"></a>代码组织</h3><p><strong>当编译一个 .java 文件时，在 .java 文件中的每个类都会输出一个与类同名的 .class 文件。</strong></p><p>MultiClassDemo.java 示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">MultiClass1</span> &#123;&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">MultiClass2</span> &#123;&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">MultiClass3</span> &#123;&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MultiClassDemo</span> &#123;&#125;<br></code></pre></td></tr></table></figure><p>执行 <code>javac MultiClassDemo.java</code> 命令，本地会生成 MultiClass1.class、MultiClass2.class、MultiClass3.class、MultiClassDemo.class 四个文件。</p><p><strong>Java 可运行程序是由一组 .class 文件打包并压缩成的一个 .jar 文件</strong>。Java 解释器负责这些文件的查找、装载和解释。<strong>Java 类库实际上是一组类文件（.java 文件）。</strong></p><ul><li><strong>其中每个文件允许有一个 public 类，以及任意数量的非 public 类</strong>。</li><li><strong>public 类名必须和 .java 文件名完全相同，包括大小写。</strong></li></ul><p>程序一般不止一个人编写，会调用系统提供的代码、第三方库中的代码、项目中其他人写的代码等，不同的人因为不同的目的可能定义同样的类名&#x2F;接口名，这就是命名冲突。</p><p>Java 中为了解决命名冲突问题，提供了包（<code>package</code>）和导入（<code>import</code>）机制。</p><h4 id="package"><a href="#package" class="headerlink" title="package"></a>package</h4><p>包（<code>package</code>）的原则：</p><ul><li>包类似于文件夹，文件放在文件夹中，类和接口则放在包中。为了便于组织，文件夹一般是一个<strong>有层次的树形结构</strong>，包也类似。</li><li><strong>包名以逗号 <code>.</code> 分隔，表示层次结构。</strong></li><li>Java 中命名包名的一个惯例是<strong>使用域名作为前缀</strong>，因为域名是唯一的，一般按照<strong>域名的反序来定义包名</strong>，比如，域名是：apache.org，包名就以 org.apache 开头。</li><li><strong>包名和文件目录结构必须完全匹配。</strong>Java 解释器运行过程如下：<ul><li>找出环境变量 CLASSPATH，作为 .class 文件的根目录。</li><li>从根目录开始，获取包名称，并将逗号 <code>.</code> 替换为文件分隔符（反斜杠 <code>/</code>），通过这个路径名称去查找 Java 类。</li></ul></li></ul><h4 id="import"><a href="#import" class="headerlink" title="import"></a>import</h4><p>同一个包下的类之间互相引用是不需要包名的，可以直接使用。但如果类不在同一个包内，则必须要知道其所在的包，使用有两种方式：</p><ul><li><p>通过类的完全限定名</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">PackageDemo</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span> <span class="hljs-params">(String[]args)</span>&#123;<br>        System.out.println(<span class="hljs-keyword">new</span> <span class="hljs-title class_">java</span>.util.Date());<br>        System.out.println(<span class="hljs-keyword">new</span> <span class="hljs-title class_">java</span>.util.Date());<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>通过 import 将用到的类引入到当前类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.util.Date;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">PackageDemo2</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        System.out.println(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Date</span>());<br>        System.out.println(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Date</span>());<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li></ul><p>显然是 <code>import</code> 方式，代码更加整洁。</p><h3 id="访问权限修饰关键字"><a href="#访问权限修饰关键字" class="headerlink" title="访问权限修饰关键字"></a>访问权限修饰关键字</h3><p>访问权限控制的等级，从最大权限到最小权限依次为：</p><figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs actionscript"><span class="hljs-keyword">public</span> &gt; <span class="hljs-keyword">protected</span> &gt; 包访问权限（没有任何关键字）&gt; <span class="hljs-keyword">private</span><br></code></pre></td></tr></table></figure><ul><li><code>public</code> - 表示任何类都可以访问；</li><li><code>包访问权限</code> - 包访问权限，没有任何关键字。它表示当前包中的所有其他类都可以访问，但是其它包的类无法访问。</li><li><code>protected</code> - 表示子类可以访问，此外，<strong>同一个包内的其他类也可以访问</strong>，即使这些类不是子类。</li><li><code>private</code> - 表示其它任何类都无法访问。</li></ul><h2 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h2><p>接口是对行为的抽象，它是抽象方法的集合，利用接口可以达到 API 定义和实现分离的目的。</p><p>接口，不能实例化；不能包含任何非常量成员，任何 field 都是隐含着 <code>public static final</code> 的意义；同时，没有非静态方法实现，<strong>也就是说要么是抽象方法，要么是静态方法</strong>。</p><p>Java 标准类库中，定义了非常多的接口，比如 <code>java.util.List</code>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">Comparable</span>&lt;T&gt; &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">compareTo</span><span class="hljs-params">(T o)</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="抽象类"><a href="#抽象类" class="headerlink" title="抽象类"></a>抽象类</h2><p>抽象类是不能实例化的类，用 <code>abstract</code> 关键字修饰 <code>class</code>，其目的主要是代码重用。除了不能实例化，形式上和一般的 Java 类并没有太大区别，可以有一个或者多个抽象方法，也可以没有抽象方法。抽象类大多用于抽取相关 Java 类的共用方法实现或者是共同成员变量，然后通过继承的方式达到代码复用的目的。</p><ol><li>抽象类不能被实例化(初学者很容易犯的错)，如果被实例化，就会报错，编译无法通过。只有抽象类的非抽象子类可以创建对象。</li><li>抽象类中不一定包含抽象方法，但是有抽象方法的类必定是抽象类。</li><li>抽象类中的抽象方法只是声明，不包含方法体，就是不给出方法的具体实现也就是方法的具体功能。</li><li>构造方法，类方法（用 static 修饰的方法）不能声明为抽象方法。</li><li>抽象类的子类必须给出抽象类中的抽象方法的具体实现，除非该子类也是抽象类。</li></ol>]]></content>
    
    
    <categories>
      
      <category>JavaSE</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java</tag>
      
      <tag>oop</tag>
      
      <tag>类</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Java 数据类型</title>
    <link href="/java%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B.html"/>
    <url>/java%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B.html</url>
    
    <content type="html"><![CDATA[<p>Java 中的数据类型有两类：值类型（又叫内置数据类型，基本数据类型），引用类型（除值类型以外，都是引用类型，包括字符串、数组等）。</p><span id="more"></span><h2 id="数据类型分类"><a href="#数据类型分类" class="headerlink" title="数据类型分类"></a>数据类型分类</h2><p>Java 数据类型分为值类型和引用类型：</p><ul><li>值类型包括：boolean、char、byte、short、int、long、float 、double。</li><li>引用类型包括：数组、类、接口、枚举。</li></ul><h3 id="值类型"><a href="#值类型" class="headerlink" title="值类型"></a>值类型</h3><p>Java 语言提供了 <strong>8</strong> 种基本类型，大致分为 <strong>4</strong> 类。</p><table><thead><tr><th>基本数据类型</th><th>分类</th><th>比特数</th><th>默认值</th><th>取值范围</th></tr></thead><tbody><tr><td><code>boolean</code></td><td><strong>布尔型</strong></td><td>8 位</td><td><code>false</code></td><td>{false, true}</td></tr><tr><td><code>char</code></td><td><strong>字符型</strong></td><td>16 位</td><td><code>&#39;\u0000&#39;</code></td><td>[0, $2^{16} - 1$]</td></tr><tr><td><code>byte</code></td><td><strong>整数型</strong></td><td>8 位</td><td><code>0</code></td><td>[-$2^7$, $2^7 - 1$]</td></tr><tr><td><code>short</code></td><td><strong>整数型</strong></td><td>16 位</td><td><code>0</code></td><td>[-$2^{15}$, $2^{15} - 1$]</td></tr><tr><td><code>int</code></td><td><strong>整数型</strong></td><td>32 位</td><td><code>0</code></td><td>[-$2^{31}$, $2^{31} - 1$]</td></tr><tr><td><code>long</code></td><td><strong>整数型</strong></td><td>64 位</td><td><code>0L</code></td><td>[-$2^{63}$, $2^{63} - 1$]</td></tr><tr><td><code>float</code></td><td><strong>浮点型</strong></td><td>32 位</td><td><code>+0.0F</code></td><td>[$2^{-149}$, $2^{128} - 1$]</td></tr><tr><td><code>double</code></td><td><strong>浮点型</strong></td><td>64 位</td><td><code>+0.0D</code></td><td>[$2^{-1074}$, $2^{1024} - 1$]</td></tr></tbody></table><p>尽管各种数据类型的默认值看起来不一样，但在内存中都是零。</p><p>在这些基本类型中，<code>boolean</code> 和 <code>char</code> 是唯二的无符号类型。</p><h3 id="值类型和引用类型的区别"><a href="#值类型和引用类型的区别" class="headerlink" title="值类型和引用类型的区别"></a>值类型和引用类型的区别</h3><ul><li>从概念方面来说<ul><li>基本类型：变量名指向具体的数值。</li><li>引用类型：变量名指向存数据对象的内存地址。</li></ul></li><li>从内存方面来说<ul><li>基本类型：变量在声明之后，Java 就会立刻分配给他内存空间。</li><li>引用类型：它以特殊的方式（类似 C 指针）向对象实体（具体的值），这类变量声明时不会分配内存，只是存储了一个内存地址。</li></ul></li><li>从使用方面来说<ul><li>基本类型：使用时需要赋具体值,判断时使用 <code>==</code> 号。</li><li>引用类型：使用时可以赋 null，判断时使用 <code>equals</code> 方法。</li></ul></li></ul><blockquote><p><a href="https://juejin.im/post/59cd71835188255d3448faf6">Java 基本数据类型和引用类型</a></p></blockquote><h2 id="数据转换"><a href="#数据转换" class="headerlink" title="数据转换"></a>数据转换</h2><p>Java 中，数据类型转换有两种方式：</p><ul><li>自动转换</li><li>强制转换</li></ul><h3 id="自动转换"><a href="#自动转换" class="headerlink" title="自动转换"></a>自动转换</h3><p>一般情况下，定义了某数据类型的变量，就不能再随意转换。但是 JAVA 允许用户对基本类型做<strong>有限度</strong>的类型转换。</p><p>如果符合以下条件，则 JAVA 将会自动做类型转换：</p><ul><li><p><strong>由小数据转换为大数据</strong>，显而易见的是，“小”数据类型的数值表示范围小于“大”数据类型的数值表示范围，即精度小于“大”数据类型。这些类型由“小”到“大”分别为：(byte，short，char) &lt; int &lt; long &lt; float &lt; double。</p></li><li><p><strong>转换前后的数据类型要兼容</strong>，由于 boolean 类型只能存放 true 或 false，这与整数或字符是不兼容的，因此不可以做类型转换。</p></li><li><p><strong>整型类型和浮点型进行计算后，结果会转为浮点类型</strong></p></li></ul><p>例如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">long</span> <span class="hljs-variable">x</span> <span class="hljs-operator">=</span> <span class="hljs-number">30</span>;<br><span class="hljs-type">float</span> <span class="hljs-variable">y</span> <span class="hljs-operator">=</span> <span class="hljs-number">14.3f</span>;<br>System.out.println(<span class="hljs-string">&quot;x/y = &quot;</span> + x/y);<br></code></pre></td></tr></table></figure><p>输出：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">x/y = <span class="hljs-number">1.9607843</span><br></code></pre></td></tr></table></figure><p>可见 long 虽然精度大于 float 类型，但是结果为浮点数类型。</p><h3 id="强制转换"><a href="#强制转换" class="headerlink" title="强制转换"></a>强制转换</h3><p>在不符合自动转换条件时或者根据用户的需要，可以对数据类型做强制的转换。</p><p><strong>强制转换使用括号 <code>()</code> 。</strong></p><p>引用类型也可以使用强制转换。</p><p>例如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">float</span> <span class="hljs-variable">f</span> <span class="hljs-operator">=</span> <span class="hljs-number">25.5f</span>;<br><span class="hljs-type">int</span> <span class="hljs-variable">x</span> <span class="hljs-operator">=</span> (<span class="hljs-type">int</span>)f;<br>System.out.println(<span class="hljs-string">&quot;x = &quot;</span> + x);<br></code></pre></td></tr></table></figure><h2 id="装箱和拆箱"><a href="#装箱和拆箱" class="headerlink" title="装箱和拆箱"></a>装箱和拆箱</h2><p><strong>引入包装类的目的</strong>就是：提供一种机制，使得<strong>基本数据类型可以与引用类型互相转换</strong>。</p><p>基本数据类型与包装类的转换被称为<code>装箱</code>和<code>拆箱</code>。</p><ul><li><strong><code>装箱</code>（boxing）是将值类型转换为引用类型</strong>。例如：<code>int</code> 转 <code>Integer</code><ul><li>装箱过程是通过调用包装类的 <code>valueOf</code> 方法实现的。</li></ul></li><li><strong><code>拆箱</code>（unboxing）是将引用类型转换为值类型</strong>。例如：<code>Integer</code> 转 <code>int</code><ul><li>拆箱过程是通过调用包装类的 <code>xxxValue</code> 方法实现的。（xxx 代表对应的基本数据类型）。</li></ul></li></ul><h3 id="包装器类型"><a href="#包装器类型" class="headerlink" title="包装器类型"></a>包装器类型</h3><ul><li>Byte（对应 byte）</li><li>Short（对应 short）</li><li>Integer（对应 int）</li><li>Long（对应 long）</li><li>Float（对应 float）</li><li>Double（对应 double）</li><li>Character（对应 char）</li><li>Boolean（对应 boolean）</li></ul><h3 id="自动装箱"><a href="#自动装箱" class="headerlink" title="自动装箱"></a><strong>自动装箱</strong></h3><p>隐式地创建对象</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">Integer</span> <span class="hljs-variable">i1</span> <span class="hljs-operator">=</span> <span class="hljs-number">10</span>; <span class="hljs-comment">// 自动装箱</span><br><span class="hljs-type">Integer</span> <span class="hljs-variable">i2</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Integer</span>(<span class="hljs-number">10</span>); <span class="hljs-comment">// 非自动装箱</span><br><span class="hljs-type">Integer</span> <span class="hljs-variable">i3</span> <span class="hljs-operator">=</span> Integer.valueOf(<span class="hljs-number">10</span>); <span class="hljs-comment">// 非自动装箱</span><br><span class="hljs-type">int</span> <span class="hljs-variable">i4</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Integer</span>(<span class="hljs-number">10</span>); <span class="hljs-comment">// 自动拆箱</span><br><span class="hljs-type">int</span> <span class="hljs-variable">i5</span> <span class="hljs-operator">=</span> i2.intValue(); <span class="hljs-comment">// 非自动拆箱</span><br></code></pre></td></tr></table></figure><p>注意：</p><ul><li>对于 <code>i1 == i2</code> 输出为 <code>false</code>，因为 i1 和 i2 都是包装类，java 将它们当作两个<strong>对象</strong>，自然不相等。</li><li>对于 <code>i1 == i4</code> 输出为 <code>true</code>，因为 i4 为值，java 自动将 i1 这个包装类<strong>自动拆箱</strong>为一个 <code>int</code> 值。</li></ul><h3 id="装箱、拆箱注意点"><a href="#装箱、拆箱注意点" class="headerlink" title="装箱、拆箱注意点"></a>装箱、拆箱注意点</h3><ol><li>装箱操作会创建对象，频繁的装箱操作会造成不必要的内存消耗，影响性能。所以<strong>应该尽量避免装箱。</strong></li><li>基础数据类型的比较操作使用 <code>==</code>，包装类的比较操作使用 <code>equals</code> 方法。</li></ol><blockquote><p><a href="https://www.cnblogs.com/dolphin0520/p/3780005.html">深入剖析 Java 中的装箱和拆箱</a></p></blockquote><h2 id="判等问题"><a href="#判等问题" class="headerlink" title="判等问题"></a>判等问题</h2><p>Java 中，通常使用 <code>equals</code> 或 <code>==</code> 进行判等操作。<code>equals</code> 是方法而 <code>==</code> 是操作符。此外，二者使用也是有区别的：</p><ul><li>对<strong>基本类型</strong>，比如 <code>int</code>、<code>long</code>，进行判等，<strong>只能使用 <code>==</code>，比较的是字面值</strong>。因为基本类型的值就是其数值。</li><li>对<strong>引用类型</strong>，比如 <code>Integer</code>、<code>Long</code> 和 <code>String</code>，进行判等，<strong>需要使用 <code>equals</code> 进行内容判等</strong>。因为引用类型的直接值是指针，使用 <code>==</code> 的话，比较的是指针，也就是两个对象在内存中的地址，即比较它们是不是同一个对象，而不是比较对象的内容。</li></ul><h3 id="包装类的判等"><a href="#包装类的判等" class="headerlink" title="包装类的判等"></a>包装类的判等</h3><p>【示例】包装类的判等</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">Integer</span> <span class="hljs-variable">a</span> <span class="hljs-operator">=</span> <span class="hljs-number">127</span>; <span class="hljs-comment">//Integer.valueOf(127)</span><br><span class="hljs-type">Integer</span> <span class="hljs-variable">b</span> <span class="hljs-operator">=</span> <span class="hljs-number">127</span>; <span class="hljs-comment">//Integer.valueOf(127)</span><br><span class="hljs-comment">// a == b ? true</span><br><br><span class="hljs-type">Integer</span> <span class="hljs-variable">c</span> <span class="hljs-operator">=</span> <span class="hljs-number">128</span>; <span class="hljs-comment">//Integer.valueOf(128)</span><br><span class="hljs-type">Integer</span> <span class="hljs-variable">d</span> <span class="hljs-operator">=</span> <span class="hljs-number">128</span>; <span class="hljs-comment">//Integer.valueOf(128)</span><br><span class="hljs-comment">// c == d ? alse</span><br><span class="hljs-comment">//设置-XX:AutoBoxCacheMax=1000再试试</span><br><br><span class="hljs-type">Integer</span> <span class="hljs-variable">e</span> <span class="hljs-operator">=</span> <span class="hljs-number">127</span>; <span class="hljs-comment">//Integer.valueOf(127)</span><br><span class="hljs-type">Integer</span> <span class="hljs-variable">f</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Integer</span>(<span class="hljs-number">127</span>); <span class="hljs-comment">//new instance</span><br><span class="hljs-comment">// e == f ? false</span><br><br><span class="hljs-type">Integer</span> <span class="hljs-variable">g</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Integer</span>(<span class="hljs-number">127</span>); <span class="hljs-comment">//new instance</span><br><span class="hljs-type">Integer</span> <span class="hljs-variable">h</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Integer</span>(<span class="hljs-number">127</span>); <span class="hljs-comment">//new instance</span><br><span class="hljs-comment">// g == h ? false</span><br><br><span class="hljs-type">Integer</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">128</span>; <span class="hljs-comment">//unbox</span><br><span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">128</span>;<br><span class="hljs-comment">// i == j ? true</span><br></code></pre></td></tr></table></figure><ul><li><p>第一个案例中，编译器会把 <code>Integer a = 127</code> 转换为 <code>Integer.valueOf(127)</code>。查看源码可以发现，这个转换在内部其实做了缓存，<strong>使得两个 Integer 指向同一个对象</strong>，所以 &#x3D;&#x3D; 返回 true。</p></li><li><p>第二个案例中，之所以同样的代码 128 就返回 false 的原因是，默认情况下会缓存[-128,127]的数值，而 128 处于这个区间之外。设置 JVM 参数加上 -XX:AutoBoxCacheMax&#x3D;1000 再试试，是不是就返回 true 了呢？</p></li><li><p>第三和第四个案例中，New 出来的 Integer 始终是<strong>不走缓存的新对象</strong>。比较两个新对象，或者比较一个新对象和一个来自缓存的对象，结果肯定不是相同的对象，因此返回 false。</p></li><li><p>第五个案例中，我们把装箱的 Integer 和基本类型 int 比较，前者会先拆箱再比较，比较的肯定是<strong>数值</strong>而不是引用，因此返回 true。</p></li></ul><blockquote><p>【总结】综上，我们可以得出结论：包装类需要使用 <code>equals</code> 进行内容判等，而不能使用 <code>==</code>。</p></blockquote><h3 id="String-的判等"><a href="#String-的判等" class="headerlink" title="String 的判等"></a>String 的判等</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">String</span> <span class="hljs-variable">a</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;1&quot;</span>;<br><span class="hljs-type">String</span> <span class="hljs-variable">b</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;1&quot;</span>;<br><span class="hljs-comment">// a == b ? true</span><br><br><span class="hljs-type">String</span> <span class="hljs-variable">c</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>(<span class="hljs-string">&quot;2&quot;</span>);<br><span class="hljs-type">String</span> <span class="hljs-variable">d</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>(<span class="hljs-string">&quot;2&quot;</span>);<br><span class="hljs-comment">// c == d ? false</span><br><br><span class="hljs-type">String</span> <span class="hljs-variable">e</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>(<span class="hljs-string">&quot;3&quot;</span>).intern(); <span class="hljs-comment">// 走常量池机制</span><br><span class="hljs-type">String</span> <span class="hljs-variable">f</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>(<span class="hljs-string">&quot;3&quot;</span>).intern();<br><span class="hljs-comment">// e == f ? true</span><br><br><span class="hljs-type">String</span> <span class="hljs-variable">g</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>(<span class="hljs-string">&quot;4&quot;</span>);<br><span class="hljs-type">String</span> <span class="hljs-variable">h</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>(<span class="hljs-string">&quot;4&quot;</span>);<br><span class="hljs-comment">// g.equals(h)) ? true</span><br></code></pre></td></tr></table></figure><blockquote><p>在 JVM 中，当代码中出现双引号形式创建<strong>字符串对象</strong>时，JVM 会先对这个字符串进行检查，如果字符串常量池中存在相同内容的字符串对象的引用，则将这个引用返回；否则，创建新的字符串对象，然后将这个引用放入字符串常量池，并返回该引用。这种机制，就是<strong>字符串驻留或池化</strong>。</p></blockquote><ul><li><p>第一个案例返回 true，因为 Java 的字符串<strong>驻留机制</strong>，直接使用双引号声明出来的两个 String 对象指向<strong>常量池</strong>中的相同字符串。</p></li><li><p>第二个案例，new 出来的两个 String 是不同对象，引用当然不同，所以得到 false 的结果。</p></li><li><p>第三个案例，使用 String 提供的 intern 方法也会<strong>走常量池机制</strong>，所以同样能得到 true。</p></li><li><p>第四个案例，通过 equals 对值内容判等，是正确的处理方式，当然会得到 true。</p></li></ul><p><em>虽然使用 new 声明的字符串调用 intern 方法，也可以让字符串进行驻留，但在业务代码中滥用 intern，可能会产生性能问题。</em></p><p><strong>原因</strong>在于：字符串常量池是一个固定容量的 <strong>Map</strong>。如果容量太小（Number of buckets&#x3D;60013）、字符串太多（1000 万个字符串），那么每一个桶中的字符串数量会非常多，所以搜索起来就很慢。</p><p><strong>解决方法</strong>是：设置 JVM 参数 -XX:StringTableSize&#x3D;10000000，指定更多的桶。</p><h3 id="实现-equals"><a href="#实现-equals" class="headerlink" title="实现 equals"></a>实现 equals</h3><p>Object 类源码里 equals 的实现其实是比较对象引用</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">equals</span><span class="hljs-params">(Object obj)</span> &#123;<br>    <span class="hljs-keyword">return</span> (<span class="hljs-built_in">this</span> == obj);<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>对于自定义类型，如果不覆写 equals 的话，默认就是使用 Object 基类的按引用的比较方式。</strong></p><p>实现一个更好的 equals 应该注意的点：</p><ul><li>考虑到性能，可以先进行指针判等，如果对象是同一个那么直接返回 true；</li><li>需要对另一方进行判空，空对象和自身进行比较，结果一定是 fasle；</li><li>需要判断两个对象的类型，如果类型都不同，那么直接返回 false；</li><li>确保类型相同的情况下再进行类型强制转换，然后逐一判断所有字段。</li></ul><p>自定义 equals 示例</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 自定义类</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Point</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> x;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> y;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> String desc;<br>&#125;<br><br><span class="hljs-comment">// 自定义equals：</span><br><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">equals</span><span class="hljs-params">(Object o)</span> &#123;<br>    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">this</span> == o) <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    <span class="hljs-keyword">if</span> (o == <span class="hljs-literal">null</span> || getClass() != o.getClass()) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    <span class="hljs-type">Point</span> <span class="hljs-variable">that</span> <span class="hljs-operator">=</span> (Point) o;<br>    <span class="hljs-keyword">return</span> x == that.x &amp;&amp; y == that.y;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="数值计算"><a href="#数值计算" class="headerlink" title="数值计算"></a>数值计算</h2><h3 id="浮点数计算问题"><a href="#浮点数计算问题" class="headerlink" title="浮点数计算问题"></a>浮点数计算问题</h3><p>计算机是把数值保存在了变量中，不同类型的数值变量能保存的数值范围不同，当数值超过类型能表达的数值上限则会发生溢出问题。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java">System.out.println(<span class="hljs-number">0.1</span> + <span class="hljs-number">0.2</span>); <span class="hljs-comment">// 0.30000000000000004</span><br>System.out.println(<span class="hljs-number">1.0</span> - <span class="hljs-number">0.8</span>); <span class="hljs-comment">// 0.19999999999999996</span><br>System.out.println(<span class="hljs-number">4.015</span> * <span class="hljs-number">100</span>); <span class="hljs-comment">// 401.49999999999994</span><br>System.out.println(<span class="hljs-number">123.3</span> / <span class="hljs-number">100</span>); <span class="hljs-comment">// 1.2329999999999999</span><br><span class="hljs-type">double</span> <span class="hljs-variable">amount1</span> <span class="hljs-operator">=</span> <span class="hljs-number">2.15</span>;<br><span class="hljs-type">double</span> <span class="hljs-variable">amount2</span> <span class="hljs-operator">=</span> <span class="hljs-number">1.10</span>;<br>System.out.println(amount1 - amount2); <span class="hljs-comment">// 1.0499999999999998</span><br></code></pre></td></tr></table></figure><p>出现上述结果的原因是，计算机以<strong>二进制</strong>存储数值，，浮点数也不例外。比如，0.1 的二进制表示为 0.0 0011 0011 0011… （0011 无限循环)，再转换为十进制就是 0.1000000000000000055511151231257827021181583404541015625。对于计算机而言，0.1 无法精确表达，这是浮点数计算造成精度损失的根源。</p><h3 id="使用-BigDecimal"><a href="#使用-BigDecimal" class="headerlink" title="使用 BigDecimal"></a>使用 BigDecimal</h3><p>BigDecimal 是不可变的，可以用来表示任意精度的带符号十进制数。double 的问题是从小数点转换到二进制丢失精度，二进制丢失精度。BigDecimal 在处理的时候把十进制小数扩大 N 倍让它在整数上进行计算，并保留相应的精度信息。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">BigDecimal</span> <span class="hljs-variable">bigDecimal</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">BigDecimal</span>(<span class="hljs-number">0.1</span>);<br>System.out.println(<span class="hljs-string">&quot;bigDecimal值为: &quot;</span> + bigDecimal);<br><span class="hljs-comment">//输出  0.1000000000000000055511151231257827021181583404541015625</span><br><br>System.out.println(String.format(<span class="hljs-string">&quot;%.1f&quot;</span>, bigDecimal)); <span class="hljs-comment">// 0.1</span><br></code></pre></td></tr></table></figure><p>参数类型为 double 的构造方法的结果有一定的<strong>不可预知性</strong>，需要通过格式化输出！</p><p><u><strong>推荐使用字符串为形参传入构造函数</strong></u></p><ul><li><p>String 类型参的构造方法是<strong>完全可预知的</strong>。比如 new BigDecimal(“0.1”) 将创建一个 BigDecimal 对象，它正好等于预期的 0.1。因此优先使用 String 构造方法。</p></li><li><p>当是形参为浮点数时，推荐先将<strong>浮点数转换为字符串类型</strong>然后放入构造函数中。例如:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">BigDecimal</span> <span class="hljs-variable">bigDecimal</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">BigDecimal</span>(Double.toString(<span class="hljs-number">2.1</span>));<br><span class="hljs-comment">/* 或者 */</span><br><span class="hljs-type">BigDecimal</span> <span class="hljs-variable">bigDecimal1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">BigDecimal</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Double</span>(<span class="hljs-number">2.1</span>).toString());<br></code></pre></td></tr></table></figure></li></ul><h3 id="BigDecimal-判等问题"><a href="#BigDecimal-判等问题" class="headerlink" title="BigDecimal 判等问题"></a>BigDecimal 判等问题</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">wrong</span><span class="hljs-params">()</span> &#123;<br>    System.out.println(<span class="hljs-keyword">new</span> <span class="hljs-title class_">BigDecimal</span>(<span class="hljs-string">&quot;1.0&quot;</span>).equals(<span class="hljs-keyword">new</span> <span class="hljs-title class_">BigDecimal</span>(<span class="hljs-string">&quot;1&quot;</span>))); <span class="hljs-comment">//false</span><br>&#125;<br><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">right</span><span class="hljs-params">()</span> &#123;<br>    System.out.println(<span class="hljs-keyword">new</span> <span class="hljs-title class_">BigDecimal</span>(<span class="hljs-string">&quot;1.0&quot;</span>).compareTo(<span class="hljs-keyword">new</span> <span class="hljs-title class_">BigDecimal</span>(<span class="hljs-string">&quot;1&quot;</span>)) == <span class="hljs-number">0</span>); <span class="hljs-comment">//true</span><br>&#125;<br></code></pre></td></tr></table></figure><p>BigDecimal 的 equals 方法的注释中说明了原因，equals 比较的是 BigDecimal 的 value 和 scale，1.0 的 scale 是 1，1 的 scale 是 0，所以结果一定是 false。</p><p><strong>如果只比较 BigDecimal 的 value，可以使用 compareTo 方法</strong>。</p>]]></content>
    
    
    <categories>
      
      <category>JavaSE</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java</tag>
      
      <tag>数据类型</tag>
      
      <tag>值类型</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>webserver 知识点</title>
    <link href="/webserver%E5%AD%A6%E4%B9%A0.html"/>
    <url>/webserver%E5%AD%A6%E4%B9%A0.html</url>
    
    <content type="html"><![CDATA[<p>在学习开源轻量级 web 服务器 <a href="https://github.com/qinguoyi/TinyWebServer/tree/master">TinyWebServer</a> 过程中，总结记录的相关知识点。</p><span id="more"></span><h2 id="五种-I-x2F-O-模型"><a href="#五种-I-x2F-O-模型" class="headerlink" title="五种 I&#x2F;O 模型"></a>五种 I&#x2F;O 模型</h2><ul><li><strong>阻塞 IO</strong>:调用者调用了某个函数，等待这个函数返回，期间什么也不做，不停的去检查这个函数有没有返回，必须等这个函数返回才能进行下一步动作</li><li><strong>非阻塞 IO</strong>:非阻塞等待，每隔一段时间就去检测 IO 事件是否就绪。没有就绪就可以做其他事。非阻塞 I&#x2F;O 执行系统调用总是立即返回，不管时间是否已经发生，若时间没有发生，则返回-1，此时可以根据 errno 区分这两种情况，对于 accept，recv 和 send，事件未发生时，errno 通常被设置成 eagain</li><li><strong>信号驱动 IO</strong>:linux 用套接口进行信号驱动 IO，安装一个信号处理函数，进程继续运行并不阻塞，当 IO 时间就绪，进程收到 SIGIO 信号。然后处理 IO 事件。</li><li><strong>IO 复用</strong>:linux 用 select&#x2F;poll 函数实现 IO 复用模型，这两个函数也会使进程阻塞，但是和阻塞 IO 所不同的是这两个函数可以同时阻塞多个 IO 操作。而且可以同时对多个读操作、写操作的 IO 函数进行检测。知道有数据可读或可写时，才真正调用 IO 操作函数</li><li><strong>异步 IO</strong>:linux 中，可以调用 aio_read 函数告诉内核描述字缓冲区指针和缓冲区的大小、文件偏移及通知的方式，然后立即返回，当内核将数据拷贝到缓冲区后，再通知应用程序。</li></ul><p>注意：阻塞 I&#x2F;O，非阻塞 I&#x2F;O，信号驱动 I&#x2F;O 和 I&#x2F;O 复用都是同步 I&#x2F;O。同步 I&#x2F;O 指内核向应用程序通知的是就绪事件，比如只通知有客户端连接，要求用户代码自行执行 I&#x2F;O 操作，异步 I&#x2F;O 是指内核向应用程序通知的是完成事件，比如读取客户端的数据后才通知应用程序，由内核完成 I&#x2F;O 操作。</p><h2 id="事件处理模式"><a href="#事件处理模式" class="headerlink" title="事件处理模式"></a>事件处理模式</h2><ul><li>reactor 模式中，主线程(<strong>I&#x2F;O 处理单元</strong>)只负责监听文件描述符上是否有事件发生，有的话立即通知工作线程(<strong>逻辑单元</strong> )，读写数据、接受新连接及处理客户请求均在工作线程中完成。通常由<strong>同步 I&#x2F;O</strong>实现。</li><li>proactor 模式中，主线程和内核负责处理读写数据、接受新连接等 I&#x2F;O 操作，工作线程仅负责业务逻辑，如处理客户请求。通常由<strong>异步 I&#x2F;O</strong>实现。</li></ul><h2 id="同步-I-x2F-O-模拟-proactor-模式"><a href="#同步-I-x2F-O-模拟-proactor-模式" class="headerlink" title="同步 I&#x2F;O 模拟 proactor 模式"></a>同步 I&#x2F;O 模拟 proactor 模式</h2><p>同步 I&#x2F;O 模型的工作流程如下（epoll_wait 为例）：</p><ul><li>主线程往 epoll 内核事件表注册 socket 上的读就绪事件。</li><li>主线程调用 epoll_wait 等待 socket 上有数据可读</li><li>当 socket 上有数据可读，epoll_wait 通知主线程,主线程从 socket 循环读取数据，直到没有更多数据可读，然后将读取到的数据封装成一个请求对象并插入请求队列。</li><li>睡眠在请求队列上某个工作线程被唤醒，它获得请求对象并处理客户请求，然后往 epoll 内核事件表中注册该 socket 上的写就绪事件</li><li>主线程调用 epoll_wait 等待 socket 可写。</li><li>当 socket 上有数据可写，epoll_wait 通知主线程。主线程往 socket 上写入服务器处理客户请求的结果。</li></ul><h2 id="并发编程模式"><a href="#并发编程模式" class="headerlink" title="并发编程模式"></a>并发编程模式</h2><p>并发编程方法的实现有多线程和多进程两种，但这里涉及的并发模式指 I&#x2F;O 处理单元与逻辑单元的协同完成任务的方法。</p><ul><li>半同步&#x2F;半异步模式</li><li>领导者&#x2F;追随者模式</li></ul><h2 id="半同步-x2F-半反应堆"><a href="#半同步-x2F-半反应堆" class="headerlink" title="半同步&#x2F;半反应堆"></a>半同步&#x2F;半反应堆</h2><p>半同步&#x2F;半反应堆并发模式是半同步&#x2F;半异步的变体，将半异步具体化为某种事件处理模式。</p><p><strong>并发模式中的同步和异步：</strong></p><ul><li>同步指的是程序完全按照代码序列的顺序执行</li><li>异步指的是程序的执行需要由系统事件驱动</li></ul><p><strong>半同步&#x2F;半异步模式工作流程</strong>:</p><ul><li>同步线程用于处理客户逻辑</li><li>异步线程用于处理 I&#x2F;O 事件</li><li>异步线程监听到客户请求后，就将其封装成请求对象并插入请求队列中</li><li>请求队列将通知某个工作在同步模式的工作线程来读取并处理该请求对象</li></ul><p><strong>半同步&#x2F;半反应堆工作流程（以 Proactor 模式为例）</strong></p><ul><li>主线程充当异步线程，负责监听所有 socket 上的事件</li><li>若有新请求到来，主线程接收之以得到新的连接 socket，然后往 epoll 内核事件表中注册该 socket 上的读写事件</li><li>如果连接 socket 上有读写事件发生，主线程从 socket 上接收数据，并将数据封装成请求对象插入到请求队列中</li><li>所有工作线程睡眠在请求队列上，当有任务到来时，通过竞争（如互斥锁）获得任务的接管权</li></ul><h2 id="线程池"><a href="#线程池" class="headerlink" title="线程池"></a>线程池</h2><ul><li>空间换时间,浪费服务器的硬件资源,换取运行效率.</li><li>池是一组资源的集合,这组资源在服务器启动之初就被完全创建好并初始化,这称为静态资源.</li><li>当服务器进入正式运行阶段,开始处理客户请求的时候,如果它需要相关的资源,可以直接从池中获取,无需动态分配.</li><li>当服务器处理完一个客户连接后,可以把相关的资源放回池中,无需执行系统调用释放资源.</li></ul><h2 id="select-x2F-poll-x2F-epoll"><a href="#select-x2F-poll-x2F-epoll" class="headerlink" title="select&#x2F;poll&#x2F;epoll"></a><strong>select&#x2F;poll&#x2F;epoll</strong></h2><ul><li><p>调用函数</p></li><li><ul><li>select 和 poll 都是一个函数，epoll 是一组函数</li></ul></li><li><p>文件描述符数量</p></li><li><ul><li>select 通过线性表描述文件描述符集合，文件描述符有上限，一般是 1024，但可以修改源码，重新编译内核，不推荐</li><li>poll 是链表描述，突破了文件描述符上限，最大可以打开文件的数目</li><li>epoll 通过红黑树描述，最大可以打开文件的数目，可以通过命令 ulimit -n number 修改，仅对当前终端有效</li></ul></li><li><p>将文件描述符从用户传给内核</p></li><li><ul><li>select 和 poll 通过将所有文件描述符拷贝到内核态，每次调用都需要拷贝</li><li>epoll 通过 epoll_create 建立一棵红黑树，通过 epoll_ctl 将要监听的文件描述符注册到红黑树上</li></ul></li><li><p>内核判断就绪的文件描述符</p></li><li><ul><li>select 和 poll 通过遍历文件描述符集合，判断哪个文件描述符上有事件发生</li><li>epoll_create 时，内核除了帮我们在 epoll 文件系统里建了个红黑树用于存储以后 epoll_ctl 传来的 fd 外，还会再建立一个 list 链表，用于存储准备就绪的事件，当 epoll_wait 调用时，仅仅观察这个 list 链表里有没有数据即可。</li><li>epoll 是根据每个 fd 上面的回调函数(中断函数)判断，只有发生了事件的 socket 才会主动的去调用 callback 函数，其他空闲状态 socket 则不会，若是就绪事件，插入 list</li></ul></li><li><p>应用程序索引就绪文件描述符</p></li><li><ul><li>select&#x2F;poll 只返回发生了事件的文件描述符的个数，若知道是哪个发生了事件，同样需要遍历</li><li>epoll 返回的发生了事件的个数和结构体数组，结构体包含 socket 的信息，因此直接处理返回的数组即可</li></ul></li><li><p>工作模式</p></li><li><ul><li>select 和 poll 都只能工作在相对低效的 LT 模式下</li><li>epoll 则可以工作在 ET 高效模式，并且 epoll 还支持 EPOLLONESHOT 事件，该事件能进一步减少可读、可写和异常事件被触发的次数。</li></ul></li><li><p>应用场景</p></li><li><ul><li>当所有的 fd 都是活跃连接，使用 epoll，需要建立文件系统，红黑书和链表对于此来说，效率反而不高，不如 selece 和 poll</li><li>当监测的 fd 数目较小，且各个 fd 都比较活跃，建议使用 select 或者 poll</li><li>当监测的 fd 数目非常大，成千上万，且单位时间只有其中的一部分 fd 处于就绪状态，这个时候使用 epoll 能够明显提升性能</li></ul></li></ul><h2 id="ET、LT、EPOLLONESHOT"><a href="#ET、LT、EPOLLONESHOT" class="headerlink" title="ET、LT、EPOLLONESHOT"></a>ET、LT、EPOLLONESHOT</h2><ul><li><p>LT 水平触发模式</p></li><li><ul><li>epoll_wait 检测到文件描述符有事件发生，则将其通知给应用程序，应用程序可以不立即处理该事件。</li><li>当下一次调用 epoll_wait 时，epoll_wait 还会再次向应用程序报告此事件，直至被处理</li></ul></li><li><p>ET 边缘触发模式</p></li><li><ul><li>epoll_wait 检测到文件描述符有事件发生，则将其通知给应用程序，应用程序必须立即处理该事件</li><li>必须要一次性将数据读取完，使用非阻塞 I&#x2F;O，读取到出现 eagain</li></ul></li><li><p>EPOLLONESHOT</p></li><li><ul><li>一个线程读取某个 socket 上的数据后开始处理数据，在处理过程中该 socket 上又有新数据可读，此时另一个线程被唤醒读取，此时出现两个线程处理同一个 socket</li><li>我们期望的是一个 socket 连接在任一时刻都只被一个线程处理，通过 epoll_ctl 对该文件描述符注册 epolloneshot 事件，一个线程处理 socket 时，其他线程将无法处理，<strong>当该线程处理完后，需要通过 epoll_ctl 重置 epolloneshot 事件</strong></li></ul></li></ul>]]></content>
    
    
    <categories>
      
      <category>知识储备</category>
      
    </categories>
    
    
    <tags>
      
      <tag>webserver</tag>
      
      <tag>linux</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>cpp 刷题笔记</title>
    <link href="/cpp%E5%88%B7%E9%A2%98%E7%AC%94%E8%AE%B0.html"/>
    <url>/cpp%E5%88%B7%E9%A2%98%E7%AC%94%E8%AE%B0.html</url>
    
    <content type="html"><![CDATA[<p>刷代码随想录过程中记得笔记。</p><span id="more"></span><h3 id="常用函数"><a href="#常用函数" class="headerlink" title="常用函数"></a>常用函数</h3><ul><li><p>在<code>sort</code>中使用 lambda 表示式：<code>sort(arr.begin(), arr.end(), [](int a, int b)-&gt;bool &#123;return a &gt; b; &#125;);</code>。</p></li><li><p><code>s = s1.substr(pos, len)</code>从 pos 位置开始，长度为 len 的子串。</p></li><li><p><code>str[i] = tolower(str[i]);</code>大写字母转小写，<code>str[i] = toupper(str[i]);</code>小写字母转大写。</p></li><li><p><code>bool binary_search(arr.begin(), arrr.end(), 3)</code>返回 <strong>bool</strong>。</p></li><li><p>getline 按逗号分割字符串：</p></li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs cpp">vector&lt;string&gt; strs;<br><span class="hljs-function">stringstream <span class="hljs-title">ss</span><span class="hljs-params">(line)</span></span>;<br>string str;<br><span class="hljs-keyword">while</span> (<span class="hljs-built_in">getline</span>(ss, str, <span class="hljs-string">&#x27;,&#x27;</span>)) &#123;<br>     strs.<span class="hljs-built_in">push_back</span>(str);<br>&#125;<br></code></pre></td></tr></table></figure><ul><li><p>把 “ab” 换成 “####”：<code>str=str.replace(str.find(&quot;a&quot;),2,&quot;####&quot;);</code></p></li><li><p>有序列表中二分查找 <code>lower_bound (begin, last, val, compare)</code> 找到<mark>大于等于 val</mark>的位置，<code>upper_bound (begin, last, val, compare)</code>找到<mark>大于 val</mark>的位置。</p></li><li><p><code>uique (begin,last)</code> 左闭右开区间。</p></li><li><p><code>string.erase(pos)</code> <code>string.erase(first, last)</code>通过迭代器删除元素。</p></li><li><p><strong>remove 和 rease 搭配删除所有指定值，remove 将元素移到末尾，没有改变 size</strong>：</p></li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs cpp">vector&lt;<span class="hljs-type">int</span>&gt; vec = &#123; <span class="hljs-number">1</span>,<span class="hljs-number">1</span>,<span class="hljs-number">1</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>,<span class="hljs-number">6</span>,<span class="hljs-number">7</span>,<span class="hljs-number">8</span>&#125;;<br>vec.<span class="hljs-built_in">erase</span>(<span class="hljs-built_in">remove</span>(vec.<span class="hljs-built_in">begin</span>(), vec.<span class="hljs-built_in">end</span>(), <span class="hljs-number">1</span>), vec.<span class="hljs-built_in">end</span>());<br><span class="hljs-comment">// vec = &#123;3,4,5,6,7,8&#125;</span><br></code></pre></td></tr></table></figure><ul><li><p><code>nth_element(begin, last, nth, comp)</code>默认升序排列，找到第 nth 大的元素，移到第 nth 的位置。</p></li><li><p>利用 bitset 进行任意进制转二进制：</p></li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// stol() 第二个参数默认为 NULL，第三个默认 10 进制，可 8/16 进制</span><br><span class="hljs-function">bitset&lt;16&gt; <span class="hljs-title">bin</span><span class="hljs-params">(stol(t, <span class="hljs-literal">nullptr</span>, <span class="hljs-number">16</span>))</span></span>;   先转为 <span class="hljs-type">long</span>，通过 bitset 转为二进制 <span class="hljs-number">16</span> 位<br>string s = bin.<span class="hljs-built_in">to_string</span>();<br></code></pre></td></tr></table></figure><h3 id="ACM-模式输入输出"><a href="#ACM-模式输入输出" class="headerlink" title="ACM 模式输入输出"></a>ACM 模式输入输出</h3><ul><li><p>用 while 循环读取字符串时，输入<code>Ctrl+X</code>标志终止输入。</p></li><li><p><code>#include &lt;bits/stdc++.h&gt;</code>，万能头文件。</p></li><li><p><code>using namespace std;</code>，定义域名空间。</p></li><li><p><code>while (getchar() != &#39;\n&#39;) &#123; 判断换行符号&#125;</code>，<strong>读取一行内任意个数元素</strong>。</p></li><li><p><code>getchar()</code>，从缓冲区取一个字符，缓冲区少一个字符。</p></li></ul><h3 id="List"><a href="#List" class="headerlink" title="List"></a>List</h3><ul><li><p>list 的成员函数 remove, erase, pop_front, pop_back, clear 自动释放元素内存空间，同时元素迭代器失效。</p></li><li><p>删除某个元素，仅仅会删除元素的迭代器失效。插入、删除元素不会对其他元素造成影响。</p></li></ul><h3 id="二分法"><a href="#二分法" class="headerlink" title="二分法"></a>二分法</h3><p>注意<code>while (left &lt;= right)</code>取<strong>等号</strong>，查找值是否存在。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">search</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums, <span class="hljs-type">int</span> target)</span> </span>&#123;<br>    <span class="hljs-type">int</span> left = <span class="hljs-number">0</span>;<br>    <span class="hljs-type">int</span> right = nums.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>; <span class="hljs-comment">// 定义 target 在左闭右闭的间里，[left, right]</span><br>    <span class="hljs-keyword">while</span> (left &lt;= right) &#123; <span class="hljs-comment">// 当 left==right，区间 [left, right] 依然有效，所以用 &lt;=</span><br>        <span class="hljs-type">int</span> mid = left + ((right - left) / <span class="hljs-number">2</span>); <span class="hljs-comment">// 防止溢出 等同于 (left + right)/2</span><br>        <span class="hljs-keyword">if</span> (nums[mid] &gt; target) right = middle - <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (nums[mid] &lt; target) left = middle + <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">return</span> mid;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h3><p>注意<code>while (left &lt; right)</code>，交换左右元素，至少有<strong>两个</strong>元素，才能交换，因此不能取等号。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">partition</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums, <span class="hljs-type">int</span> left, <span class="hljs-type">int</span> right)</span> </span>&#123;<br>        <span class="hljs-type">int</span> pivot = nums[left];<br>        <span class="hljs-keyword">while</span> (left &lt; right) &#123;<br>            <span class="hljs-keyword">while</span> (left &lt; right &amp;&amp; pivot &lt;= nums[right])    right--;<br>            nums[left] = nums[right];<br>            <span class="hljs-keyword">while</span> (left &lt; right &amp;&amp; pivot &gt;= nums[left])     left++;<br>            nums[right] = nums[left];<br>        &#125;<br>        nums[left] = pivot;<br>        <span class="hljs-keyword">return</span> left;<br>    &#125;<br><span class="hljs-comment">// 递归</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">quicksort</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums, <span class="hljs-type">int</span> left, <span class="hljs-type">int</span> right)</span> </span>&#123;<br>    <span class="hljs-type">int</span> pivot;<br>    <span class="hljs-keyword">if</span> (left &lt; right) &#123;<br>        pivot = <span class="hljs-built_in">partition</span>(nums, left, right);<br>        <span class="hljs-built_in">quicksort</span>(nums, left, pivot - <span class="hljs-number">1</span>);<br>        <span class="hljs-built_in">quicksort</span>(nums, pivot + <span class="hljs-number">1</span>, right);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>有重复元素时多加 ‘&#x3D;‘ ，<strong>多加不会出错</strong>。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">while</span> (left &lt; right &amp;&amp; pivot &lt;= nums[right])    right--;<br><span class="hljs-keyword">while</span> (left &lt; right &amp;&amp; pivot &gt;= nums[left])     left++;<br></code></pre></td></tr></table></figure><h3 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h3><ul><li><p><code>for (int i = 0; i &lt;= arr.size() - k; i += k)</code>，每次遍历 k 个元素，注意 <code>i&lt;=arr.size()-k</code>。</p></li><li><p><code>priority_queue&lt;int,vector&lt;int&gt;，less&lt;int&gt;&gt;</code>，第二个参数是存储容器，第三个是比较函数，默认<code>less&lt;int&gt;</code>大顶堆，自顶向下变小，<code>greater&lt;int&gt;</code>小顶堆，自顶向下变大。</p></li><li><p>求数组中三数之和（固定第一个，再用双指针），四数之和，<strong>先排序</strong>，方便后面剪枝。</p></li></ul><h3 id="链表"><a href="#链表" class="headerlink" title="链表"></a>链表</h3><ul><li>自定义链表结构：</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">ListNode</span> &#123;<br>    <span class="hljs-type">int</span> val;<br>    ListNode* next;<br>    <span class="hljs-built_in">ListNode</span>(<span class="hljs-type">int</span> val):<span class="hljs-built_in">val</span>(val), <span class="hljs-built_in">next</span>(<span class="hljs-literal">nullptr</span>)&#123;&#125;<br>&#125;;<br>ListNode* node = <span class="hljs-keyword">new</span> <span class="hljs-built_in">ListNode</span>(val);<br><br><span class="hljs-comment">//使用虚拟头节点</span><br>ListNode* dummyHead = <span class="hljs-keyword">new</span> <span class="hljs-built_in">ListNode</span>(<span class="hljs-number">0</span>);<br>dummyHead-&gt;next = head;<br>ListNode* cur = dummyHead;<br></code></pre></td></tr></table></figure><ul><li>定义指针数组（哈希）：</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs cpp">vector&lt;ListNode*&gt; vec;<br>ListNode* cur=head;<br><span class="hljs-keyword">while</span>(cur)&#123;<br>    vec.<span class="hljs-built_in">push_back</span>(cur);<br>    cur=cur-&gt;next;<br>&#125;<br></code></pre></td></tr></table></figure><p>应用：对链表每 K 个结点翻转，定义一个指针数组，对数组翻转，变相对链表操作。</p><h3 id="String"><a href="#String" class="headerlink" title="String"></a>String</h3><ul><li>双指针法判断<strong>回文</strong>：</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">countSubstrings</span><span class="hljs-params">(string s)</span> </span>&#123;<br>    <span class="hljs-type">int</span> result = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; s.<span class="hljs-built_in">size</span>(); i++) &#123;<br>        result += <span class="hljs-built_in">extend</span>(s, i, i); <span class="hljs-comment">// 以 i 为中心</span><br>        result += <span class="hljs-built_in">extend</span>(s, i, i + <span class="hljs-number">1</span>); <span class="hljs-comment">// 以 i 和 i+1 为中心</span><br>    &#125;<br>    <span class="hljs-keyword">return</span> result;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">extend</span><span class="hljs-params">(<span class="hljs-type">const</span> string&amp; s, <span class="hljs-type">int</span> i, <span class="hljs-type">int</span> j)</span> </span>&#123;<br>    <span class="hljs-type">int</span> res = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">while</span> (i &gt;= <span class="hljs-number">0</span> &amp;&amp; j &lt; s.<span class="hljs-built_in">size</span>() &amp;&amp; s[i] == s[j]) &#123;<br>        i--;<br>        j++;<br>        res++;<br>    &#125;<br>    <span class="hljs-keyword">return</span> res;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li><p><code>if(str.find(&quot;a&quot;) != -1)</code>返回结果是 <strong>-1</strong> 不是 end()。</p></li><li><p><code>s.substr(start,len)</code>，从 start 位置取长度为 len 的子串。</p></li><li><p>查找字符串 S 是否包含子串 sub，S+S 拼接破环头尾，判断<code>S.find(sub)</code>存在。</p></li><li><p><strong>stoll</strong>：string 型变量转换为 long long 型变量（常用），兼容 int long；<br><strong>stod</strong>：string 型变量转换为 double 型变量（常用），兼容 float。</p></li></ul><h3 id="优先队列（堆）"><a href="#优先队列（堆）" class="headerlink" title="优先队列（堆）"></a>优先队列（堆）</h3><ul><li><code>priority_queue&lt;int, vector&lt;int&gt;, cmp&gt; p_queue</code>默认底层容器 vector，默认大顶堆 less。</li><li>自定义比较函数 class：</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">cmp</span>&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">operator</span><span class="hljs-params">()</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp;a,vector&lt;<span class="hljs-type">int</span>&gt;&amp;b)</span></span>&#123;<br>        <span class="hljs-keyword">return</span> a[<span class="hljs-number">0</span>]&gt;b[<span class="hljs-number">0</span>];   小顶堆<br>    &#125;<br>&#125;;<br>priority_queue&lt;vector&lt;<span class="hljs-type">int</span>&gt;,vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt;,cmp&gt; q;<br></code></pre></td></tr></table></figure><ul><li>自定义比较结构体 struct:</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">cmp</span> &#123;<br>     <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">operator</span><span class="hljs-params">()</span><span class="hljs-params">(pair&lt;<span class="hljs-type">int</span>,<span class="hljs-type">int</span>&gt;&amp; a,pair&lt;<span class="hljs-type">int</span>,<span class="hljs-type">int</span>&gt;&amp; b)</span></span>&#123;<br>         <span class="hljs-keyword">return</span> a.second &gt; b.second;<br>    &#125;<br>&#125;;<br>priority_queue&lt;pair&lt;<span class="hljs-type">int</span>,<span class="hljs-type">int</span>&gt;, vector&lt;pair&lt;<span class="hljs-type">int</span>,<span class="hljs-type">int</span>&gt;&gt;, cmp&gt; q;<br></code></pre></td></tr></table></figure><ul><li>两种自定义比较函数，小顶堆，注意符号（默认大顶堆），第二个参数设置底层容器，必填，否则第三个参数不起作用。</li></ul><h3 id="二叉树"><a href="#二叉树" class="headerlink" title="二叉树"></a>二叉树</h3><ul><li>数据结构模板：</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">TreeNode</span> &#123;<br>    <span class="hljs-type">int</span> val;<br>    TreeNode *left;<br>    TreeNode *right;<br>    <span class="hljs-built_in">TreeNode</span>(<span class="hljs-type">int</span> x) : <span class="hljs-built_in">val</span>(x), <span class="hljs-built_in">left</span>(<span class="hljs-literal">nullptr</span>), <span class="hljs-built_in">right</span>(<span class="hljs-literal">nullptr</span>) &#123;&#125;<br>&#125;;<br></code></pre></td></tr></table></figure><ul><li>二叉树递归参数传值 val，切忌不要用引用 &amp;val，不能改变 val 值，<strong>方便回溯</strong>。</li><li>递归遍历函数是否需要返回值？<ul><li>若只要找到一条路径，不用全部遍历，则要返回值 bool。</li><li>若找到所有满足条件路径，要求全部遍历，则不需要返回值。</li></ul></li><li>递归返回<code>TreeNode*</code>，可以<code>return nullptr</code>。</li><li><strong>删除</strong>二叉树节点，<strong>增加</strong>二叉树节点，都是用<strong>递归函数的返回值</strong>来完成。</li><li>根据有序数组创建<strong>二叉搜索树</strong>，同时也是平衡树：</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function">TreeNode* <span class="hljs-title">createTree</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; vec,<span class="hljs-type">int</span> left,<span class="hljs-type">int</span> right)</span></span>&#123;<br>    <span class="hljs-keyword">if</span>(left &gt; right) <span class="hljs-keyword">return</span> <span class="hljs-literal">nullptr</span>;<br>    <span class="hljs-type">int</span> mid = (left+right)/<span class="hljs-number">2</span>;<br>    TreeNode* node = <span class="hljs-keyword">new</span> <span class="hljs-built_in">TreeNode</span>(vec[mid]);<br>    node-&gt;left = <span class="hljs-built_in">createTree</span>(vec,left,mid<span class="hljs-number">-1</span>);<br>    node-&gt;right = <span class="hljs-built_in">createTree</span>(vec,mid+<span class="hljs-number">1</span>,right);<br>    <span class="hljs-keyword">return</span> node;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>求公共最近公共邻居 leetcode.236：</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">TreeNode* <span class="hljs-title">lowestCommonAncestor</span><span class="hljs-params">(TreeNode* root, TreeNode* p, TreeNode* q)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (root == q || root == p || root == <span class="hljs-literal">NULL</span>) <span class="hljs-keyword">return</span> root;<br>        TreeNode* left = <span class="hljs-built_in">lowestCommonAncestor</span>(root-&gt;left, p, q);<br>        TreeNode* right = <span class="hljs-built_in">lowestCommonAncestor</span>(root-&gt;right, p, q);<br>        <span class="hljs-keyword">if</span> (left != <span class="hljs-literal">NULL</span> &amp;&amp; right != <span class="hljs-literal">NULL</span>) <span class="hljs-keyword">return</span> root;<br><br>        <span class="hljs-keyword">if</span> (left == <span class="hljs-literal">NULL</span> &amp;&amp; right != <span class="hljs-literal">NULL</span>) <span class="hljs-keyword">return</span> right;<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (left != <span class="hljs-literal">NULL</span> &amp;&amp; right == <span class="hljs-literal">NULL</span>) <span class="hljs-keyword">return</span> left;<br>        <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;<br>        &#125;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><ul><li><p>考虑设置 全局变量<code>public: TreeNode* pre</code>递归过程更新全局指针变量。</p></li><li><p><strong>递归一定看函数返回什么，指针？整数？，利用起来<code>root-&gt;left = deleteNode(root-&gt;left,key);</code>。</strong></p></li></ul><h3 id="回溯法"><a href="#回溯法" class="headerlink" title="回溯法"></a>回溯法</h3><ul><li><p><strong>关键词：返回所有可能方案。</strong></p></li><li><p><strong>回溯是递归的副产品，只要有递归就会有回溯。</strong></p></li><li><p>回溯法就是暴力搜索，并不是什么高效的算法，最多在剪枝一下（解决多层 for 循环）。</p></li><li><p>通用模板：</p></li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-type">void</span> backtracking（参数） &#123;<br>    <span class="hljs-keyword">if</span> （终止条件） &#123;<br>        存放结果；<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br>    <span class="hljs-keyword">for</span> （选择：本层集合中元素（树中节点孩子的数量就是集合的大小）) &#123;<br>        处理节点；<br>        backtracking（路径，选择列表）; <span class="hljs-comment">// 递归</span><br>        回溯，撤销处理结果！!!<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>在终止条件前加入剪枝，即进入递归后提前<code>return</code>：</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">private</span>:<br>    vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; result; <span class="hljs-comment">// 存放符合条件结果的集合</span><br>    vector&lt;<span class="hljs-type">int</span>&gt; path; <span class="hljs-comment">// 用来存放符合条件结果</span><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">backtracking</span><span class="hljs-params">(<span class="hljs-type">int</span> n, <span class="hljs-type">int</span> k, <span class="hljs-type">int</span> startIndex)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (path.<span class="hljs-built_in">size</span>() == k) &#123;<br>            result.<span class="hljs-built_in">push_back</span>(path);<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = startIndex; i &lt;= n; i++) &#123;<br>            path.<span class="hljs-built_in">push_back</span>(i); <span class="hljs-comment">// 处理节点</span><br>            <span class="hljs-built_in">backtracking</span>(n, k, i + <span class="hljs-number">1</span>);   <span class="hljs-comment">//注意 传 i+1, 不是 startIndex</span><br>            path.<span class="hljs-built_in">pop_back</span>(); <span class="hljs-comment">// 回溯，撤销处理的节点</span><br>        &#125;<br>    &#125;<br><span class="hljs-keyword">public</span>:<br>    vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">combine</span>(<span class="hljs-type">int</span> n, <span class="hljs-type">int</span> k) &#123;<br>        result.<span class="hljs-built_in">clear</span>();<br>        path.<span class="hljs-built_in">clear</span>();<br>        <span class="hljs-built_in">backtracking</span>(n, k, <span class="hljs-number">1</span>);<br>        <span class="hljs-keyword">return</span> result;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><ul><li><p>经典组合题，注意<code>backtracking(n, k, i + 1)</code>; 传 <strong>i+1</strong>, 回溯部分<code>path.pop_back()</code>以及相应处理。</p></li><li><p>善用<code>used[]</code>，标记已访问的元素。</p></li><li><p>全组合用<code>startIndex</code>（无顺序且组合不能重复）;</p><p>全排列<strong>不需要</strong><code>startIndex</code>，而是用<code>used[ ]</code>（有顺序且同一元素不能重复选取）。</p></li><li><p><strong>对于结果有重复子集，需去重，则先排序，通过判断相邻结点是否重复使用过。</strong></p></li><li><p><code>if (i &gt; 0 &amp;&amp; nums[i] == nums[i - 1] &amp;&amp; used[i - 1] == false) continue;</code>, 先排序，对于{1, 1, 2}, <code>used[0]=false</code>表示同一数层上 n[0] 已被用过，而 n[0]&#x3D;&#x3D;n[1]，所以跳过；对于<code>used[0]=true</code>，表示 n[0] 在<strong>上一层</strong>，同一条树枝上，不在同一层，可重复使用。</p></li><li><p>经典排列题，含去重：</p></li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">private</span>:<br>    vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; result;<br>    vector&lt;<span class="hljs-type">int</span>&gt; path;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">backtracking</span> <span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums, vector&lt;<span class="hljs-type">bool</span>&gt;&amp; used)</span> </span>&#123;<br>        <span class="hljs-comment">// 此时说明找到了一组</span><br>        <span class="hljs-keyword">if</span> (path.<span class="hljs-built_in">size</span>() == nums.<span class="hljs-built_in">size</span>()) &#123;<br>            result.<span class="hljs-built_in">push_back</span>(path);<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; nums.<span class="hljs-built_in">size</span>(); i++) &#123;<br>            <span class="hljs-comment">// used[i - 1] == true，说明同一树枝 nums[i - 1] 使用过</span><br>            <span class="hljs-comment">// used[i - 1] == false，说明同一树层 nums[i - 1] 使用过</span><br>            <span class="hljs-comment">// 如果同一树层 nums[i - 1] 使用过则直接跳过</span><br>            <span class="hljs-keyword">if</span> (i &gt; <span class="hljs-number">0</span> &amp;&amp; nums[i] == nums[i - <span class="hljs-number">1</span>] &amp;&amp; used[i - <span class="hljs-number">1</span>] == <span class="hljs-literal">false</span>) &#123;<br>                <span class="hljs-keyword">continue</span>;<br>            &#125;<br>            <span class="hljs-comment">//if ( used[i] == true ) continue;</span><br>            <span class="hljs-keyword">if</span> (used[i] == <span class="hljs-literal">false</span>) &#123;<br>                used[i] = <span class="hljs-literal">true</span>;<br>                path.<span class="hljs-built_in">push_back</span>(nums[i]);<br>                <span class="hljs-built_in">backtracking</span>(nums, used);<br>                path.<span class="hljs-built_in">pop_back</span>();<br>                used[i] = <span class="hljs-literal">false</span>;<br>            &#125;<br>        &#125;<br>    &#125;<br><span class="hljs-keyword">public</span>:<br>    vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">permuteUnique</span>(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums) &#123;<br>        result.<span class="hljs-built_in">clear</span>();<br>        path.<span class="hljs-built_in">clear</span>();<br>        <span class="hljs-built_in">sort</span>(nums.<span class="hljs-built_in">begin</span>(), nums.<span class="hljs-built_in">end</span>()); <span class="hljs-comment">// 排序</span><br>        <span class="hljs-function">vector&lt;<span class="hljs-type">bool</span>&gt; <span class="hljs-title">used</span><span class="hljs-params">(nums.size(), <span class="hljs-literal">false</span>)</span></span>;<br>        <span class="hljs-built_in">backtracking</span>(nums, used);<br>        <span class="hljs-keyword">return</span> result;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><ul><li><p><code>if (used[i] == false) &#123; ... &#125;</code>，记住前提条件，<strong>上一层已选过，就不考虑啦</strong>，或者改为<code>if (used[i] == true) continue;</code>。</p></li><li><p>递归和回溯：<br>1）要遍历所有元素找全部结果，函数 void 无返回值。<br>2）只要找到一条路径&#x2F;结果，函数有返回值 bool（同二叉树）。</p></li></ul><h3 id="贪心算法"><a href="#贪心算法" class="headerlink" title="贪心算法"></a>贪心算法</h3><ul><li><p>贪心的本质是选择每一阶段的局部最优，从而达到全局最优。</p></li><li><p><strong>提前排序给定数组！降低难度！</strong></p></li><li><p>加关键词 static 才能在 sort 使用 cmp 函数，sort 要求 cmp 函数为 static，或者声明类外作为全局函数。</p></li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">static</span> <span class="hljs-type">bool</span> <span class="hljs-title">cmp</span><span class="hljs-params">(<span class="hljs-type">int</span> a,<span class="hljs-type">int</span> b)</span></span>&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">abs</span>(a) &gt; <span class="hljs-built_in">abs</span>(b);<br>&#125;<br><span class="hljs-built_in">sort</span>(nums.<span class="hljs-built_in">begin</span>(),nums.<span class="hljs-built_in">end</span>(),cmp);<br></code></pre></td></tr></table></figure><ul><li><strong>左右排序两次问题，区间问题，或数组中当前元素与左右元素比较时</strong>，先顺序遍历，在逆序遍历，两次遍历不能同时兼顾左右（lc.135），换句话说，遇到两个维度权衡的时候，一定要先确定一个维度，再确定另一个维度。</li></ul><h3 id="动态规划"><a href="#动态规划" class="headerlink" title="动态规划"></a>动态规划</h3><blockquote><ol><li><p>确定 dp 数组以及下标的含义</p></li><li><p>确定递推公式</p></li><li><p>dp 数组如何初始化</p></li><li><p>确定遍历顺序</p></li><li><p>举例推导 dp 数组</p></li></ol></blockquote><p><strong>debug 最好方式就是把 dp 数组打印出来，看看究竟是不是按照自己思路推导的！</strong></p><p>dp 初始化后，遍历数组考虑初始值，避免越界。</p><h3 id="经典01背包问题"><a href="#经典01背包问题" class="headerlink" title="经典01背包问题"></a>经典01背包问题</h3><ul><li><p>每个物品只能放入一次。</p></li><li><p>外层遍历物品，<strong>内层遍历容量</strong>。</p></li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// 二维数组</span><br>vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">dp</span>(weight.<span class="hljs-built_in">size</span>(), <span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">int</span>&gt;(bagweight + <span class="hljs-number">1</span>, <span class="hljs-number">0</span>));<br><span class="hljs-comment">// 初始化</span><br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = weight[<span class="hljs-number">0</span>]; j &lt;= bagweight; j++) &#123;<br>    dp[<span class="hljs-number">0</span>][j] = value[<span class="hljs-number">0</span>];<br>&#125;<br><span class="hljs-comment">// weight 数组的大小 就是物品个数</span><br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt; weight.<span class="hljs-built_in">size</span>(); i++) &#123; <span class="hljs-comment">// 遍历物品</span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt;= bagweight; j++) &#123; <span class="hljs-comment">// 遍历背包容量</span><br>        放不下 i 重量<br>        <span class="hljs-keyword">if</span> (j &lt; weight[i]) dp[i][j] = dp[i - <span class="hljs-number">1</span>][j];<br>        <span class="hljs-keyword">else</span> dp[i][j] = <span class="hljs-built_in">max</span>(dp[i - <span class="hljs-number">1</span>][j], dp[i - <span class="hljs-number">1</span>][j - weight[i]] + value[i]);<br>    &#125;<br>&#125;<br>cout &lt;&lt; dp[weight.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>][bagweight] &lt;&lt; endl;<br></code></pre></td></tr></table></figure><ul><li><strong>滚动数组</strong>：降低空间复杂度。先正序遍历物品，在倒序遍历背包容量，dp[j] 表示：容量维 j 的背包，所背的物品价值最大为 dp[j]，<strong>倒序遍历是为了保证物品 i 只被放入一次！</strong></li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// 初始化</span><br><span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">dp</span><span class="hljs-params">(bagWeight + <span class="hljs-number">1</span>, <span class="hljs-number">0</span>)</span></span>;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; weight.<span class="hljs-built_in">size</span>(); i++) &#123; <span class="hljs-comment">// 遍历物品</span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = bagWeight; j &gt;= weight[i]; j--) &#123; <span class="hljs-comment">// 遍历背包容量</span><br>        dp[j] = <span class="hljs-built_in">max</span>(dp[j], dp[j - weight[i]] + value[i]);<br>    &#125;<br>&#125;<br>cout &lt;&lt; dp[bagWeight] &lt;&lt; endl;<br></code></pre></td></tr></table></figure><ul><li><p><code>dp[i]</code>表示不放物体，相当于<code>dp[i-1][j]</code>，不放物体 i，<code>dp[j - weight[i]] + value[i]</code>表示放物体 i，为放物体前容量的最大价值 + 物体 i 的价值。</p></li><li><p>为什么第二次循环<code>j&gt;=weight[i]</code>，因为<code>dp[j - weight[i]]</code>表示放物体前的容量，不能为负数，考虑能放下的情况，放还是不放；对于不能放下就默认等于上一次值，不考虑。</p></li><li><p>注意第二重<strong>循环 j 初始值</strong>，为 dp 容量最大值。</p></li></ul><h3 id="完全背包问题"><a href="#完全背包问题" class="headerlink" title="完全背包问题"></a>完全背包问题</h3><ul><li>每件物品无限件，可重复放入背包。</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// 先遍历物品，再遍历背包</span><br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; weight.<span class="hljs-built_in">size</span>(); i++) &#123; <span class="hljs-comment">// 遍历物品</span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = weight[i]; j &lt;= bagWeight ; j++) &#123; <span class="hljs-comment">// 遍历背包容量</span><br>        dp[j] = <span class="hljs-built_in">max</span>(dp[j], dp[j - weight[i]] + value[i]);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li><p><strong>内循环 从小到大遍历，因为每件物品添加多次</strong>。</p></li><li><p><strong>理解 内循环 dp[j]：每次容量为 j 的时候，所以后面内容都是考虑当前容量为 j</strong>。</p></li><li><p><strong>如果求<mark>组合数</mark>就是外层 for 循环遍历物品，内层 for 遍历背包</strong>。</p><p><strong>如果求<mark>排列数</mark>就是外层 for 遍历背包，内层 for 循环遍历物品</strong>。</p></li><li><p>滚动数组为了取代二维数组，但<strong>内循环一般是倒序</strong>的，防止重复选取。</p></li></ul><h3 id="求连续公共子序列"><a href="#求连续公共子序列" class="headerlink" title="求连续公共子序列"></a>求连续公共子序列</h3><ul><li><p><code>dp[i][j]</code>：以下标 <strong>i-1</strong> 为结尾的 A，和以下标 <strong>j-1</strong> 为结尾的 B，最长重复子数组<strong>长度</strong>为<code>dp[i][j]</code>。</p></li><li><p>求<strong>连续</strong>最长重复子数组：</p></li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">findLength</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums1, vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums2)</span> </span>&#123;<br>        vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">dp</span>(nums1.<span class="hljs-built_in">size</span>()+<span class="hljs-number">1</span>,<span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">int</span>&gt;(nums2.<span class="hljs-built_in">size</span>()+<span class="hljs-number">1</span>,<span class="hljs-number">0</span>));<br>        <span class="hljs-type">int</span> res = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i &lt;=nums1.<span class="hljs-built_in">size</span>();i++)&#123;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">1</span>;j&lt;=nums2.<span class="hljs-built_in">size</span>();j++)&#123;<br>                <span class="hljs-keyword">if</span>(nums1[i<span class="hljs-number">-1</span>] == nums2[j<span class="hljs-number">-1</span>])&#123;<br>                    dp[i][j] = dp[i<span class="hljs-number">-1</span>][j<span class="hljs-number">-1</span>]+<span class="hljs-number">1</span>;<br>                &#125;<br>                <span class="hljs-keyword">if</span>(dp[i][j] &gt; res) res = dp[i][j];<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><ul><li>求<strong>不连续</strong>公共子数组：</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">longestCommonSubsequence</span><span class="hljs-params">(string text1, string text2)</span> </span>&#123;<br>        vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">dp</span>(text1.<span class="hljs-built_in">size</span>()+<span class="hljs-number">1</span>,<span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">int</span>&gt;(text2.<span class="hljs-built_in">size</span>()+<span class="hljs-number">1</span>,<span class="hljs-number">0</span>));<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=text1.<span class="hljs-built_in">size</span>();i++)&#123;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">1</span>;j&lt;=text2.<span class="hljs-built_in">size</span>();j++)&#123;<br>                <span class="hljs-keyword">if</span>(text1[i<span class="hljs-number">-1</span>] == text2[j<span class="hljs-number">-1</span>])&#123;<br>                    dp[i][j] = dp[i<span class="hljs-number">-1</span>][j<span class="hljs-number">-1</span>] + <span class="hljs-number">1</span>;<br>                &#125;<span class="hljs-keyword">else</span>&#123;<br>                    dp[i][j] = <span class="hljs-built_in">max</span>(dp[i<span class="hljs-number">-1</span>][j],dp[i][j<span class="hljs-number">-1</span>]);<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> dp[text1.<span class="hljs-built_in">size</span>()][text2.<span class="hljs-built_in">size</span>()];<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><ul><li>思考<code>d[i][j]</code>是一个数，表示什么意思？公共长度？最多重复数量？最少删除次数？视情况而定。</li></ul><h3 id="单调栈"><a href="#单调栈" class="headerlink" title="单调栈"></a>单调栈</h3><ul><li><p><strong>要寻找任一个元素的右边或者左边第一个比自己大或者小的元素的位置。</strong></p></li><li><p>栈里只存递增或递减的 index，遇到逆序就弹出栈内元素，从而得到第一个大于或小于元素的 index。</p></li><li><p>设置两个数组，顺序和逆序遍历，得到左边&#x2F;右边最大数字：</p></li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// 记录每个柱子左边柱子最大高度</span><br>maxLeft[<span class="hljs-number">0</span>] = height[<span class="hljs-number">0</span>];<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt; size; i++) &#123;<br>    maxLeft[i] = <span class="hljs-built_in">max</span>(height[i], maxLeft[i - <span class="hljs-number">1</span>]);<br>&#125;<br><span class="hljs-comment">// 记录每个柱子右边柱子最大高度</span><br>maxRight[size - <span class="hljs-number">1</span>] = height[size - <span class="hljs-number">1</span>];<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = size - <span class="hljs-number">2</span>; i &gt;= <span class="hljs-number">0</span>; i--) &#123;<br>    maxRight[i] = <span class="hljs-built_in">max</span>(height[i], maxRight[i + <span class="hljs-number">1</span>]);<br>&#125;<br></code></pre></td></tr></table></figure><p>待续……</p>]]></content>
    
    
    <categories>
      
      <category>刷题笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>cpp</tag>
      
      <tag>note</tag>
      
      <tag>algorithm</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>论文笔记之 pSCAN</title>
    <link href="/pSCAN.html"/>
    <url>/pSCAN.html</url>
    
    <content type="html"><![CDATA[<p>pSCAN 研究了结构图聚类问题，这是图数据管理和分析的基本问题。给定一个无向无权图，结构图聚类就是将顶点分配给簇，并识别中心顶点和离群顶点的集合，使得同一簇中的顶点彼此紧密连接，而不同簇中的顶点松散连接。</p><span id="more"></span><blockquote><p>pSCAN: Fast and Exact Structural Graph Clustering.Lijun Chang, Wei Li, Lu Qin, Wenjie Zhang, and Shiyu Yang.</p></blockquote><h2 id="1-Contributions："><a href="#1-Contributions：" class="headerlink" title="1.Contributions："></a>1.Contributions：</h2><ul><li>作者证明了现有的 SCAN 算法在最坏情况下最优的。</li><li>作者对结构图聚类做了三个观察，提出了可扩展结的两步范式，减少结构相似性计算。</li><li>此外，作者提供了优化技术加速检查两个顶点是否结构相似。</li></ul><h2 id="2-Three-observations"><a href="#2-Three-observations" class="headerlink" title="2.Three observations:"></a>2.Three observations:</h2><ol><li>结构图聚类中的聚类可能存在重叠。</li><li>核顶点的集群不相交。</li><li>非核心顶点的簇由核心顶点唯一确定。</li></ol><h2 id="3-Definition"><a href="#3-Definition" class="headerlink" title="3.Definition:"></a>3.Definition:</h2><ul><li>顶点 u 的结构领域 N[u] 为 u 的闭领域，即：N[u] &#x3D; {v ∈ V|(u,v) ∈ E} ∪ {u}。</li><li>顶点 u 和 v 之间的结构相似性定义为：N[u]和 N[v]中共有顶点的数量按其基数的几个平均值归一化。</li><li>给定相似度阈值 0 &lt; $\epsilon$ &lt;&#x3D; 1 和一个整数 $\mu$ ≥ 2，一个顶点是核心顶点如果 $N_{eps}$[u] ≥ $\mu$。</li><li>集群 C 是 V 的一个子集，它至少有两个顶点，则：<ul><li>（最大化）如果核心顶点 u∈C，那么所欲有从 u 到结构可达的顶点 v 也属于 C。</li><li>（连通性）对于任意两个顶点 $v_1$,$v_2$ ∈ C，有顶点 u ∈ C，使得 $v_1$ 和 $v_2$ 都可以从 u 可达。</li></ul></li><li>给定聚类 C，C 中不属于任何集群的顶点 u，如果它的邻居属于两个或者两个以上的集群，则为 hub，否则为 outlier。</li></ul><h2 id="4-Two-step-Paradigm"><a href="#4-Two-step-Paradigm" class="headerlink" title="4.Two-step Paradigm:"></a>4.Two-step Paradigm:</h2><ul><li>step-1：<u>聚类核心顶点</u>，把所有核心顶点分类到对应簇。</li><li>step-2：<u>聚类非核心顶点</u>，是 non-core 且和邻点 core 相似，分到 core 的簇中。</li></ul><img src="https://cdn.jsdelivr.net/gh/gejoyy/Pictures@main/image-20230627152627744.png" alt="pscan-algorithm-2" style="zoom: 67%;" /><h2 id="5-Algorithm"><a href="#5-Algorithm" class="headerlink" title="5.Algorithm"></a>5.Algorithm</h2><h3 id="5-1-pSCAN"><a href="#5-1-pSCAN" class="headerlink" title="5.1 pSCAN"></a>5.1 pSCAN</h3><p>算法目标是减少结构相似性计算的次数，把边分为 $E_{c,c}$，$E_{c,n}$，分别讨论。</p><img src="https://cdn.jsdelivr.net/gh/gejoyy/Pictures@main/image-20230627153257747.png" alt="pscan-algorithm-3" style="zoom:67%;" /><ul><li>行 1，初始化每个顶点成单个子集。</li><li>行 2-4，初始化每个顶点 sd(u), ed(u)。</li><li>行 5-7，按有效度 ed(u) 非递增顺序遍历顶点 u，检测 u 是否为 core，如果 u 是 core，把 u 和已经确定为 core 的邻点聚类到一起。</li><li>行 8-9，得到 core 顶点聚类 $C_c$，再聚类 non-core 顶点集合。</li><li>用不相交数据结构(disjoint-set data) 聚类 $G_c$ 中的 core，形成多个不相交的集合 S &#x3D; {s1, s2,…}<ul><li>find-subset：查看元素在哪一个子集中。</li><li>union：合并两个子集。</li></ul></li><li>union(u, v) 相当于在 $G_c$ 中添加一条边(u, v)。</li><li>两个顶点 u，v 属于同一连接组件（聚类）当且仅当 u，v 所在的子集相同，即：find-subset(u) &#x3D; find-subset(v)。</li></ul><p><strong>effective-degree: ed(u)</strong></p><ul><li>目的：为了减少相似度计算，按 ed(u) <strong>非递增</strong>顺序排序顶点。</li><li>定义：|N[u]|减去与 u 不相似的邻点的数量，得到可能相似的邻点的数量，满足 |$N_{eps}[u]$| ≤ ed(u)，ed(u) 是上界。</li><li>如果 ed(u) ≤ $\mu$，上界小于 $\mu$，则 u 是 non-core，从而减少<strong>顶点对 $E_{n,n}$ 的计算次数</strong>，对两个 non-core 顶点，不用计算它们之间相似度。</li></ul><p><strong>similar-degree: sd(u)</strong></p><ul><li>目的：为了有效检查一个顶点是否为 core。</li><li>定义：sd(u) 是已经确定与 u 相似的邻居的数量，满足|$N_{eps}[u]$| ≥ sd(u)，sd(u) 是下界。</li><li>如果 sd(u) ≥ $\mu$，下界大于 $\mu$，则 u 是 core。</li></ul><h3 id="5-2-CheckCore"><a href="#5-2-CheckCore" class="headerlink" title="5.2 CheckCore"></a>5.2 CheckCore</h3><p>目的：检测一个顶点是否为 core，减少顶点对 $E_{n,n}$的计算。</p><img src="https://cdn.jsdelivr.net/gh/gejoyy/Pictures@main/image-20230627153654828.png" alt="pscan-algorithm-4" style="zoom:67%;" /><ul><li>行 1，对于 ed(u) &lt; $\mu$（确定为 non-core）和 sd(u) ≥ $\mu$（确定 core）两种情况无需讨论，因为 ed(u) ≥ sd(u)，所以讨论第三种情况，ed(u) ≥ $\mu$ &gt;sd(u)，需要计算 u 和其邻居的相似性，<strong>以检测 u 是否为core</strong>。</li><li>行 2，初始化 ed(u)，sd(u)。</li><li>行 3-6，计算相似度，然后更新 ed(u)，sd(u)。</li><li>行 7-9，如果邻点 v 还没有被探索，更新 ed(v)，sd(v)，如果 ed(u) &lt; $\mu$ 或者 sd(u) ≥ $\mu$，则<strong>后面不需要探索 v</strong>，即可确定 v 是 core 还是 non-core。</li><li>行 10，知道确定 u 是 core 还是 non-core。</li><li>最后，标记 u 已被探索过，之后不需要更新 ed(u)，sd(u)。</li></ul><h3 id="5-3-ClusterCore"><a href="#5-3-ClusterCore" class="headerlink" title="5.3 ClusterCore"></a>5.3 ClusterCore</h3><p>目的：聚类核心顶点的邻居顶点（也是核心顶点），减少了 $E_{c,c}$ 相似对的计算。</p><img src="https://cdn.jsdelivr.net/gh/gejoyy/Pictures@main/image-20230627154338133.png" alt="pscan-algorithm-5" style="zoom:67%;" /><ul><li>行 1-3，将与 u 结构相似的核心顶点（同时也是 u 的邻居顶点）分配到与 u 相同的集群中。</li><li>行 4-6，N’[u] 表示已经被计算过结构相似性邻居顶点 v 的集合，对于每个尚未被计算的 u 的结构相似邻居 v，如果 u 和 v 尚未分配给相同的集群，并且 v 可能是 core，则计算相似度(u, v)。</li><li>行 7-9，若 v 未被探索，如果(u, v)结构相似，更新 sd，否则不相似，更新 ed。</li><li>行 10，若 v 确定为 core，并且(u, v)相似，合并 u，v 到同一个集群中，属于同一聚类。</li></ul><h3 id="5-4-ClusterNoncore"><a href="#5-4-ClusterNoncore" class="headerlink" title="5.4 ClusterNoncore"></a>5.4 ClusterNoncore</h3><p>目的：减少 $E_{c,n}$ 相似对的计算。</p><img src="https://cdn.jsdelivr.net/gh/gejoyy/Pictures@main/image-20230627154711792.png" alt="pscan-algorithm-6" style="zoom:60%;" /><ul><li>行 4-7，遍历核心顶点的每个邻居 v，如果 v 是 non-core 并且 v 不在 u 的集群（可能包含 non-core）里，计算相似度(u,v)，如果还没计算的话。</li><li>行 8，如果（u，v）相似，把 v 加入 u 的集群。</li><li>行 6，如果 sd(v) ≥ $\mu$（v 为 core）或者 v 属于 u 的集群，则不需要计算 u，v 的相似度。</li><li>思考：计算 core 的时候，能够得出其邻居是 non-core（ed &lt; $\mu$），则不需要探索 non-core。</li></ul><p><strong>bin-sort</strong>: 桶排序，桶号 i 表示有效度 ed(u) &#x3D; i，顶点放入对应桶里，有效度 ed 只会减少，每一个桶是单链表。</p><p><strong>adjacency list</strong>: 输入图存储为邻接表，N(u)以顶点 id 排序，实践中计算 N[u] ∩ N[v] 表现更好。</p><h3 id="5-5-Optimization-Techniques"><a href="#5-5-Optimization-Techniques" class="headerlink" title="5.5 Optimization Techniques"></a>5.5 Optimization Techniques</h3><ol><li><strong>Criss link：</strong> 交叉连接 (u,v) 和 (v,u)，相似度计算减少一半，对于 N[u] 和 (u,v)，用二分查找 N[v] 中相反边(v,u)</li><li><strong>Pruning Rule：</strong> 修剪规则有效决定 u，v 是否相似，若 d[u] &lt; $\epsilon^2$·d[v] 或者 d[v] &lt; $\epsilon^2$·d[u]，则 $\sigma$(u, v) &lt; $\mu$。</li></ol><img src="https://cdn.jsdelivr.net/gh/gejoyy/Pictures@main/image-20230627155057753.png" alt="pscan-algorithm-6" style="zoom:67%;" /><ol start="3"><li><strong>Adaptive Structural Similarity Checking：</strong><ul><li>cn(u, v) 是满足 u，v 相似的<strong>最小公共邻居数量</strong>。</li><li>cn(u, v) &#x3D; $\lceil\sigma\cdot\sqrt{d[u]\cdot d[v]}\rceil$。</li><li>顶点相似等价于 |N[u] ∩ N[v]| ≥ cn(u,v)。</li></ul></li></ol><img src="https://cdn.jsdelivr.net/gh/gejoyy/Pictures@main/image-20230627155232123.png" alt="pscan-algorithm-7" style="zoom:67%;" /><ul><li><strong>cn(u,v) &lt; min{$d_u,d_v$} 不可能相似（提前结束）</strong></li><li><strong>只要满足 公共邻居数量 ≥ cn(u,v)，退出 while，返回 true（提前结束）</strong></li></ul><h2 id="6-Dynameically-cluster-maintenance"><a href="#6-Dynameically-cluster-maintenance" class="headerlink" title="6.Dynameically cluster maintenance"></a>6.Dynameically cluster maintenance</h2><ul><li>经过 pSCAN 算法，我们已知道 1. 顶点 u 是否为 core，2.部分顶点是否相似。</li><li>由于剪枝算法，1) 存在一些顶点间是否相似并不知道 ；2) 一些顶点间具体相似值不知道。</li><li>为了维护聚类，维持以下两个数据：<ul><li>每个顶点，维护 sd(u)，或者说<strong>维护核心顶点的集合</strong>。、</li><li>每个边，维护 t(u, v) &#x3D; |N[u] ∩ N[v]|，t(u, v) 的值可能为 0(没有边)，为 1（没有边但有一个共同邻居）。</li></ul></li><li>在 pSCAN 算法过程中，维护 t(u, v)：<ul><li>若 u，v 相似，则 t(u, v) &gt; 0，反之 t &gt; 0，不一定相似（t&#x3D;1）。</li><li>若 u，v 不相似，则 t(u, v) &lt; 0 （不存在边，或者有边且有多个共同邻居但<strong>不相似</strong>，此时为负整数）。</li><li>其他情况，t(u, v) &#x3D; 0，对与未知的 t(x,y)值，默认 t(x,y)&#x3D;0。</li><li>此外 |t(u, v) | ≥ 2，则 |t(u, v) | &#x3D; |N[u] ∩ N[v]|，注意是<strong>绝对值</strong>，t 可能为负数（-2，-3，···）</li></ul></li></ul><h3 id="6-1-ClusterMaintenance"><a href="#6-1-ClusterMaintenance" class="headerlink" title="6.1 ClusterMaintenance"></a>6.1 ClusterMaintenance</h3><img src="https://cdn.jsdelivr.net/gh/gejoyy/Pictures@main/image-20230627155758739.png" alt="pscan-algorithm-8" style="zoom:67%;" /><h3 id="6-2-Maintaining-Core-Vertices"><a href="#6-2-Maintaining-Core-Vertices" class="headerlink" title="6.2 Maintaining Core Vertices"></a>6.2 Maintaining Core Vertices</h3><ul><li>定义 N[u, v] &#x3D; N[u] ∪ N[v]。</li><li>在插入或删除边（u，v）后，只有边相关顶点相似值可能改变，那些不在 N[u,v]的顶点相似值不变，可能从 core 变为 non-core，或相反，因此考虑 N[u,v] 中的顶点，维护核心顶点集合。</li></ul><h4 id="6-2-1-Edge-insert"><a href="#6-2-1-Edge-insert" class="headerlink" title="6.2.1 Edge insert"></a>6.2.1 <strong>Edge insert</strong></h4><p>对每个 w ∈ N[u, v]，维护 sd(w)，N[u, v]划分四个集合分别考虑。</p><ul><li><strong>w ∈ N(u) 但不属于 N(v)：</strong><ul><li>若 t(w, u) ≤ 0，则 t(w, u)，sd(w) 不改变，因为 $\sigma$(w, u) 变小了，不存在 u 从 non-core 变为 core。</li><li>若 t(w, u) &gt; 0 且 sd(w) &lt; $\mu$，即 w 是 non-core，则 w 还是 non-core，需要更新 t(w,u)，sd(w)。</li><li>若 t(w, u) &gt; 0 且 sd(w) ≥ $\mu$，即 w 是 core，需要更新 t(w,u)，sd(w)，如果 $sd’$(w) &lt; $\mu$，需要计算相似性，对那些 w 的邻接点 x，满足 t(w, x) &#x3D; 0，去检查 w 是否仍然为 core。</li></ul></li><li><strong>w ∈ N(v) 但不属于 N(u)，做法同上。</strong></li><li><strong>w ∈ N(u) ∩ N(v)：</strong><ul><li>w 是共同邻接点，则 $\sigma’$(w, u) &gt; $\sigma$(w, u)，相似度变大了，同理 $\sigma$(w,v) 也变大（三角形数加一）。</li><li>若更新前 w 是 core，更新后仍然为 core，也要更新 t(w, u), t(w,v)。</li><li>若更新前 w 是 non-core，则需要更新 t(w,u), t(w, v)，其他邻接点 x 满足 t(w,x) &#x3D; 0 决定 w 是一个 core 更新后。</li></ul></li><li><strong>对于顶点 u，v：</strong><ul><li>考虑 u，由于 sd(u) &lt; $\mu$ 并且 邻接点 x 满足 t(u, x) &#x3D; 0，即在更新后（删除边 x,u）u 可能成为 core，则计算|N[u] ∩ N[v]|，更新 t(u, x) 和 sd(u)。</li><li>对于其他 邻接点 y 满足 t(u, y) $\neq$ 0，t(u, y)已经被更新过，在插入边 (u,x) 时候。</li><li>对于 v，做法一样。</li></ul></li></ul><p><strong>MaintainCoreVertices</strong>: </p><ul><li>对应上面四种处理方法</li></ul><img src="https://cdn.jsdelivr.net/gh/gejoyy/Pictures@main/image-20230627160221009.png" alt="pscan-algorithm-9" style="zoom:80%;" /><ul><li>行 2-10，w ∈ N(v)\N(u)；</li><li>行 12-22，w ∈ N(u)∩N(v)；</li><li>行 23-26，处理 u，v。</li><li>三角形 t(u, v) &#x3D; |N[u] ∩ N[v]|，若（u，v）确定不相似（可以没有边），则 t(u, v) &#x3D; - t(u, v)，变成负数。</li><li>行 27-29，若 |t(x, y)| ≤ 1，则重新计算 |N[x] ∩ N[y]|，否则更新 t(x,y) &#x3D; |t(x,y)| + 三角形。</li><li>行 30，判断 x，y 是否相似，赋值 t(x, y) 正负号。</li></ul><h4 id="6-2-2-Edge-Deletion"><a href="#6-2-2-Edge-Deletion" class="headerlink" title="6.2.2 Edge Deletion"></a>6.2.2 Edge Deletion</h4><ul><li>对 w ∈ N[u,v]，维护 sd(w)，与 insert edge 做法相似。</li><li>w ∈ N[u] \ N[v]，有 $\sigma’$(w, u) &gt; $\sigma$(w, u)。</li><li>w ∈ N[u] ∩ N[v]，有 $\sigma’$(w, u) &lt; $\sigma$(w, u)。</li></ul><h3 id="6-3-Maintaining-Structral-Similarities"><a href="#6-3-Maintaining-Structral-Similarities" class="headerlink" title="6.3 Maintaining Structral Similarities"></a>6.3 Maintaining Structral Similarities</h3><ul><li>考虑 t (x, y) 不在 N[u, v]：<ul><li>t(x,y)可能为 0 ，对（x,y）∈ E，在运行 pSCAN，维护聚类时候，例如删除边(x,y)，则 t()&#x3D;0。</li><li>聚类 C 可能分成两部分，由于里面一些边从相似 <strong>变为</strong> 不相似。</li><li>存在一个边在 C 中，满足 t(x,y)&#x3D;0 且 $\sigma$(x, y) ≥ $\epsilon$，把两个集合连接成一个聚类。</li></ul></li><li>因此要考虑 t(x,y)&#x3D;0，但不是对所有 edge（x,y）满足 t(x,y)&#x3D;0 ，都要更新，会延迟更新信息时间，因此关键在于如何选取哪些边 t&#x3D;0。</li><li>若聚类 C 中所有边满足 t&gt;0，聚类能够获得通过 BFS，基于 sd()，t()。</li><li>对于聚类 C，如果满足以下条件，不需要探索聚类 C 中顶点去更新 t()：<ul><li>不存在边 从 t&gt;0 变成 t&lt;0；</li><li>不存在核心顶点的邻接边，满足 t() &#x3D; 0；</li></ul></li><li>因此对每一个 core，提出一个平衡值 AllCh，<code>AllCh(x) = true</code> 当且仅当聚类 C 中不存在核心顶点邻接边 t &#x3D; 0。</li></ul><img src="https://cdn.jsdelivr.net/gh/gejoyy/Pictures@main/image-20230627160648438.png" alt="pscan-algorithm-10" style="zoom:80%" align="center" /><ul><li>edge(x,y) 从 t(x,y)&gt;0 变成 t(x,y)&lt;0：<ul><li>若更新前 x 是 core，则对所有与 x 结构可达的 core 满足 <code>AllCh() = true</code>，计算所有未知的 t(·,·)（即 t&#x3D;0）。</li><li>对 y 做法同上。</li><li>若更新后 x 或 y，从 non-core 变成 core，则必定存在另一个邻接边从 t ≤ 0 变成 t ≥ 0。</li></ul></li><li>edge(x,y) 从 t(x,y)≤0 变成 t(x,y)&gt;0：<ul><li>若 x 从 non-core 变成 core，则计算未知 t(·,·)，对所有临界边。</li><li>对 y 做法同上。</li><li>若更新后 x 和 y 都是 core 且 AllCh(x) $\neq$ AllCh(y)，则计算未知的 t( , )，即 t 值为 0。</li></ul></li><li>AllCh(x) 初始化每个点为 <code>false</code>。</li><li>若 x 是 core，UpdateReachable(x)计算未知 t() 值，对所有聚类中的 core 且满足 <code>AllCh() = true</code>；否则 UpdateReachable(x) 等价于 UpdateReachable(y)，对每一个 y 的 core 邻接点。</li><li>注意如果 <code>AllCh(x) = true</code>，调用 UpdateReachable(x) 将什么都不做。</li></ul>]]></content>
    
    
    <categories>
      
      <category>论文笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>SCAN</tag>
      
      <tag>graph</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
