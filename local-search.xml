<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>从源码解读 TinyWebServer 之 webserver</title>
    <link href="/%E4%BB%8E%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB%20TinyWebServer%20%E4%B9%8B%20webserver.html"/>
    <url>/%E4%BB%8E%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB%20TinyWebServer%20%E4%B9%8B%20webserver.html</url>
    
    <content type="html"><![CDATA[<p>本文从源码开始解读开源 TinyWebserver 项目，彻底理解客户端连接服务端的过程发生了什么，服务器又是如何处理来自客户端的请求。</p><span id="more"></span><h2 id="TinyWebServer"><a href="#TinyWebServer" class="headerlink" title="TinyWebServer"></a>TinyWebServer</h2><p>Linux 下 C++轻量级 Web 服务器，助力初学者快速实践网络编程，搭建属于自己的服务器。</p><ul><li>使用线程池+非阻塞 socket+epoll(ET 和 LT 均实现)+事件处理(Reactor 和模拟 Proactor 均实现)的并发模型。</li><li>使用<strong>状态机</strong>解析 HTTP 请求报文，支持解析 <strong>GET 和 POST</strong> 请求。</li><li>访问服务器数据库实现 web 端用户<strong>注册、登录</strong>功能，可以请求服务器<strong>图片和视频文件</strong>。</li><li>实现<strong>同步&#x2F;异步日志系统</strong>，记录服务器运行状态。</li><li>经 Webbench 压力测试可以实现<strong>上万的并发连接</strong>数据交换。</li></ul><h2 id="config-模块"><a href="#config-模块" class="headerlink" title="config 模块"></a>config 模块</h2><p>打开源文件首先看到 config 的头文件，根据标识可以知道这是一个用户自定义头，里面是一些参数配置。</p><h3 id="config-h-代码解读"><a href="#config-h-代码解读" class="headerlink" title="config.h 代码解读"></a>config.h 代码解读</h3><p>这里体现出整个项目的优点：<strong>模式切换</strong>，也就是说这是一个复合的 ET&#x2F;LT。作者在 Listenfd 上和 cfd 上都建立了两种模式，意味着我们有四种组合方式。</p><p>ET 与 LT 模式：</p><ul><li>ET 代表着一次性接受所有连接，这里是考虑到网络接入量巨大，瞬间占到 Max_size 的情况。</li><li>LT 代表一次取一个，当然这是默认的方式也是最常见的方式。</li></ul><p>cfd 的两种方式也就是对应了 epoll 的方式，默认的 LT 和手动的 ET。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">ifndef</span> CONFIG_H</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> CONFIG_H</span><br><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;webserver.h&quot;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Config</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">Config</span>();<br><br>    ~<span class="hljs-built_in">Config</span>() &#123;&#125;;<br><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">parse_arg</span><span class="hljs-params">(<span class="hljs-type">int</span> argc, <span class="hljs-type">char</span> *argv[])</span></span>;<br><br>    <span class="hljs-comment">//端口号</span><br>    <span class="hljs-type">int</span> PORT;<br><br>    <span class="hljs-comment">//数据库校验方式</span><br>    <span class="hljs-type">int</span> SQLVerify;<br><br>    <span class="hljs-comment">//日志写入方式</span><br>    <span class="hljs-type">int</span> LOGWrite;<br><br>    <span class="hljs-comment">//触发组合模式</span><br>    <span class="hljs-type">int</span> TRIGMode;<br><br>    <span class="hljs-comment">//listenfd触发模式</span><br>    <span class="hljs-type">int</span> LISTENTrigmode;<br><br>    <span class="hljs-comment">//connfd触发模式</span><br>    <span class="hljs-type">int</span> CONNTrigmode;<br><br>    <span class="hljs-comment">//优雅关闭链接</span><br>    <span class="hljs-type">int</span> OPT_LINGER;<br><br>    <span class="hljs-comment">//数据库连接池数量</span><br>    <span class="hljs-type">int</span> sql_num;<br><br>    <span class="hljs-comment">//线程池内的线程数量</span><br>    <span class="hljs-type">int</span> thread_num;<br><br>    <span class="hljs-comment">//是否关闭日志</span><br>    <span class="hljs-type">int</span> close_log;<br><br>    <span class="hljs-comment">//并发模型选择</span><br>    <span class="hljs-type">int</span> actor_model;<br>&#125;;<br><br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br></code></pre></td></tr></table></figure><h3 id="config-cpp-代码解读"><a href="#config-cpp-代码解读" class="headerlink" title="config.cpp 代码解读"></a>config.cpp 代码解读</h3><p>构造参数里作出了对于各种初始模式的设定，并且在并发模式处理中，作者给出了 reactor 和 proactor 两种方式。</p><ul><li><strong>Reactor 是非阻塞同步网络模式，感知的是就绪可读写事件</strong>。在每次感知到有事件发生（比如可读就绪事件）后，就需要应用进程主动调用 read 方法来完成数据的读取，也就是要应用进程主动将 socket 接收缓存中的数据读到应用进程内存中，这个过程是同步的，读取完数据后应用进程才能处理数据。</li><li><strong>Proactor 是异步网络模式，感知的是已完成的读写事件</strong>。在发起异步读写请求时，需要传入数据缓冲区的地址（用来存放结果数据）等信息，这样系统内核才可以自动帮我们把数据的读写工作完成，这里的读写工作全程由操作系统来做，并不需要像 Reactor 那样还需要应用进程主动发起 read&#x2F;write 来读写数据，操作系统完成读写工作后，就会通知应用进程直接处理数据。</li></ul><p>因此，<strong>Reactor 可以理解为「来了事件操作系统通知应用进程，让应用进程来处理」</strong>，而 <strong>Proactor 可以理解为「来了事件操作系统来处理，处理完再通知应用进程」</strong>。这里的「事件」就是有新连接、有数据可读、有数据可写的这些 I&#x2F;O 事件这里的「处理」包含从驱动读取到内核以及从内核读取到用户空间。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;config.h&quot;</span></span><br><br>Config::<span class="hljs-built_in">Config</span>() &#123;<br>    <span class="hljs-comment">//端口号,默认9006</span><br>    PORT = <span class="hljs-number">9006</span>;<br><br>    <span class="hljs-comment">//数据库校验方式，默认同步</span><br>    SQLVerify = <span class="hljs-number">0</span>;<br><br>    <span class="hljs-comment">//日志写入方式，默认同步</span><br>    LOGWrite = <span class="hljs-number">0</span>;<br><br>    <span class="hljs-comment">//触发组合模式,默认listenfd LT + connfd LT</span><br>    TRIGMode = <span class="hljs-number">0</span>;<br><br>    <span class="hljs-comment">//listenfd触发模式，默认LT</span><br>    LISTENTrigmode = <span class="hljs-number">0</span>;<br><br>    <span class="hljs-comment">//connfd触发模式，默认LT</span><br>    CONNTrigmode = <span class="hljs-number">0</span>;<br><br>    <span class="hljs-comment">//优雅关闭链接，默认不使用</span><br>    OPT_LINGER = <span class="hljs-number">0</span>;<br><br>    <span class="hljs-comment">//数据库连接池数量,默认8</span><br>    sql_num = <span class="hljs-number">8</span>;<br><br>    <span class="hljs-comment">//线程池内的线程数量,默认8</span><br>    thread_num = <span class="hljs-number">8</span>;<br><br>    <span class="hljs-comment">//关闭日志,默认不关闭</span><br>    close_log = <span class="hljs-number">0</span>;<br><br>    <span class="hljs-comment">//并发模型,默认是proactor</span><br>    actor_model = <span class="hljs-number">0</span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Config::parse_arg</span><span class="hljs-params">(<span class="hljs-type">int</span> argc, <span class="hljs-type">char</span> *argv[])</span> </span>&#123;<br>    <span class="hljs-type">int</span> opt;<br>    <span class="hljs-type">const</span> <span class="hljs-type">char</span> *str = <span class="hljs-string">&quot;p:v:l:m:o:s:t:c:a:&quot;</span>;<br>    <span class="hljs-keyword">while</span> ((opt = <span class="hljs-built_in">getopt</span>(argc, argv, str)) != <span class="hljs-number">-1</span>) &#123;<br>        <span class="hljs-keyword">switch</span> (opt) &#123;<br>            <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;p&#x27;</span>: &#123;<br>                PORT = <span class="hljs-built_in">atoi</span>(optarg);<br>                <span class="hljs-keyword">break</span>;<br>            &#125;<br>            <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;v&#x27;</span>: &#123;<br>                SQLVerify = <span class="hljs-built_in">atoi</span>(optarg);<br>                <span class="hljs-keyword">break</span>;<br>            &#125;<br>            <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;l&#x27;</span>: &#123;<br>                LOGWrite = <span class="hljs-built_in">atoi</span>(optarg);<br>                <span class="hljs-keyword">break</span>;<br>            &#125;<br>            <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;m&#x27;</span>: &#123;<br>                TRIGMode = <span class="hljs-built_in">atoi</span>(optarg);<br>                <span class="hljs-keyword">break</span>;<br>            &#125;<br>            <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;o&#x27;</span>: &#123;<br>                OPT_LINGER = <span class="hljs-built_in">atoi</span>(optarg);<br>                <span class="hljs-keyword">break</span>;<br>            &#125;<br>            <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;s&#x27;</span>: &#123;<br>                sql_num = <span class="hljs-built_in">atoi</span>(optarg);<br>                <span class="hljs-keyword">break</span>;<br>            &#125;<br>            <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;t&#x27;</span>: &#123;<br>                thread_num = <span class="hljs-built_in">atoi</span>(optarg);<br>                <span class="hljs-keyword">break</span>;<br>            &#125;<br>            <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;c&#x27;</span>: &#123;<br>                close_log = <span class="hljs-built_in">atoi</span>(optarg);<br>                <span class="hljs-keyword">break</span>;<br>            &#125;<br>            <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;a&#x27;</span>: &#123;<br>                actor_model = <span class="hljs-built_in">atoi</span>(optarg);<br>                <span class="hljs-keyword">break</span>;<br>            &#125;<br>            <span class="hljs-keyword">default</span>:<br>                <span class="hljs-keyword">break</span>;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="main-模块"><a href="#main-模块" class="headerlink" title="main 模块"></a>main 模块</h2><p>main 模块的主要功能是驱动 Sever。WebServer 被单独作为一个类实现，并且封装好了调度函数。也就是说，main 函数相当于一个开关，我打开了服务器的开关让他进入了 listen 状态，同时也转身打开了数据库的开关。当然，这个开关的信息，来自于 config。</p><h3 id="main-cpp-代码解读"><a href="#main-cpp-代码解读" class="headerlink" title="main.cpp 代码解读"></a>main.cpp 代码解读</h3><p>这里的命令行解析是给数据库的运行方式传参，当然可以什么都不传，不传默认使用 config 的参数配置。首先初始化一个服务器对象，启动日志服务，连接数据库，初始化线程池，然后设置运行模式，之后就是启动监听和进入工作循环（事务循环）。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;config.h&quot;</span></span><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-type">int</span> argc, <span class="hljs-type">char</span> *argv[])</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-comment">//需要修改的数据库信息,登录名,密码,库名</span><br>    string user = <span class="hljs-string">&quot;root&quot;</span>;<br>    string passwd = <span class="hljs-string">&quot;root&quot;</span>;<br>    string databasename = <span class="hljs-string">&quot;qgydb&quot;</span>;<br><br>    <span class="hljs-comment">//命令行解析</span><br>    Config config;<br>    config.<span class="hljs-built_in">parse_arg</span>(argc, argv);<br><br>    WebServer server;<br><br>    <span class="hljs-comment">//初始化</span><br>    server.<span class="hljs-built_in">init</span>(config.PORT, user, passwd, databasename, config.LOGWrite, config.SQLVerify,<br>                config.OPT_LINGER, config.TRIGMode,  config.sql_num,  config.thread_num,<br>                config.close_log, config.actor_model);<br><br><br>    <span class="hljs-comment">//日志</span><br>    server.<span class="hljs-built_in">log_write</span>();<br><br>    <span class="hljs-comment">//数据库</span><br>    server.<span class="hljs-built_in">sql_pool</span>();<br><br>    <span class="hljs-comment">//线程池</span><br>    server.<span class="hljs-built_in">thread_pool</span>();<br><br>    <span class="hljs-comment">//触发模式</span><br>    server.<span class="hljs-built_in">trig_mode</span>();<br><br>    <span class="hljs-comment">//监听</span><br>    server.<span class="hljs-built_in">eventListen</span>();<br><br>    <span class="hljs-comment">//运行</span><br>    server.<span class="hljs-built_in">eventLoop</span>();<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="WebServer-模块"><a href="#WebServer-模块" class="headerlink" title="WebServer 模块"></a>WebServer 模块</h2><p>这是服务器的关键部分，集成了各种复杂模块，按顺序依次调度。</p><h3 id="trig-mode-函数"><a href="#trig-mode-函数" class="headerlink" title="trig_mode 函数"></a>trig_mode 函数</h3><p>对应四种组合模式</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">WebServer::trig_mode</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-comment">//LT + LT</span><br>    <span class="hljs-keyword">if</span> (<span class="hljs-number">0</span> == m_TRIGMode)<br>    &#123;<br>        m_LISTENTrigmode = <span class="hljs-number">0</span>;<br>        m_CONNTrigmode = <span class="hljs-number">0</span>;<br>    &#125;<br>    <span class="hljs-comment">//LT + ET</span><br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (<span class="hljs-number">1</span> == m_TRIGMode)<br>    &#123;<br>        m_LISTENTrigmode = <span class="hljs-number">0</span>;<br>        m_CONNTrigmode = <span class="hljs-number">1</span>;<br>    &#125;<br>    <span class="hljs-comment">//ET + LT</span><br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (<span class="hljs-number">2</span> == m_TRIGMode)<br>    &#123;<br>        m_LISTENTrigmode = <span class="hljs-number">1</span>;<br>        m_CONNTrigmode = <span class="hljs-number">0</span>;<br>    &#125;<br>    <span class="hljs-comment">//ET + ET</span><br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (<span class="hljs-number">3</span> == m_TRIGMode)<br>    &#123;<br>        m_LISTENTrigmode = <span class="hljs-number">1</span>;<br>        m_CONNTrigmode = <span class="hljs-number">1</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="eventListen-函数"><a href="#eventListen-函数" class="headerlink" title="eventListen 函数"></a>eventListen 函数</h3><p>eventListen 根据名字知道是实现监听事务的部分。</p><ul><li>首先是处理连接关闭部分，将剩余未处理完的数据发送完成再退出，或者在内核停留一段时间确保消息传达。</li><li>其次调用 epoll，将 lfd 上树，这里的上树封装 addfd 目的是为了可以更改模式。</li><li>之后就是创建了管道，这里牵扯到进程间通信的问题。这么做的好处就是统一事件源。因为正常情况下，信号处理与 IO 处理不走一条路。</li></ul><p><strong>这里的信号主要是超时问题</strong>，具体的做法是，信号处理函数使用管道将信号传递给主循环，信号处理函数往管道的写端写入信号值，主循环则从管道的读端读出信号值，使用 I&#x2F;O 复用系统调用来监听管道读端的可读事件，这样信号事件与其他文件描述符都可以通过 epoll 来监测，从而实现统一处理。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">WebServer::eventListen</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-comment">//网络编程基础步骤</span><br>    m_listenfd = <span class="hljs-built_in">socket</span>(PF_INET, SOCK_STREAM, <span class="hljs-number">0</span>);<br>    <span class="hljs-comment">//如果它的条件返回错误，则终止程序执行</span><br>    <span class="hljs-built_in">assert</span>(m_listenfd &gt;= <span class="hljs-number">0</span>);<br><br>    <span class="hljs-comment">//优雅关闭连接</span><br>    <span class="hljs-keyword">if</span> (<span class="hljs-number">0</span> == m_OPT_LINGER)<br>    &#123;<br>        <span class="hljs-comment">//底层会将未发送完的数据发送完成后再释放资源，也就是优雅的退出</span><br>        <span class="hljs-keyword">struct</span> <span class="hljs-title class_">linger</span> tmp = &#123;<span class="hljs-number">0</span>, <span class="hljs-number">1</span>&#125;;<br>        <span class="hljs-built_in">setsockopt</span>(m_listenfd, SOL_SOCKET, SO_LINGER, &amp;tmp, <span class="hljs-built_in">sizeof</span>(tmp));<br>    &#125;<br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (<span class="hljs-number">1</span> == m_OPT_LINGER)<br>    &#123;<br>        <span class="hljs-comment">//这种方式下，在调用closesocket的时候不会立刻返回，内核会延迟一段时间，这个时间就由l_linger得值来决定。</span><br>        <span class="hljs-comment">//如果超时时间到达之前，发送完未发送的数据(包括FIN包)并得到另一端的确认，closesocket会返回正确，socket描述符优雅性退出。</span><br>        <span class="hljs-comment">//否则，closesocket会直接返回 错误值，未发送数据丢失，socket描述符被强制性退出。需要注意的时，如果socket描述符被设置为非堵塞型，则closesocket会直接返回值。</span><br>        <span class="hljs-keyword">struct</span> linger tmp = &#123;<span class="hljs-number">1</span>, <span class="hljs-number">1</span>&#125;;<br>        <span class="hljs-built_in">setsockopt</span>(m_listenfd, SOL_SOCKET, SO_LINGER, &amp;tmp, <span class="hljs-built_in">sizeof</span>(tmp));<br>    &#125;<br><br>    <span class="hljs-type">int</span> ret = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">struct</span> <span class="hljs-title class_">sockaddr_in</span> address;<br>    <span class="hljs-comment">// bzero() 会将内存块（字符串）的前n个字节清零;</span><br>    <span class="hljs-comment">// s为内存（字符串）指针，n 为需要清零的字节数。</span><br>    <span class="hljs-comment">// 在网络编程中会经常用到。</span><br>    <span class="hljs-built_in">bzero</span>(&amp;address, <span class="hljs-built_in">sizeof</span>(address));<br>    address.sin_family = AF_INET;<br>    address.sin_addr.s_addr = <span class="hljs-built_in">htonl</span>(INADDR_ANY);<br>    address.sin_port = <span class="hljs-built_in">htons</span>(m_port);<br><br>    <span class="hljs-type">int</span> flag = <span class="hljs-number">1</span>;<br>    <span class="hljs-comment">//允许重用本地地址和端口</span><br>    <span class="hljs-built_in">setsockopt</span>(m_listenfd, SOL_SOCKET, SO_REUSEADDR, &amp;flag, <span class="hljs-built_in">sizeof</span>(flag));<br>    <span class="hljs-comment">//传统绑定步骤</span><br>    ret = <span class="hljs-built_in">bind</span>(m_listenfd, (<span class="hljs-keyword">struct</span> sockaddr *)&amp;address, <span class="hljs-built_in">sizeof</span>(address));<br>    <span class="hljs-built_in">assert</span>(ret &gt;= <span class="hljs-number">0</span>);<br>    <span class="hljs-comment">//传统监听步骤</span><br>    ret = <span class="hljs-built_in">listen</span>(m_listenfd, <span class="hljs-number">5</span>);<br>    <span class="hljs-built_in">assert</span>(ret &gt;= <span class="hljs-number">0</span>);<br><br>    <span class="hljs-comment">//工具类,信号和描述符基础操作</span><br>    Utils::u_pipefd = m_pipefd;<br>    Utils::u_epollfd = m_epollfd;<br><br>    utils.<span class="hljs-built_in">init</span>(TIMESLOT);<br><br>    <span class="hljs-comment">//epoll创建内核事件表</span><br>    epoll_event events[MAX_EVENT_NUMBER];<br>    m_epollfd = <span class="hljs-built_in">epoll_create</span>(<span class="hljs-number">5</span>);<br>    <span class="hljs-built_in">assert</span>(m_epollfd != <span class="hljs-number">-1</span>);<br><br>    <span class="hljs-comment">//将lfd上树</span><br>    utils.<span class="hljs-built_in">addfd</span>(m_epollfd, m_listenfd, <span class="hljs-literal">false</span>, m_LISTENTrigmode);<br>    http_conn::m_epollfd = m_epollfd;<br><br>    <span class="hljs-comment">//创建管道套接字</span><br>    ret = <span class="hljs-built_in">socketpair</span>(PF_UNIX, SOCK_STREAM, <span class="hljs-number">0</span>, m_pipefd);<br>    <span class="hljs-built_in">assert</span>(ret != <span class="hljs-number">-1</span>);<br>    <span class="hljs-comment">//设置管道写端为非阻塞，为什么写端要非阻塞？</span><br>    <span class="hljs-comment">//send是将信息发送给套接字缓冲区，如果缓冲区满了，则会阻塞，</span><br>    <span class="hljs-comment">//这时候会进一步增加信号处理函数的执行时间，为此，将其修改为非阻塞。</span><br>    utils.<span class="hljs-built_in">setnonblocking</span>(m_pipefd[<span class="hljs-number">1</span>]);<br>    <span class="hljs-comment">//设置管道读端为ET非阻塞 统一事件源</span><br>    utils.<span class="hljs-built_in">addfd</span>(m_epollfd, m_pipefd[<span class="hljs-number">0</span>], <span class="hljs-literal">false</span>, <span class="hljs-number">0</span>);<br><br>    utils.<span class="hljs-built_in">addsig</span>(SIGPIPE, SIG_IGN);<br>    <span class="hljs-comment">//传递给主循环的信号值，这里只关注SIGALRM和SIGTERM</span><br>    utils.<span class="hljs-built_in">addsig</span>(SIGALRM, utils.sig_handler, <span class="hljs-literal">false</span>);<br>    utils.<span class="hljs-built_in">addsig</span>(SIGTERM, utils.sig_handler, <span class="hljs-literal">false</span>);<br><br>    <span class="hljs-comment">//每隔TIMESLOT时间触发SIGALRM信号</span><br>    <span class="hljs-built_in">alarm</span>(TIMESLOT);<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="eventLoop-函数"><a href="#eventLoop-函数" class="headerlink" title="eventLoop 函数"></a>eventLoop 函数</h3><p>这个函数可以说是始终伴随着程序始终。只要服务器不关，我就一直不退出，因为我退出了，main 也退出了。可以看出，这一函数的逻辑就是不断的处理产生事件的节点，而在 epoll_wait 返回后，我们主要处理三种事件：io 事件，信号，新的连接，也就是在 for 循环中的三次判断，并且每次处理完一组后，我们会刷新定时。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">WebServer::eventLoop</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">bool</span> timeout = <span class="hljs-literal">false</span>;<br>    <span class="hljs-type">bool</span> stop_server = <span class="hljs-literal">false</span>;<br><br>    <span class="hljs-keyword">while</span> (!stop_server)<br>    &#123;<br>        <span class="hljs-comment">//监测发生事件的文件描述符</span><br>        <span class="hljs-type">int</span> number = <span class="hljs-built_in">epoll_wait</span>(m_epollfd, events, MAX_EVENT_NUMBER, <span class="hljs-number">-1</span>);<br>        <span class="hljs-keyword">if</span> (number &lt; <span class="hljs-number">0</span> &amp;&amp; errno != EINTR)<br>        &#123;<br>            <span class="hljs-built_in">LOG_ERROR</span>(<span class="hljs-string">&quot;%s&quot;</span>, <span class="hljs-string">&quot;epoll failure&quot;</span>);<br>            <span class="hljs-keyword">break</span>;<br>        &#125;<br><br>        <span class="hljs-comment">//轮询有事件产生的文件描述符</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; number; i++)<br>        &#123;<br>            <span class="hljs-type">int</span> sockfd = events[i].data.fd;<br><br>            <span class="hljs-comment">//处理新到的客户连接</span><br>            <span class="hljs-keyword">if</span> (sockfd == m_listenfd)<br>            &#123;<br>                <span class="hljs-type">bool</span> flag = <span class="hljs-built_in">dealclinetdata</span>();<br>                <span class="hljs-keyword">if</span> (<span class="hljs-literal">false</span> == flag)<br>                    <span class="hljs-keyword">continue</span>;<br>            &#125;<br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (events[i].events &amp; (EPOLLRDHUP | EPOLLHUP | EPOLLERR))<br>            &#123;<br>                <span class="hljs-comment">//服务器端关闭连接，移除对应的定时器</span><br>                util_timer *timer = users_timer[sockfd].timer;<br>                <span class="hljs-built_in">deal_timer</span>(timer, sockfd);<br>            &#125;<br>            <span class="hljs-comment">//处理信号</span><br>            <span class="hljs-comment">//管道读端对应文件描述符发生读事件</span><br>            <span class="hljs-comment">//因为统一了事件源，信号处理当成读事件来处理</span><br>            <span class="hljs-comment">//就是信号回调函数哪里不立即处理而是写到：pipe的写端</span><br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> ((sockfd == m_pipefd[<span class="hljs-number">0</span>]) &amp;&amp; (events[i].events &amp; EPOLLIN))<br>            &#123;<br>                <span class="hljs-type">bool</span> flag = <span class="hljs-built_in">dealwithsignal</span>(timeout, stop_server);<br>                <span class="hljs-keyword">if</span> (<span class="hljs-literal">false</span> == flag)<br>                    <span class="hljs-built_in">LOG_ERROR</span>(<span class="hljs-string">&quot;%s&quot;</span>, <span class="hljs-string">&quot;dealclientdata failure&quot;</span>);<br>            &#125;<br>            <span class="hljs-comment">//处理客户连接上接收到的数据</span><br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (events[i].events &amp; EPOLLIN)<br>            &#123;<br>                <span class="hljs-built_in">dealwithread</span>(sockfd);<br>            &#125;<br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (events[i].events &amp; EPOLLOUT)<br>            &#123;<br>                <span class="hljs-built_in">dealwithwrite</span>(sockfd);<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">if</span> (timeout)<br>        &#123;<br>            utils.<span class="hljs-built_in">timer_handler</span>();<br><br>            <span class="hljs-built_in">LOG_INFO</span>(<span class="hljs-string">&quot;%s&quot;</span>, <span class="hljs-string">&quot;timer tick&quot;</span>);<br><br>            timeout = <span class="hljs-literal">false</span>;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="dealclinetdata-函数"><a href="#dealclinetdata-函数" class="headerlink" title="dealclinetdata 函数"></a>dealclinetdata 函数</h3><p>函数处理数据连接部分，建立连接分为两种模式 ET 和 LT：</p><blockquote><p>LT 模式：即<strong>水平触发模式</strong>，当 epoll_wait 检测到监听文件描述符上有事件发生时通知应用程序，应用程序可以不理解处理该事件，下次调用 epoll_wait 时该事件还会被通告直到该事件被处理。</p><p>ET 模式：即<strong>边缘触发模式</strong>，当 epoll_wait 检测到事件发生告知应用程序后应用程序必须立即处理该事件，后续的 epoll_wait 将不会再向应用程序告知这一事件。</p></blockquote><p>LT 是系统默认，工作在这种方式下，程序员不易出问题，在接收数据时，只要 socket 输入缓存有数据，都能够获得 EPOLLIN 的持续通知， 同样在发送数据时，只要发送缓存够用，都会有持续不间断的 EPOLLOUT 通知。</p><p>ET 是另外一种触发方式，比 EPOLLLT 要高效很多，对程序员的要求也多些，程序员必须小心使用，因为工作在此种方式下时，在接收数据时，如果有数据只会通知一次，假如 read 时未读完数据，那么不会再有 EPOLLIN 的通知了，直到下次有新的数据到达时为止；当发送数据时，如果发送缓存未满也只有一次 EPOLLOUT 的通知，除非你把发送缓存塞满了，才会有第二次 EPOLLOUT 通知的机会，所以在此方式下 read 和 write 时都要处理好。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">WebServer::dealclinetdata</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">struct</span> <span class="hljs-title class_">sockaddr_in</span> client_address;<br>    <span class="hljs-type">socklen_t</span> client_addrlength = <span class="hljs-built_in">sizeof</span>(client_address);<br>    <span class="hljs-comment">//LT</span><br>    <span class="hljs-keyword">if</span> (<span class="hljs-number">0</span> == m_LISTENTrigmode)<br>    &#123;<br>        <span class="hljs-type">int</span> connfd = <span class="hljs-built_in">accept</span>(m_listenfd, (<span class="hljs-keyword">struct</span> sockaddr *)&amp;client_address, &amp;client_addrlength);<br>        <span class="hljs-keyword">if</span> (connfd &lt; <span class="hljs-number">0</span>)<br>        &#123;<br>            <span class="hljs-built_in">LOG_ERROR</span>(<span class="hljs-string">&quot;%s:errno is:%d&quot;</span>, <span class="hljs-string">&quot;accept error&quot;</span>, errno);<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        &#125;<br>        <span class="hljs-keyword">if</span> (http_conn::m_user_count &gt;= MAX_FD)<br>        &#123;<br>            utils.<span class="hljs-built_in">show_error</span>(connfd, <span class="hljs-string">&quot;Internal server busy&quot;</span>);<br>            <span class="hljs-built_in">LOG_ERROR</span>(<span class="hljs-string">&quot;%s&quot;</span>, <span class="hljs-string">&quot;Internal server busy&quot;</span>);<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        &#125;<br>        <span class="hljs-built_in">timer</span>(connfd, client_address);<br>    &#125;<br><br>    <span class="hljs-comment">//ET</span><br>    <span class="hljs-keyword">else</span><br>    &#123;<br>        <span class="hljs-keyword">while</span> (<span class="hljs-number">1</span>)<br>        &#123;<br>            <span class="hljs-type">int</span> connfd = <span class="hljs-built_in">accept</span>(m_listenfd, (<span class="hljs-keyword">struct</span> sockaddr *)&amp;client_address, &amp;client_addrlength);<br>            <span class="hljs-keyword">if</span> (connfd &lt; <span class="hljs-number">0</span>)<br>            &#123;<br>                <span class="hljs-built_in">LOG_ERROR</span>(<span class="hljs-string">&quot;%s:errno is:%d&quot;</span>, <span class="hljs-string">&quot;accept error&quot;</span>, errno);<br>                <span class="hljs-keyword">break</span>;<br>            &#125;<br>            <span class="hljs-keyword">if</span> (http_conn::m_user_count &gt;= MAX_FD)<br>            &#123;<br>                utils.<span class="hljs-built_in">show_error</span>(connfd, <span class="hljs-string">&quot;Internal server busy&quot;</span>);<br>                <span class="hljs-built_in">LOG_ERROR</span>(<span class="hljs-string">&quot;%s&quot;</span>, <span class="hljs-string">&quot;Internal server busy&quot;</span>);<br>                <span class="hljs-keyword">break</span>;<br>            &#125;<br>            <span class="hljs-built_in">timer</span>(connfd, client_address);<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="dealwithread-函数"><a href="#dealwithread-函数" class="headerlink" title="dealwithread 函数"></a>dealwithread 函数</h3><p>按照之前的思想，对于整个并发模式的思路，存在两个模式的切换：reactor 与 preactor（同步 io 模拟）。它们的区别是对于数据的读取者是谁，对于 reactor 是同步线程来完成，整个读就绪放在请求列表上；而对于 preactor 则是由主线程，也就是当前的 WebServer 进行一次调用，读取后将读完成放入请求队列上。同样，对于当前的 fd 我们要对他进行时间片的调整。同样的，当时间到期时，在定时器对象中，会有对应的下树操作。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">WebServer::dealwithread</span><span class="hljs-params">(<span class="hljs-type">int</span> sockfd)</span></span><br><span class="hljs-function"></span>&#123;<br>    util_timer *timer = users_timer[sockfd].timer;<br><br>    <span class="hljs-comment">//reactor</span><br>    <span class="hljs-keyword">if</span> (<span class="hljs-number">1</span> == m_actormodel)<br>    &#123;<br>        <span class="hljs-keyword">if</span> (timer)<br>        &#123;<br>            <span class="hljs-built_in">adjust_timer</span>(timer);<br>        &#125;<br><br>        <span class="hljs-comment">//若监测到读事件，将该事件放入请求队列</span><br>        m_pool-&gt;<span class="hljs-built_in">append</span>(users + sockfd, <span class="hljs-number">0</span>);<br><br>        <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>)<br>        &#123;<br>            <span class="hljs-keyword">if</span> (<span class="hljs-number">1</span> == users[sockfd].improv)<br>            &#123;<br>                <span class="hljs-keyword">if</span> (<span class="hljs-number">1</span> == users[sockfd].timer_flag)<br>                &#123;<br>                    <span class="hljs-built_in">deal_timer</span>(timer, sockfd);<br>                    users[sockfd].timer_flag = <span class="hljs-number">0</span>;<br>                &#125;<br>                users[sockfd].improv = <span class="hljs-number">0</span>;<br>                <span class="hljs-keyword">break</span>;<br>            &#125;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">else</span><br>    &#123;<br>        <span class="hljs-comment">//proactor</span><br>        <span class="hljs-keyword">if</span> (users[sockfd].<span class="hljs-built_in">read_once</span>())<br>        &#123;<br>            <span class="hljs-built_in">LOG_INFO</span>(<span class="hljs-string">&quot;deal with the client(%s)&quot;</span>, <span class="hljs-built_in">inet_ntoa</span>(users[sockfd].<span class="hljs-built_in">get_address</span>()-&gt;sin_addr));<br><br>            <span class="hljs-comment">//若监测到读事件，将该事件放入请求队列</span><br>            m_pool-&gt;<span class="hljs-built_in">append_p</span>(users + sockfd);<br><br>            <span class="hljs-keyword">if</span> (timer)<br>            &#123;<br>                <span class="hljs-built_in">adjust_timer</span>(timer);<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">else</span><br>        &#123;<br>            <span class="hljs-built_in">deal_timer</span>(timer, sockfd);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="dealwithwrite-函数"><a href="#dealwithwrite-函数" class="headerlink" title="dealwithwrite 函数"></a>dealwithwrite 函数</h3><p>逻辑与模式大致相同</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">WebServer::dealwithwrite</span><span class="hljs-params">(<span class="hljs-type">int</span> sockfd)</span></span><br><span class="hljs-function"></span>&#123;<br>    util_timer *timer = users_timer[sockfd].timer;<br>    <span class="hljs-comment">//reactor</span><br>    <span class="hljs-keyword">if</span> (<span class="hljs-number">1</span> == m_actormodel)<br>    &#123;<br>        <span class="hljs-keyword">if</span> (timer)<br>        &#123;<br>            <span class="hljs-built_in">adjust_timer</span>(timer);<br>        &#125;<br><br>        m_pool-&gt;<span class="hljs-built_in">append</span>(users + sockfd, <span class="hljs-number">1</span>);<br><br>        <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>)<br>        &#123;<br>            <span class="hljs-keyword">if</span> (<span class="hljs-number">1</span> == users[sockfd].improv)<br>            &#123;<br>                <span class="hljs-keyword">if</span> (<span class="hljs-number">1</span> == users[sockfd].timer_flag)<br>                &#123;<br>                    <span class="hljs-built_in">deal_timer</span>(timer, sockfd);<br>                    users[sockfd].timer_flag = <span class="hljs-number">0</span>;<br>                &#125;<br>                users[sockfd].improv = <span class="hljs-number">0</span>;<br>                <span class="hljs-keyword">break</span>;<br>            &#125;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">else</span><br>    &#123;<br>        <span class="hljs-comment">//proactor</span><br>        <span class="hljs-keyword">if</span> (users[sockfd].<span class="hljs-built_in">write</span>())<br>        &#123;<br>            <span class="hljs-built_in">LOG_INFO</span>(<span class="hljs-string">&quot;send data to the client(%s)&quot;</span>, <span class="hljs-built_in">inet_ntoa</span>(users[sockfd].<span class="hljs-built_in">get_address</span>()-&gt;sin_addr));<br><br>            <span class="hljs-keyword">if</span> (timer)<br>            &#123;<br>                <span class="hljs-built_in">adjust_timer</span>(timer);<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">else</span><br>        &#123;<br>            <span class="hljs-built_in">deal_timer</span>(timer, sockfd);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="dealwithsignal-函数"><a href="#dealwithsignal-函数" class="headerlink" title="dealwithsignal 函数"></a>dealwithsignal 函数</h3><p>与读写不同的是，这里的 signal 是处理函数，它不需要上队列。这里是通过管道的方式来告知 WebServer，管道由 epoll 监控。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">WebServer::dealwithsignal</span><span class="hljs-params">(<span class="hljs-type">bool</span> &amp;timeout, <span class="hljs-type">bool</span> &amp;stop_server)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span> ret = <span class="hljs-number">0</span>;<br>    <span class="hljs-type">int</span> sig;<br>    <span class="hljs-type">char</span> signals[<span class="hljs-number">1024</span>];<br>    <span class="hljs-comment">//从管道读端读出信号值，成功返回字节数，失败返回-1</span><br>    <span class="hljs-comment">//正常情况下，这里的ret返回值总是1，只有14和15两个ASCII码对应的字符</span><br>    ret = <span class="hljs-built_in">recv</span>(m_pipefd[<span class="hljs-number">0</span>], signals, <span class="hljs-built_in">sizeof</span>(signals), <span class="hljs-number">0</span>);<br>    <span class="hljs-keyword">if</span> (ret == <span class="hljs-number">-1</span>)<br>    &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (ret == <span class="hljs-number">0</span>)<br>    &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br>    <span class="hljs-keyword">else</span><br>    &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; ret; ++i)<br>        &#123;<br>            <span class="hljs-comment">//处理信号值对应的逻辑</span><br>            <span class="hljs-keyword">switch</span> (signals[i])<br>            &#123;<br>            <span class="hljs-keyword">case</span> SIGALRM:<br>            &#123;<br>                timeout = <span class="hljs-literal">true</span>;<br>                <span class="hljs-keyword">break</span>;<br>            &#125;<br>            <span class="hljs-keyword">case</span> SIGTERM:<br>            &#123;<br>                stop_server = <span class="hljs-literal">true</span>;<br>                <span class="hljs-keyword">break</span>;<br>            &#125;<br>            &#125;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="timer-函数"><a href="#timer-函数" class="headerlink" title="timer 函数"></a>timer 函数</h3><p>timer 在 accept 得到 cfd 的时候调用，这里不仅初始化了 cfd 的时间，而且也整体初始化了，即服务器完成三次握手，允许传输数据，并设置了超时时间。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">WebServer::timer</span><span class="hljs-params">(<span class="hljs-type">int</span> connfd, <span class="hljs-keyword">struct</span> sockaddr_in client_address)</span></span><br><span class="hljs-function"></span>&#123;<br>    users[connfd].<span class="hljs-built_in">init</span>(connfd, client_address, m_root, m_SQLVerify, m_CONNTrigmode, m_close_log, m_user, m_passWord, m_databaseName);<br><br>    <span class="hljs-comment">//初始化client_data数据</span><br>    <span class="hljs-comment">//创建定时器，设置回调函数和超时时间，绑定用户数据，将定时器添加到链表中</span><br>    users_timer[connfd].address = client_address;<br>    users_timer[connfd].sockfd = connfd;<br>    util_timer *timer = <span class="hljs-keyword">new</span> util_timer;<br>    timer-&gt;user_data = &amp;users_timer[connfd];<br>    timer-&gt;cb_func = cb_func;<br>    <span class="hljs-type">time_t</span> cur = <span class="hljs-built_in">time</span>(<span class="hljs-literal">NULL</span>);<br>    timer-&gt;expire = cur + <span class="hljs-number">3</span> * TIMESLOT;<br>    users_timer[connfd].timer = timer;<br>    utils.m_timer_lst.<span class="hljs-built_in">add_timer</span>(timer);<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="adjust-timer-函数"><a href="#adjust-timer-函数" class="headerlink" title="adjust_timer 函数"></a>adjust_timer 函数</h3><p>若有数据传输，则将定时器往后延迟 3 个单位，并对新的定时器在链表上的位置进行调整。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">WebServer::adjust_timer</span><span class="hljs-params">(util_timer *timer)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">time_t</span> cur = <span class="hljs-built_in">time</span>(<span class="hljs-literal">NULL</span>);<br>    timer-&gt;expire = cur + <span class="hljs-number">3</span> * TIMESLOT;<br>    utils.m_timer_lst.<span class="hljs-built_in">adjust_timer</span>(timer);<br><br>    <span class="hljs-built_in">LOG_INFO</span>(<span class="hljs-string">&quot;%s&quot;</span>, <span class="hljs-string">&quot;adjust timer once&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>webserverber</category>
      
    </categories>
    
    
    <tags>
      
      <tag>cpp</tag>
      
      <tag>linux</tag>
      
      <tag>网络编程</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>cpp 笔记</title>
    <link href="/cpp-note.html"/>
    <url>/cpp-note.html</url>
    
    <content type="html"><![CDATA[<p>刷代码随想录过程中记得笔记。</p><span id="more"></span><h3 id="常用函数"><a href="#常用函数" class="headerlink" title="常用函数"></a>常用函数</h3><ul><li><p>在<code>sort</code>中使用 lambda 表示式：<code>sort(arr.begin(), arr.end(), [](int a, int b)-&gt;bool &#123;return a &gt; b; &#125;);</code>。</p></li><li><p><code>s = s1.substr(pos, len)</code>从 pos 位置开始，长度为 len 的子串。</p></li><li><p><code>str[i] = tolower(str[i]);</code>大写字母转小写，<code>str[i] = toupper(str[i]);</code>小写字母转大写。</p></li><li><p><code>bool binary_search(arr.begin(), arrr.end(), 3)</code>返回 <strong>bool</strong>。</p></li><li><p>getline 按逗号分割字符串：</p></li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs cpp">vector&lt;string&gt; strs;<br><span class="hljs-function">stringstream <span class="hljs-title">ss</span><span class="hljs-params">(line)</span></span>;<br>string str;<br><span class="hljs-keyword">while</span> (<span class="hljs-built_in">getline</span>(ss, str, <span class="hljs-string">&#x27;,&#x27;</span>)) &#123;<br>     strs.<span class="hljs-built_in">push_back</span>(str);<br>&#125;<br></code></pre></td></tr></table></figure><ul><li><p>把 “ab” 换成 “####”：<code>str=str.replace(str.find(&quot;a&quot;),2,&quot;####&quot;);</code></p></li><li><p>有序列表中二分查找 <code>lower_bound (begin, last, val, compare)</code> 找到<mark>大于等于 val</mark>的位置，<code>upper_bound (begin, last, val, compare)</code>找到<mark>大于 val</mark>的位置。</p></li><li><p><code>uique (begin,last)</code> 左闭右开区间。</p></li><li><p><code>string.erase(pos)</code> <code>string.erase(first, last)</code>通过迭代器删除元素。</p></li><li><p><strong>remove 和 rease 搭配删除所有指定值，remove 将元素移到末尾，没有改变 size</strong>：</p></li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs cpp">vector&lt;<span class="hljs-type">int</span>&gt; vec = &#123; <span class="hljs-number">1</span>,<span class="hljs-number">1</span>,<span class="hljs-number">1</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>,<span class="hljs-number">6</span>,<span class="hljs-number">7</span>,<span class="hljs-number">8</span>&#125;;<br>vec.<span class="hljs-built_in">erase</span>(<span class="hljs-built_in">remove</span>(vec.<span class="hljs-built_in">begin</span>(), vec.<span class="hljs-built_in">end</span>(), <span class="hljs-number">1</span>), vec.<span class="hljs-built_in">end</span>());<br><span class="hljs-comment">// vec = &#123;3,4,5,6,7,8&#125;</span><br></code></pre></td></tr></table></figure><ul><li><p><code>nth_element(begin, last, nth, comp)</code>默认升序排列，找到第 nth 大的元素，移到第 nth 的位置。</p></li><li><p>利用 bitset 进行任意进制转二进制：</p></li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// stol() 第二个参数默认为 NULL，第三个默认 10 进制，可 8/16 进制</span><br><span class="hljs-function">bitset&lt;16&gt; <span class="hljs-title">bin</span><span class="hljs-params">(stol(t, <span class="hljs-literal">nullptr</span>, <span class="hljs-number">16</span>))</span></span>;   先转为 <span class="hljs-type">long</span>，通过 bitset 转为二进制 <span class="hljs-number">16</span> 位<br>string s = bin.<span class="hljs-built_in">to_string</span>();<br></code></pre></td></tr></table></figure><h3 id="ACM-模式输入输出"><a href="#ACM-模式输入输出" class="headerlink" title="ACM 模式输入输出"></a>ACM 模式输入输出</h3><ul><li><p>用 while 循环读取字符串时，输入<code>Ctrl+X</code>标志终止输入。</p></li><li><p><code>#include &lt;bits/stdc++.h&gt;</code>，万能头文件。</p></li><li><p><code>using namespace std;</code>，定义域名空间。</p></li><li><p><code>while (getchar() != &#39;\n&#39;) &#123; 判断换行符号&#125;</code>，<strong>读取一行内任意个数元素</strong>。</p></li><li><p><code>getchar()</code>，从缓冲区取一个字符，缓冲区少一个字符。</p></li></ul><h3 id="List"><a href="#List" class="headerlink" title="List"></a>List</h3><ul><li><p>list 的成员函数 remove, erase, pop_front, pop_back, clear 自动释放元素内存空间，同时元素迭代器失效。</p></li><li><p>删除某个元素，仅仅会删除元素的迭代器失效。插入、删除元素不会对其他元素造成影响。</p></li></ul><h3 id="二分法"><a href="#二分法" class="headerlink" title="二分法"></a>二分法</h3><p>注意<code>while (left &lt;= right)</code>取<strong>等号</strong>，查找值是否存在。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">search</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums, <span class="hljs-type">int</span> target)</span> </span>&#123;<br>    <span class="hljs-type">int</span> left = <span class="hljs-number">0</span>;<br>    <span class="hljs-type">int</span> right = nums.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>; <span class="hljs-comment">// 定义 target 在左闭右闭的间里，[left, right]</span><br>    <span class="hljs-keyword">while</span> (left &lt;= right) &#123; <span class="hljs-comment">// 当 left==right，区间 [left, right] 依然有效，所以用 &lt;=</span><br>        <span class="hljs-type">int</span> mid = left + ((right - left) / <span class="hljs-number">2</span>); <span class="hljs-comment">// 防止溢出 等同于 (left + right)/2</span><br>        <span class="hljs-keyword">if</span> (nums[mid] &gt; target) right = middle - <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (nums[mid] &lt; target) left = middle + <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">return</span> mid;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h3><p>注意<code>while (left &lt; right)</code>，交换左右元素，至少有<strong>两个</strong>元素，才能交换，因此不能取等号。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">partition</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums, <span class="hljs-type">int</span> left, <span class="hljs-type">int</span> right)</span> </span>&#123;<br>        <span class="hljs-type">int</span> pivot = nums[left];<br>        <span class="hljs-keyword">while</span> (left &lt; right) &#123;<br>            <span class="hljs-keyword">while</span> (left &lt; right &amp;&amp; pivot &lt;= nums[right])    right--;<br>            nums[left] = nums[right];<br>            <span class="hljs-keyword">while</span> (left &lt; right &amp;&amp; pivot &gt;= nums[left])     left++;<br>            nums[right] = nums[left];<br>        &#125;<br>        nums[left] = pivot;<br>        <span class="hljs-keyword">return</span> left;<br>    &#125;<br><span class="hljs-comment">// 递归</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">quicksort</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums, <span class="hljs-type">int</span> left, <span class="hljs-type">int</span> right)</span> </span>&#123;<br>    <span class="hljs-type">int</span> pivot;<br>    <span class="hljs-keyword">if</span> (left &lt; right) &#123;<br>        pivot = <span class="hljs-built_in">partition</span>(nums, left, right);<br>        <span class="hljs-built_in">quicksort</span>(nums, left, pivot - <span class="hljs-number">1</span>);<br>        <span class="hljs-built_in">quicksort</span>(nums, pivot + <span class="hljs-number">1</span>, right);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>有重复元素时多加 ‘&#x3D;‘ ，<strong>多加不会出错</strong>。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">while</span> (left &lt; right &amp;&amp; pivot &lt;= nums[right])    right--;<br><span class="hljs-keyword">while</span> (left &lt; right &amp;&amp; pivot &gt;= nums[left])     left++;<br></code></pre></td></tr></table></figure><h3 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h3><ul><li><p><code>for (int i = 0; i &lt;= arr.size() - k; i += k)</code>，每次遍历 k 个元素，注意 <code>i&lt;=arr.size()-k</code>。</p></li><li><p><code>priority_queue&lt;int,vector&lt;int&gt;，less&lt;int&gt;&gt;</code>，第二个参数是存储容器，第三个是比较函数，默认<code>less&lt;int&gt;</code>大顶堆，自顶向下变小，<code>greater&lt;int&gt;</code>小顶堆，自顶向下变大。</p></li><li><p>求数组中三数之和（固定第一个，再用双指针），四数之和，<strong>先排序</strong>，方便后面剪枝。</p></li></ul><h3 id="链表"><a href="#链表" class="headerlink" title="链表"></a>链表</h3><ul><li>自定义链表结构：</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">ListNode</span> &#123;<br>    <span class="hljs-type">int</span> val;<br>    ListNode* next;<br>    <span class="hljs-built_in">ListNode</span>(<span class="hljs-type">int</span> val):<span class="hljs-built_in">val</span>(val), <span class="hljs-built_in">next</span>(<span class="hljs-literal">nullptr</span>)&#123;&#125;<br>&#125;;<br>ListNode* node = <span class="hljs-keyword">new</span> <span class="hljs-built_in">ListNode</span>(val);<br><br><span class="hljs-comment">//使用虚拟头节点</span><br>ListNode* dummyHead = <span class="hljs-keyword">new</span> <span class="hljs-built_in">ListNode</span>(<span class="hljs-number">0</span>);<br>dummyHead-&gt;next = head;<br>ListNode* cur = dummyHead;<br></code></pre></td></tr></table></figure><ul><li>定义指针数组（哈希）：</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs cpp">vector&lt;ListNode*&gt; vec;<br>ListNode* cur=head;<br><span class="hljs-keyword">while</span>(cur)&#123;<br>    vec.<span class="hljs-built_in">push_back</span>(cur);<br>    cur=cur-&gt;next;<br>&#125;<br></code></pre></td></tr></table></figure><p>应用：对链表每 K 个结点翻转，定义一个指针数组，对数组翻转，变相对链表操作。</p><h3 id="String"><a href="#String" class="headerlink" title="String"></a>String</h3><ul><li>双指针法判断<strong>回文</strong>：</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">countSubstrings</span><span class="hljs-params">(string s)</span> </span>&#123;<br>    <span class="hljs-type">int</span> result = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; s.<span class="hljs-built_in">size</span>(); i++) &#123;<br>        result += <span class="hljs-built_in">extend</span>(s, i, i); <span class="hljs-comment">// 以 i 为中心</span><br>        result += <span class="hljs-built_in">extend</span>(s, i, i + <span class="hljs-number">1</span>); <span class="hljs-comment">// 以 i 和 i+1 为中心</span><br>    &#125;<br>    <span class="hljs-keyword">return</span> result;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">extend</span><span class="hljs-params">(<span class="hljs-type">const</span> string&amp; s, <span class="hljs-type">int</span> i, <span class="hljs-type">int</span> j)</span> </span>&#123;<br>    <span class="hljs-type">int</span> res = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">while</span> (i &gt;= <span class="hljs-number">0</span> &amp;&amp; j &lt; s.<span class="hljs-built_in">size</span>() &amp;&amp; s[i] == s[j]) &#123;<br>        i--;<br>        j++;<br>        res++;<br>    &#125;<br>    <span class="hljs-keyword">return</span> res;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li><p><code>if(str.find(&quot;a&quot;) != -1)</code>返回结果是 <strong>-1</strong> 不是 end()。</p></li><li><p><code>s.substr(start,len)</code>，从 start 位置取长度为 len 的子串。</p></li><li><p>查找字符串 S 是否包含子串 sub，S+S 拼接破环头尾，判断<code>S.find(sub)</code>存在。</p></li><li><p><strong>stoll</strong>：string 型变量转换为 long long 型变量（常用），兼容 int long；<br><strong>stod</strong>：string 型变量转换为 double 型变量（常用），兼容 float。</p></li></ul><h3 id="优先队列（堆）"><a href="#优先队列（堆）" class="headerlink" title="优先队列（堆）"></a>优先队列（堆）</h3><ul><li><code>priority_queue&lt;int, vector&lt;int&gt;, cmp&gt; p_queue</code>默认底层容器 vector，默认大顶堆 less。</li><li>自定义比较函数 class：</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">cmp</span>&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">operator</span><span class="hljs-params">()</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp;a,vector&lt;<span class="hljs-type">int</span>&gt;&amp;b)</span></span>&#123;<br>        <span class="hljs-keyword">return</span> a[<span class="hljs-number">0</span>]&gt;b[<span class="hljs-number">0</span>];   小顶堆<br>    &#125;<br>&#125;;<br>priority_queue&lt;vector&lt;<span class="hljs-type">int</span>&gt;,vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt;,cmp&gt; q;<br></code></pre></td></tr></table></figure><ul><li>自定义比较结构体 struct:</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">cmp</span> &#123;<br>     <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">operator</span><span class="hljs-params">()</span><span class="hljs-params">(pair&lt;<span class="hljs-type">int</span>,<span class="hljs-type">int</span>&gt;&amp; a,pair&lt;<span class="hljs-type">int</span>,<span class="hljs-type">int</span>&gt;&amp; b)</span></span>&#123;<br>         <span class="hljs-keyword">return</span> a.second &gt; b.second;<br>    &#125;<br>&#125;;<br>priority_queue&lt;pair&lt;<span class="hljs-type">int</span>,<span class="hljs-type">int</span>&gt;, vector&lt;pair&lt;<span class="hljs-type">int</span>,<span class="hljs-type">int</span>&gt;&gt;, cmp&gt; q;<br></code></pre></td></tr></table></figure><ul><li>两种自定义比较函数，小顶堆，注意符号（默认大顶堆），第二个参数设置底层容器，必填，否则第三个参数不起作用。</li></ul><h3 id="二叉树"><a href="#二叉树" class="headerlink" title="二叉树"></a>二叉树</h3><ul><li>数据结构模板：</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">TreeNode</span> &#123;<br>    <span class="hljs-type">int</span> val;<br>    TreeNode *left;<br>    TreeNode *right;<br>    <span class="hljs-built_in">TreeNode</span>(<span class="hljs-type">int</span> x) : <span class="hljs-built_in">val</span>(x), <span class="hljs-built_in">left</span>(<span class="hljs-literal">nullptr</span>), <span class="hljs-built_in">right</span>(<span class="hljs-literal">nullptr</span>) &#123;&#125;<br>&#125;;<br></code></pre></td></tr></table></figure><ul><li>二叉树递归参数传值 val，切忌不要用引用 &amp;val，不能改变 val 值，<strong>方便回溯</strong>。</li><li>递归遍历函数是否需要返回值？<ul><li>若只要找到一条路径，不用全部遍历，则要返回值 bool。</li><li>若找到所有满足条件路径，要求全部遍历，则不需要返回值。</li></ul></li><li>递归返回<code>TreeNode*</code>，可以<code>return nullptr</code>。</li><li><strong>删除</strong>二叉树节点，<strong>增加</strong>二叉树节点，都是用<strong>递归函数的返回值</strong>来完成。</li><li>根据有序数组创建<strong>二叉搜索树</strong>，同时也是平衡树：</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function">TreeNode* <span class="hljs-title">createTree</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; vec,<span class="hljs-type">int</span> left,<span class="hljs-type">int</span> right)</span></span>&#123;<br>    <span class="hljs-keyword">if</span>(left &gt; right) <span class="hljs-keyword">return</span> <span class="hljs-literal">nullptr</span>;<br>    <span class="hljs-type">int</span> mid = (left+right)/<span class="hljs-number">2</span>;<br>    TreeNode* node = <span class="hljs-keyword">new</span> <span class="hljs-built_in">TreeNode</span>(vec[mid]);<br>    node-&gt;left = <span class="hljs-built_in">createTree</span>(vec,left,mid<span class="hljs-number">-1</span>);<br>    node-&gt;right = <span class="hljs-built_in">createTree</span>(vec,mid+<span class="hljs-number">1</span>,right);<br>    <span class="hljs-keyword">return</span> node;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>求公共最近公共邻居 leetcode.236：</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">TreeNode* <span class="hljs-title">lowestCommonAncestor</span><span class="hljs-params">(TreeNode* root, TreeNode* p, TreeNode* q)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (root == q || root == p || root == <span class="hljs-literal">NULL</span>) <span class="hljs-keyword">return</span> root;<br>        TreeNode* left = <span class="hljs-built_in">lowestCommonAncestor</span>(root-&gt;left, p, q);<br>        TreeNode* right = <span class="hljs-built_in">lowestCommonAncestor</span>(root-&gt;right, p, q);<br>        <span class="hljs-keyword">if</span> (left != <span class="hljs-literal">NULL</span> &amp;&amp; right != <span class="hljs-literal">NULL</span>) <span class="hljs-keyword">return</span> root;<br><br>        <span class="hljs-keyword">if</span> (left == <span class="hljs-literal">NULL</span> &amp;&amp; right != <span class="hljs-literal">NULL</span>) <span class="hljs-keyword">return</span> right;<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (left != <span class="hljs-literal">NULL</span> &amp;&amp; right == <span class="hljs-literal">NULL</span>) <span class="hljs-keyword">return</span> left;<br>        <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;<br>        &#125;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><ul><li><p>考虑设置 全局变量<code>public: TreeNode* pre</code>递归过程更新全局指针变量。</p></li><li><p><strong>递归一定看函数返回什么，指针？整数？，利用起来<code>root-&gt;left = deleteNode(root-&gt;left,key);</code>。</strong></p></li></ul><h3 id="回溯法"><a href="#回溯法" class="headerlink" title="回溯法"></a>回溯法</h3><ul><li><p><strong>关键词：返回所有可能方案。</strong></p></li><li><p><strong>回溯是递归的副产品，只要有递归就会有回溯。</strong></p></li><li><p>回溯法就是暴力搜索，并不是什么高效的算法，最多在剪枝一下（解决多层 for 循环）。</p></li><li><p>通用模板：</p></li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-type">void</span> backtracking（参数） &#123;<br>    <span class="hljs-keyword">if</span> （终止条件） &#123;<br>        存放结果；<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br>    <span class="hljs-keyword">for</span> （选择：本层集合中元素（树中节点孩子的数量就是集合的大小）) &#123;<br>        处理节点；<br>        backtracking（路径，选择列表）; <span class="hljs-comment">// 递归</span><br>        回溯，撤销处理结果！!!<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>在终止条件前加入剪枝，即进入递归后提前<code>return</code>：</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">private</span>:<br>    vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; result; <span class="hljs-comment">// 存放符合条件结果的集合</span><br>    vector&lt;<span class="hljs-type">int</span>&gt; path; <span class="hljs-comment">// 用来存放符合条件结果</span><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">backtracking</span><span class="hljs-params">(<span class="hljs-type">int</span> n, <span class="hljs-type">int</span> k, <span class="hljs-type">int</span> startIndex)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (path.<span class="hljs-built_in">size</span>() == k) &#123;<br>            result.<span class="hljs-built_in">push_back</span>(path);<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = startIndex; i &lt;= n; i++) &#123;<br>            path.<span class="hljs-built_in">push_back</span>(i); <span class="hljs-comment">// 处理节点</span><br>            <span class="hljs-built_in">backtracking</span>(n, k, i + <span class="hljs-number">1</span>);   <span class="hljs-comment">//注意 传 i+1, 不是 startIndex</span><br>            path.<span class="hljs-built_in">pop_back</span>(); <span class="hljs-comment">// 回溯，撤销处理的节点</span><br>        &#125;<br>    &#125;<br><span class="hljs-keyword">public</span>:<br>    vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">combine</span>(<span class="hljs-type">int</span> n, <span class="hljs-type">int</span> k) &#123;<br>        result.<span class="hljs-built_in">clear</span>();<br>        path.<span class="hljs-built_in">clear</span>();<br>        <span class="hljs-built_in">backtracking</span>(n, k, <span class="hljs-number">1</span>);<br>        <span class="hljs-keyword">return</span> result;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><ul><li><p>经典组合题，注意<code>backtracking(n, k, i + 1)</code>; 传 <strong>i+1</strong>, 回溯部分<code>path.pop_back()</code>以及相应处理。</p></li><li><p>善用<code>used[]</code>，标记已访问的元素。</p></li><li><p>全组合用<code>startIndex</code>（无顺序且组合不能重复）;</p><p>全排列<strong>不需要</strong><code>startIndex</code>，而是用<code>used[ ]</code>（有顺序且同一元素不能重复选取）。</p></li><li><p><strong>对于结果有重复子集，需去重，则先排序，通过判断相邻结点是否重复使用过。</strong></p></li><li><p><code>if (i &gt; 0 &amp;&amp; nums[i] == nums[i - 1] &amp;&amp; used[i - 1] == false) continue;</code>, 先排序，对于{1, 1, 2}, <code>used[0]=false</code>表示同一数层上 n[0] 已被用过，而 n[0]&#x3D;&#x3D;n[1]，所以跳过；对于<code>used[0]=true</code>，表示 n[0] 在<strong>上一层</strong>，同一条树枝上，不在同一层，可重复使用。</p></li><li><p>经典排列题，含去重：</p></li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">private</span>:<br>    vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; result;<br>    vector&lt;<span class="hljs-type">int</span>&gt; path;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">backtracking</span> <span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums, vector&lt;<span class="hljs-type">bool</span>&gt;&amp; used)</span> </span>&#123;<br>        <span class="hljs-comment">// 此时说明找到了一组</span><br>        <span class="hljs-keyword">if</span> (path.<span class="hljs-built_in">size</span>() == nums.<span class="hljs-built_in">size</span>()) &#123;<br>            result.<span class="hljs-built_in">push_back</span>(path);<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; nums.<span class="hljs-built_in">size</span>(); i++) &#123;<br>            <span class="hljs-comment">// used[i - 1] == true，说明同一树枝 nums[i - 1] 使用过</span><br>            <span class="hljs-comment">// used[i - 1] == false，说明同一树层 nums[i - 1] 使用过</span><br>            <span class="hljs-comment">// 如果同一树层 nums[i - 1] 使用过则直接跳过</span><br>            <span class="hljs-keyword">if</span> (i &gt; <span class="hljs-number">0</span> &amp;&amp; nums[i] == nums[i - <span class="hljs-number">1</span>] &amp;&amp; used[i - <span class="hljs-number">1</span>] == <span class="hljs-literal">false</span>) &#123;<br>                <span class="hljs-keyword">continue</span>;<br>            &#125;<br>            <span class="hljs-comment">//if ( used[i] == true ) continue;</span><br>            <span class="hljs-keyword">if</span> (used[i] == <span class="hljs-literal">false</span>) &#123;<br>                used[i] = <span class="hljs-literal">true</span>;<br>                path.<span class="hljs-built_in">push_back</span>(nums[i]);<br>                <span class="hljs-built_in">backtracking</span>(nums, used);<br>                path.<span class="hljs-built_in">pop_back</span>();<br>                used[i] = <span class="hljs-literal">false</span>;<br>            &#125;<br>        &#125;<br>    &#125;<br><span class="hljs-keyword">public</span>:<br>    vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">permuteUnique</span>(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums) &#123;<br>        result.<span class="hljs-built_in">clear</span>();<br>        path.<span class="hljs-built_in">clear</span>();<br>        <span class="hljs-built_in">sort</span>(nums.<span class="hljs-built_in">begin</span>(), nums.<span class="hljs-built_in">end</span>()); <span class="hljs-comment">// 排序</span><br>        <span class="hljs-function">vector&lt;<span class="hljs-type">bool</span>&gt; <span class="hljs-title">used</span><span class="hljs-params">(nums.size(), <span class="hljs-literal">false</span>)</span></span>;<br>        <span class="hljs-built_in">backtracking</span>(nums, used);<br>        <span class="hljs-keyword">return</span> result;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><ul><li><p><code>if (used[i] == false) &#123; ... &#125;</code>，记住前提条件，<strong>上一层已选过，就不考虑啦</strong>，或者改为<code>if (used[i] == true) continue;</code>。</p></li><li><p>递归和回溯：<br>1）要遍历所有元素找全部结果，函数 void 无返回值。<br>2）只要找到一条路径&#x2F;结果，函数有返回值 bool（同二叉树）。</p></li></ul><h3 id="贪心算法"><a href="#贪心算法" class="headerlink" title="贪心算法"></a>贪心算法</h3><ul><li><p>贪心的本质是选择每一阶段的局部最优，从而达到全局最优。</p></li><li><p><strong>提前排序给定数组！降低难度！</strong></p></li><li><p>加关键词 static 才能在 sort 使用 cmp 函数，sort 要求 cmp 函数为 static，或者声明类外作为全局函数。</p></li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">static</span> <span class="hljs-type">bool</span> <span class="hljs-title">cmp</span><span class="hljs-params">(<span class="hljs-type">int</span> a,<span class="hljs-type">int</span> b)</span></span>&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">abs</span>(a) &gt; <span class="hljs-built_in">abs</span>(b);<br>&#125;<br><span class="hljs-built_in">sort</span>(nums.<span class="hljs-built_in">begin</span>(),nums.<span class="hljs-built_in">end</span>(),cmp);<br></code></pre></td></tr></table></figure><ul><li><strong>左右排序两次问题，区间问题，或数组中当前元素与左右元素比较时</strong>，先顺序遍历，在逆序遍历，两次遍历不能同时兼顾左右（lc.135），换句话说，遇到两个维度权衡的时候，一定要先确定一个维度，再确定另一个维度。</li></ul><h3 id="动态规划"><a href="#动态规划" class="headerlink" title="动态规划"></a>动态规划</h3><blockquote><ol><li><p>确定 dp 数组以及下标的含义</p></li><li><p>确定递推公式</p></li><li><p>dp 数组如何初始化</p></li><li><p>确定遍历顺序</p></li><li><p>举例推导 dp 数组</p></li></ol></blockquote><p><strong>debug 最好方式就是把 dp 数组打印出来，看看究竟是不是按照自己思路推导的！</strong></p><p>dp 初始化后，遍历数组考虑初始值，避免越界。</p><h3 id="经典01背包问题"><a href="#经典01背包问题" class="headerlink" title="经典01背包问题"></a>经典01背包问题</h3><ul><li><p>每个物品只能放入一次。</p></li><li><p>外层遍历物品，<strong>内层遍历容量</strong>。</p></li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// 二维数组</span><br>vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">dp</span>(weight.<span class="hljs-built_in">size</span>(), <span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">int</span>&gt;(bagweight + <span class="hljs-number">1</span>, <span class="hljs-number">0</span>));<br><span class="hljs-comment">// 初始化</span><br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = weight[<span class="hljs-number">0</span>]; j &lt;= bagweight; j++) &#123;<br>    dp[<span class="hljs-number">0</span>][j] = value[<span class="hljs-number">0</span>];<br>&#125;<br><span class="hljs-comment">// weight 数组的大小 就是物品个数</span><br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt; weight.<span class="hljs-built_in">size</span>(); i++) &#123; <span class="hljs-comment">// 遍历物品</span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt;= bagweight; j++) &#123; <span class="hljs-comment">// 遍历背包容量</span><br>        放不下 i 重量<br>        <span class="hljs-keyword">if</span> (j &lt; weight[i]) dp[i][j] = dp[i - <span class="hljs-number">1</span>][j];<br>        <span class="hljs-keyword">else</span> dp[i][j] = <span class="hljs-built_in">max</span>(dp[i - <span class="hljs-number">1</span>][j], dp[i - <span class="hljs-number">1</span>][j - weight[i]] + value[i]);<br>    &#125;<br>&#125;<br>cout &lt;&lt; dp[weight.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>][bagweight] &lt;&lt; endl;<br></code></pre></td></tr></table></figure><ul><li><strong>滚动数组</strong>：降低空间复杂度。先正序遍历物品，在倒序遍历背包容量，dp[j] 表示：容量维 j 的背包，所背的物品价值最大为 dp[j]，<strong>倒序遍历是为了保证物品 i 只被放入一次！</strong></li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// 初始化</span><br><span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">dp</span><span class="hljs-params">(bagWeight + <span class="hljs-number">1</span>, <span class="hljs-number">0</span>)</span></span>;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; weight.<span class="hljs-built_in">size</span>(); i++) &#123; <span class="hljs-comment">// 遍历物品</span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = bagWeight; j &gt;= weight[i]; j--) &#123; <span class="hljs-comment">// 遍历背包容量</span><br>        dp[j] = <span class="hljs-built_in">max</span>(dp[j], dp[j - weight[i]] + value[i]);<br>    &#125;<br>&#125;<br>cout &lt;&lt; dp[bagWeight] &lt;&lt; endl;<br></code></pre></td></tr></table></figure><ul><li><p><code>dp[i]</code>表示不放物体，相当于<code>dp[i-1][j]</code>，不放物体 i，<code>dp[j - weight[i]] + value[i]</code>表示放物体 i，为放物体前容量的最大价值 + 物体 i 的价值。</p></li><li><p>为什么第二次循环<code>j&gt;=weight[i]</code>，因为<code>dp[j - weight[i]]</code>表示放物体前的容量，不能为负数，考虑能放下的情况，放还是不放；对于不能放下就默认等于上一次值，不考虑。</p></li><li><p>注意第二重<strong>循环 j 初始值</strong>，为 dp 容量最大值。</p></li></ul><h3 id="完全背包问题"><a href="#完全背包问题" class="headerlink" title="完全背包问题"></a>完全背包问题</h3><ul><li>每件物品无限件，可重复放入背包。</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// 先遍历物品，再遍历背包</span><br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; weight.<span class="hljs-built_in">size</span>(); i++) &#123; <span class="hljs-comment">// 遍历物品</span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = weight[i]; j &lt;= bagWeight ; j++) &#123; <span class="hljs-comment">// 遍历背包容量</span><br>        dp[j] = <span class="hljs-built_in">max</span>(dp[j], dp[j - weight[i]] + value[i]);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li><p><strong>内循环 从小到大遍历，因为每件物品添加多次</strong>。</p></li><li><p><strong>理解 内循环 dp[j]：每次容量为 j 的时候，所以后面内容都是考虑当前容量为 j</strong>。</p></li><li><p><strong>如果求<mark>组合数</mark>就是外层 for 循环遍历物品，内层 for 遍历背包</strong>。</p><p><strong>如果求<mark>排列数</mark>就是外层 for 遍历背包，内层 for 循环遍历物品</strong>。</p></li><li><p>滚动数组为了取代二维数组，但<strong>内循环一般是倒序</strong>的，防止重复选取。</p></li></ul><h3 id="求连续公共子序列"><a href="#求连续公共子序列" class="headerlink" title="求连续公共子序列"></a>求连续公共子序列</h3><ul><li><p><code>dp[i][j]</code>：以下标 <strong>i-1</strong> 为结尾的 A，和以下标 <strong>j-1</strong> 为结尾的 B，最长重复子数组<strong>长度</strong>为<code>dp[i][j]</code>。</p></li><li><p>求<strong>连续</strong>最长重复子数组：</p></li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">findLength</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums1, vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums2)</span> </span>&#123;<br>        vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">dp</span>(nums1.<span class="hljs-built_in">size</span>()+<span class="hljs-number">1</span>,<span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">int</span>&gt;(nums2.<span class="hljs-built_in">size</span>()+<span class="hljs-number">1</span>,<span class="hljs-number">0</span>));<br>        <span class="hljs-type">int</span> res = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i &lt;=nums1.<span class="hljs-built_in">size</span>();i++)&#123;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">1</span>;j&lt;=nums2.<span class="hljs-built_in">size</span>();j++)&#123;<br>                <span class="hljs-keyword">if</span>(nums1[i<span class="hljs-number">-1</span>] == nums2[j<span class="hljs-number">-1</span>])&#123;<br>                    dp[i][j] = dp[i<span class="hljs-number">-1</span>][j<span class="hljs-number">-1</span>]+<span class="hljs-number">1</span>;<br>                &#125;<br>                <span class="hljs-keyword">if</span>(dp[i][j] &gt; res) res = dp[i][j];<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><ul><li>求<strong>不连续</strong>公共子数组：</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">longestCommonSubsequence</span><span class="hljs-params">(string text1, string text2)</span> </span>&#123;<br>        vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">dp</span>(text1.<span class="hljs-built_in">size</span>()+<span class="hljs-number">1</span>,<span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">int</span>&gt;(text2.<span class="hljs-built_in">size</span>()+<span class="hljs-number">1</span>,<span class="hljs-number">0</span>));<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=text1.<span class="hljs-built_in">size</span>();i++)&#123;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">1</span>;j&lt;=text2.<span class="hljs-built_in">size</span>();j++)&#123;<br>                <span class="hljs-keyword">if</span>(text1[i<span class="hljs-number">-1</span>] == text2[j<span class="hljs-number">-1</span>])&#123;<br>                    dp[i][j] = dp[i<span class="hljs-number">-1</span>][j<span class="hljs-number">-1</span>] + <span class="hljs-number">1</span>;<br>                &#125;<span class="hljs-keyword">else</span>&#123;<br>                    dp[i][j] = <span class="hljs-built_in">max</span>(dp[i<span class="hljs-number">-1</span>][j],dp[i][j<span class="hljs-number">-1</span>]);<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> dp[text1.<span class="hljs-built_in">size</span>()][text2.<span class="hljs-built_in">size</span>()];<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><ul><li>思考<code>d[i][j]</code>是一个数，表示什么意思？公共长度？最多重复数量？最少删除次数？视情况而定。</li></ul><h3 id="单调栈"><a href="#单调栈" class="headerlink" title="单调栈"></a>单调栈</h3><ul><li><p><strong>要寻找任一个元素的右边或者左边第一个比自己大或者小的元素的位置。</strong></p></li><li><p>栈里只存递增或递减的 index，遇到逆序就弹出栈内元素，从而得到第一个大于或小于元素的 index。</p></li><li><p>设置两个数组，顺序和逆序遍历，得到左边&#x2F;右边最大数字：</p></li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// 记录每个柱子左边柱子最大高度</span><br>maxLeft[<span class="hljs-number">0</span>] = height[<span class="hljs-number">0</span>];<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt; size; i++) &#123;<br>    maxLeft[i] = <span class="hljs-built_in">max</span>(height[i], maxLeft[i - <span class="hljs-number">1</span>]);<br>&#125;<br><span class="hljs-comment">// 记录每个柱子右边柱子最大高度</span><br>maxRight[size - <span class="hljs-number">1</span>] = height[size - <span class="hljs-number">1</span>];<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = size - <span class="hljs-number">2</span>; i &gt;= <span class="hljs-number">0</span>; i--) &#123;<br>    maxRight[i] = <span class="hljs-built_in">max</span>(height[i], maxRight[i + <span class="hljs-number">1</span>]);<br>&#125;<br></code></pre></td></tr></table></figure><p>待续……</p><p><img src="https://cdn.jsdelivr.net/gh/gejoyy/Pictures@main/wallhaven-p9oml3_1280x720.png" alt="欣赏个美图吧"></p>]]></content>
    
    
    <categories>
      
      <category>刷题笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>cpp</tag>
      
      <tag>note</tag>
      
      <tag>algorithm</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Hello World</title>
    <link href="/hello-world.html"/>
    <url>/hello-world.html</url>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><span id="more"></span><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo new <span class="hljs-string">&quot;My New Post&quot;</span><br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo server<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo generate<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo deploy<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
    
    
    
  </entry>
  
  
  
  
</search>
