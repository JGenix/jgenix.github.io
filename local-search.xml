<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>算法笔记</title>
    <link href="/cpp%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0.html"/>
    <url>/cpp%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0.html</url>
    
    <content type="html"><![CDATA[<h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><ul><li><strong>逆向思考，由 y-&gt;x,遍历所有满足条件的结果 y 值，找到最小&#x2F;大 y！</strong></li></ul><h3 id="易错"><a href="#易错" class="headerlink" title="易错"></a>易错</h3><ul><li>声明类型并初始化！！！</li><li>输出整数答案尽量用 long 存；</li><li>ascii 码顺序 0-9,A-Z,a-z(非连续)</li></ul><h3 id="输入输出"><a href="#输入输出" class="headerlink" title="输入输出"></a>输入输出</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">//////////////////////// 输入 ///////////////////////////</span><br><span class="hljs-comment">// 先给元素个数，再给元素</span><br>cin &gt;&gt; n;<br><span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">arr</span><span class="hljs-params">(n)</span></span>;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; ++i)&#123; cin &gt;&gt; arr[i]; &#125;<br><br><span class="hljs-comment">// 多个输入，读到文件结束符EOF为止</span><br><span class="hljs-keyword">while</span>(cin &gt;&gt; x)&#123; arr.<span class="hljs-built_in">emplace_back</span>(x); &#125;<br><br><span class="hljs-comment">// 输入非固定数目的整型数字</span><br><span class="hljs-keyword">while</span>(cin&gt;&gt;num)&#123;<br>    nums.<span class="hljs-built_in">push_back</span>(num);<br>    <span class="hljs-keyword">if</span>(<span class="hljs-built_in">getchar</span>() == <span class="hljs-string">&#x27;\n&#x27;</span>)<br>        <span class="hljs-keyword">break</span>;<br>&#125;<br><br><span class="hljs-comment">// 给定一行字符串，每个字符串用逗号间隔</span><br>string input;<br>cin &gt;&gt; input;<br><span class="hljs-function">stringstream <span class="hljs-title">ss</span><span class="hljs-params">(input)</span></span>;<br>string str;<br><span class="hljs-keyword">while</span>(<span class="hljs-built_in">getline</span>(ss, str,<span class="hljs-string">&#x27;,&#x27;</span>))&#123;<br>    strs.<span class="hljs-built_in">push_back</span>(str);<br>&#125;<br><br><span class="hljs-comment">//////////////////////// 输出 ///////////////////////////</span><br><span class="hljs-comment">// 保留x位小数</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iomanip&gt;</span></span><br><span class="hljs-type">float</span> a;<br>cout &lt;&lt; fixed &lt;&lt; <span class="hljs-built_in">setprecision</span>(<span class="hljs-number">3</span>) &lt;&lt; a &lt;&lt;endl;<br><br><span class="hljs-comment">// c的格式化输出</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span>  <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;面积 = %.2f\n&quot;</span>, <span class="hljs-number">88.24733734</span>); <span class="hljs-comment">//输出：面积 = 88.25</span><br><br><span class="hljs-comment">// 固定输出n位数，左侧补零</span><br>c = <span class="hljs-number">12</span>;<br>cout &lt;&lt; <span class="hljs-built_in">setw</span>(<span class="hljs-number">4</span>) &lt;&lt; <span class="hljs-built_in">setfill</span>(<span class="hljs-string">&#x27;0&#x27;</span>) &lt;&lt; c &lt;&lt; endl; <span class="hljs-comment">// 0012</span><br></code></pre></td></tr></table></figure><h3 id="双指针法"><a href="#双指针法" class="headerlink" title="双指针法"></a>双指针法</h3><p>时间复杂度：O(n)，空间复杂度：O(1)，不改变元素相对位置</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// 移除数组中所有数值等于 val 的元素</span><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">removeElement</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums, <span class="hljs-type">int</span> val)</span> </span>&#123;<br>        <span class="hljs-type">int</span> slowIndex = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> fastIndex = <span class="hljs-number">0</span>; fastIndex &lt; nums.<span class="hljs-built_in">size</span>(); fastIndex++) &#123;<br>            <span class="hljs-keyword">if</span> (val != nums[fastIndex]) &#123;<br>                nums[slowIndex++] = nums[fastIndex];<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> slowIndex;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="滑动窗口"><a href="#滑动窗口" class="headerlink" title="滑动窗口"></a>滑动窗口</h3><p>滑动窗口的精妙之处在于根据当前子序列和大小的情况，不断调节子序列的起始位置。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// 长度最小的子数组：给定一个含有 n 个正整数的数组和一个正整数 s ，找出该数组中满足其和 ≥ s 的长度最小的 连续 子数组，并返回其长度。如果不存在符合条件的子数组，返回 0</span><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">minSubArrayLen</span><span class="hljs-params">(<span class="hljs-type">int</span> s, vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums)</span> </span>&#123;<br>        <span class="hljs-type">int</span> result = INT32_MAX;<br>        <span class="hljs-type">int</span> sum = <span class="hljs-number">0</span>; <span class="hljs-comment">// 滑动窗口数值之和</span><br>        <span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; <span class="hljs-comment">// 滑动窗口起始位置</span><br>        <span class="hljs-type">int</span> subLength = <span class="hljs-number">0</span>; <span class="hljs-comment">// 滑动窗口的长度</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; nums.<span class="hljs-built_in">size</span>(); j++) &#123;<br>            sum += nums[j];<br>            <span class="hljs-comment">// 注意这里使用while，每次更新 i（起始位置），并不断比较子序列是否符合条件</span><br>            <span class="hljs-keyword">while</span> (sum &gt;= s) &#123;<br>                subLength = (j - i + <span class="hljs-number">1</span>); <span class="hljs-comment">// 取子序列的长度</span><br>                result = result &lt; subLength ? result : subLength;<br>                sum -= nums[i++]; <span class="hljs-comment">// 这里体现出滑动窗口的精髓之处，不断变更i（子序列的起始位置）</span><br>            &#125;<br>        &#125;<br>        <span class="hljs-comment">// 如果result没有被赋值的话，就返回0，说明没有符合条件的子序列</span><br>        <span class="hljs-keyword">return</span> result == INT32_MAX ? <span class="hljs-number">0</span> : result;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="二分查找"><a href="#二分查找" class="headerlink" title="二分查找"></a>二分查找</h3><p>注意<code>while (left &lt;= right)</code>取 <strong>等号</strong>，查找值是否存在。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">binary_search</span><span class="hljs-params">(vec.begin(), vec.end(), val)</span></span>; <span class="hljs-comment">// 前提有序</span><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">search</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums, <span class="hljs-type">int</span> target)</span> </span>&#123;<br>    <span class="hljs-type">int</span> left = <span class="hljs-number">0</span>;<br>    <span class="hljs-type">int</span> right = nums.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>;<br>    <span class="hljs-comment">// 当 left==right，区间 [left, right] 依然有效，所以用 &lt;=</span><br>    <span class="hljs-keyword">while</span> (left &lt;= right) &#123;<br>        <span class="hljs-type">int</span> mid = left + ((right - left) / <span class="hljs-number">2</span>); <span class="hljs-comment">// 防止溢出</span><br>        <span class="hljs-keyword">if</span> (nums[mid] &gt; target)<br>            right = middle - <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (nums[mid] &lt; target)<br>            left = middle + <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">else</span><br>            <span class="hljs-keyword">return</span> mid;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h3><p>注意<code>while (left &lt; right)</code>，交换左右元素，至少有 <strong>两个</strong> 元素，才能交换，因此不能取等号。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">partition</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt; &amp;nums, <span class="hljs-type">int</span> left, <span class="hljs-type">int</span> right)</span> </span>&#123;<br>    <span class="hljs-type">int</span> pivot = nums[left];<br>    <span class="hljs-keyword">while</span> (left &lt; right) &#123;<br>        <span class="hljs-comment">// 有重复元素时多加 ‘=‘ ，多加不会出错</span><br>        <span class="hljs-keyword">while</span> (left &lt; right &amp;&amp; pivot &lt;= nums[right]) right--;<br>        nums[left] = nums[right];<br>        <span class="hljs-comment">// 有重复元素时多加 ‘=‘ ，多加不会出错</span><br>        <span class="hljs-keyword">while</span> (left &lt; right &amp;&amp; pivot &gt;= nums[left]) left++;<br>        nums[right] = nums[left];<br>    &#125;<br>    nums[left] = pivot;<br>    <span class="hljs-keyword">return</span> left;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">quicksort</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt; &amp;nums, <span class="hljs-type">int</span> left, <span class="hljs-type">int</span> right)</span> </span>&#123;<br>    <span class="hljs-type">int</span> pivot;<br>    <span class="hljs-comment">// 注意这里是 if</span><br>    <span class="hljs-keyword">if</span> (left &lt; right) &#123;<br>        pivot = <span class="hljs-built_in">partition</span>(nums, left, right);<br>        <span class="hljs-built_in">quicksort</span>(nums, left, pivot - <span class="hljs-number">1</span>);<br>        <span class="hljs-built_in">quicksort</span>(nums, pivot + <span class="hljs-number">1</span>, right);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>查找第 k 大的数</strong></p><ol><li><p>冒泡&#x2F;选择排序：K 次选择后即可得到第 k 大的数。总的时间复杂度为 O(n*k)。</p></li><li><p>最小堆：维护一个 k 大小的最小堆，对于数组中的每一个元素判断与堆顶的大小，若堆顶较大，则不管，否则，弹出堆顶，将当前值插入到堆中。时间复杂度 O(n * logk)。</p></li><li><p>基于快速排序的二分，时间复杂度为 O(n)。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">quickfind</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt; &amp;arr, <span class="hljs-type">int</span> left, <span class="hljs-type">int</span> right, <span class="hljs-type">int</span> k)</span> </span>&#123;<br>    <span class="hljs-type">int</span> i = left, j = right;<br>    <span class="hljs-type">int</span> val = arr[left];<br>    <span class="hljs-keyword">while</span> (i &lt; j) &#123;<br>        <span class="hljs-keyword">while</span> (i &lt; j &amp;&amp; val &lt;= arr[j]) j--;<br>        arr[i] = arr[j];<br>        <span class="hljs-keyword">while</span> (i &lt; j &amp;&amp; val &gt;= arr[i]) i++;<br>        arr[j] = arr[i];<br>    &#125;<br>    arr[i] = val;<br>    <span class="hljs-keyword">if</span> (arr.<span class="hljs-built_in">size</span>() - i == k)<br>        <span class="hljs-keyword">return</span> arr[i];<br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (arr.<span class="hljs-built_in">size</span>() - i &gt; k)    <span class="hljs-comment">// 若右边元素大于k个，肯定在右边</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">quickfind</span>(arr, i + <span class="hljs-number">1</span>, right, k);<br>    <span class="hljs-keyword">else</span><span class="hljs-comment">// 若右边元素小于k个，肯定在左边</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">quickfind</span>(arr, left, i - <span class="hljs-number">1</span>, k);<br>&#125;<br></code></pre></td></tr></table></figure></li></ol><h3 id="链表"><a href="#链表" class="headerlink" title="链表"></a>链表</h3><p>数据结构</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">ListNode</span> &#123;<br>  <span class="hljs-type">int</span> val;<br>  ListNode* next;<br>  <span class="hljs-built_in">ListNode</span>(<span class="hljs-type">int</span> val):<span class="hljs-built_in">val</span>(val), <span class="hljs-built_in">next</span>(<span class="hljs-literal">nullptr</span>)&#123;&#125;<br>&#125;;<br>ListNode* node = <span class="hljs-keyword">new</span> <span class="hljs-built_in">ListNode</span>(val);<br><br><span class="hljs-comment">// 使用虚拟头节点</span><br>ListNode* dummyHead = <span class="hljs-keyword">new</span> <span class="hljs-built_in">ListNode</span>(<span class="hljs-number">0</span>);<br>dummyHead-&gt;next = head;<br>ListNode* cur = dummyHead;<br><br><span class="hljs-comment">// 指针数组（哈希）</span><br>vector&lt;ListNode*&gt; vec;<br>ListNode* cur=head;<br><span class="hljs-keyword">while</span>(cur)&#123;<br>  vec.<span class="hljs-built_in">push_back</span>(cur);<br>  cur=cur-&gt;next;<br>&#125;<br></code></pre></td></tr></table></figure><p>翻转链表</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">ListNode* <span class="hljs-title">reverseList</span><span class="hljs-params">(ListNode* head)</span> </span>&#123;<br>        ListNode* temp; <span class="hljs-comment">// 保存cur的下一个节点</span><br>        ListNode* cur = head;<br>        ListNode* pre = <span class="hljs-literal">NULL</span>;<br>        <span class="hljs-keyword">while</span>(cur) &#123;<br>            temp = cur-&gt;next;  <span class="hljs-comment">// 保存一下 cur的下一个节点，因为接下来要改变cur-&gt;next</span><br>            cur-&gt;next = pre; <span class="hljs-comment">// 翻转操作</span><br>            <span class="hljs-comment">// 更新pre 和 cur指针</span><br>            pre = cur;<br>            cur = temp;<br>        &#125;<br>        <span class="hljs-keyword">return</span> pre;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="字符串回文"><a href="#字符串回文" class="headerlink" title="字符串回文"></a>字符串回文</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// 双指针法</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">countSubstrings</span><span class="hljs-params">(string s)</span> </span>&#123;<br>  <span class="hljs-type">int</span> result = <span class="hljs-number">0</span>;<br>  <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; s.<span class="hljs-built_in">size</span>(); i++) &#123;<br>      result += <span class="hljs-built_in">extend</span>(s, i, i); <span class="hljs-comment">// 以 i 为中心</span><br>      result += <span class="hljs-built_in">extend</span>(s, i, i + <span class="hljs-number">1</span>); <span class="hljs-comment">// 以 i 和 i+1 为中心</span><br>  &#125;<br>  <span class="hljs-keyword">return</span> result;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">extend</span><span class="hljs-params">(<span class="hljs-type">const</span> string&amp; s, <span class="hljs-type">int</span> i, <span class="hljs-type">int</span> j)</span> </span>&#123;<br>  <span class="hljs-type">int</span> res = <span class="hljs-number">0</span>;<br>  <span class="hljs-keyword">while</span> (i &gt;= <span class="hljs-number">0</span> &amp;&amp; j &lt; s.<span class="hljs-built_in">size</span>() &amp;&amp; s[i] == s[j]) &#123;<br>      i--;<br>      j++;<br>      res++;<br>  &#125;<br>  <span class="hljs-keyword">return</span> res;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="二叉树"><a href="#二叉树" class="headerlink" title="二叉树"></a>二叉树</h3><p>数据结构</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">TreeNode</span> &#123;<br>  <span class="hljs-type">int</span> val;<br>  TreeNode *left;<br>  TreeNode *right;<br>  <span class="hljs-built_in">TreeNode</span>(<span class="hljs-type">int</span> x) : <span class="hljs-built_in">val</span>(x), <span class="hljs-built_in">left</span>(<span class="hljs-literal">nullptr</span>), <span class="hljs-built_in">right</span>(<span class="hljs-literal">nullptr</span>) &#123;&#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p>三种遍历</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// 先序遍历</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">traversal</span><span class="hljs-params">(TreeNode* cur, vector&lt;<span class="hljs-type">int</span>&gt;&amp; vec)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (cur == <span class="hljs-literal">NULL</span>) <span class="hljs-keyword">return</span>;<br>    vec.<span class="hljs-built_in">push_back</span>(cur-&gt;val);    <span class="hljs-comment">// 中</span><br>    <span class="hljs-built_in">traversal</span>(cur-&gt;left, vec);  <span class="hljs-comment">// 左</span><br>    <span class="hljs-built_in">traversal</span>(cur-&gt;right, vec); <span class="hljs-comment">// 右</span><br>&#125;<br><br><span class="hljs-comment">// 中序遍历</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">traversal</span><span class="hljs-params">(TreeNode* cur, vector&lt;<span class="hljs-type">int</span>&gt;&amp; vec)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (cur == <span class="hljs-literal">NULL</span>) <span class="hljs-keyword">return</span>;<br>    <span class="hljs-built_in">traversal</span>(cur-&gt;left, vec);  <span class="hljs-comment">// 左</span><br>    vec.<span class="hljs-built_in">push_back</span>(cur-&gt;val);    <span class="hljs-comment">// 中</span><br>    <span class="hljs-built_in">traversal</span>(cur-&gt;right, vec); <span class="hljs-comment">// 右</span><br>&#125;<br><br><span class="hljs-comment">// 后续遍历</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">traversal</span><span class="hljs-params">(TreeNode* cur, vector&lt;<span class="hljs-type">int</span>&gt;&amp; vec)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (cur == <span class="hljs-literal">NULL</span>) <span class="hljs-keyword">return</span>;<br>    <span class="hljs-built_in">traversal</span>(cur-&gt;left, vec);  <span class="hljs-comment">// 左</span><br>    <span class="hljs-built_in">traversal</span>(cur-&gt;right, vec); <span class="hljs-comment">// 右</span><br>    vec.<span class="hljs-built_in">push_back</span>(cur-&gt;val);    <span class="hljs-comment">// 中</span><br>&#125;<br></code></pre></td></tr></table></figure><p>层次遍历</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs cpp">vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">levelOrder</span>(TreeNode* root) &#123;<br>    queue&lt;TreeNode*&gt; que;<br>    <span class="hljs-keyword">if</span> (root != <span class="hljs-literal">NULL</span>) que.<span class="hljs-built_in">push</span>(root);<br>    vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; result;<br>    <span class="hljs-keyword">while</span> (!que.<span class="hljs-built_in">empty</span>()) &#123;<br>        <span class="hljs-type">int</span> size = que.<span class="hljs-built_in">size</span>();<br>        vector&lt;<span class="hljs-type">int</span>&gt; vec;<br>        <span class="hljs-comment">// 这里一定要使用固定大小size，不要使用que.size()，因为que.size是不断变化的</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; size; i++) &#123;<br>            TreeNode* node = que.<span class="hljs-built_in">front</span>();<br>            que.<span class="hljs-built_in">pop</span>();<br>            vec.<span class="hljs-built_in">push_back</span>(node-&gt;val);<br>            <span class="hljs-keyword">if</span> (node-&gt;left) que.<span class="hljs-built_in">push</span>(node-&gt;left);<br>            <span class="hljs-keyword">if</span> (node-&gt;right) que.<span class="hljs-built_in">push</span>(node-&gt;right);<br>        &#125;<br>        result.<span class="hljs-built_in">push_back</span>(vec); <span class="hljs-comment">// 二维数组，获得每一层的结点值</span><br>    &#125;<br>    <span class="hljs-keyword">return</span> result;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>递归遍历函数是否需要返回值？</strong></p><ul><li>若只要找到一条路径，不用全部遍历，则要返回值 bool。</li><li>若找到所有满足条件路径，要求全部遍历，则不需要返回值 void。</li></ul><p>例题：给定二叉树和目标和，判断该树中是否存在根节点到叶子节点的路径，路径上所有节点值相加等于目标和。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// 有返回值</span><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">traversal</span><span class="hljs-params">(TreeNode* cur, <span class="hljs-type">int</span> count)</span> </span>&#123;<br>    <span class="hljs-comment">// 遇到叶子节点，并且计数为0</span><br>    <span class="hljs-keyword">if</span> (!cur-&gt;left &amp;&amp; !cur-&gt;right &amp;&amp; count == <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    <span class="hljs-comment">// 遇到叶子节点直接返回</span><br>    <span class="hljs-keyword">if</span> (!cur-&gt;left &amp;&amp; !cur-&gt;right) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br><br>    <span class="hljs-keyword">if</span> (cur-&gt;left) &#123;<br>        <span class="hljs-comment">// 递归中隐藏着回溯！</span><br>        <span class="hljs-keyword">if</span> (<span class="hljs-built_in">traversal</span>(cur-&gt;left, count - cur-&gt;left-&gt;val)) <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br>    <span class="hljs-keyword">if</span> (cur-&gt;right) &#123;<br>        <span class="hljs-comment">// 递归中隐藏着回溯！</span><br>        <span class="hljs-keyword">if</span> (<span class="hljs-built_in">traversal</span>(cur-&gt;right, count - cur-&gt;right-&gt;val)) <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>例题：给定一个二叉树和一个目标和，找到所有从根节点到叶子节点路径总和等于给定目标和的路径。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">traverse</span><span class="hljs-params">(TreeNode* root,<span class="hljs-type">int</span> sum,vector&lt;<span class="hljs-type">int</span>&gt; path,vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt;&amp; res)</span></span>&#123;<br>        path.<span class="hljs-built_in">push_back</span>(root-&gt;val);<br>        <span class="hljs-keyword">if</span>(!root-&gt;left &amp;&amp; !root-&gt;right &amp;&amp; root-&gt;val == sum)&#123;<br>            res.<span class="hljs-built_in">push_back</span>(path);<br>        &#125;<br>        <span class="hljs-comment">// 递归中隐藏着回溯！</span><br>        <span class="hljs-keyword">if</span>(root-&gt;left != <span class="hljs-literal">nullptr</span>) <span class="hljs-built_in">traverse</span>(root-&gt;left,sum-root-&gt;val,path,res);<br>        <span class="hljs-keyword">if</span>(root-&gt;right != <span class="hljs-literal">nullptr</span>) <span class="hljs-built_in">traverse</span>(root-&gt;right,sum-root-&gt;val,path,res);<br>    &#125;<br>    vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">pathSum</span>(TreeNode* root, <span class="hljs-type">int</span> targetSum) &#123;<br>        vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; res;<br>        vector&lt;<span class="hljs-type">int</span>&gt; path;<br>        <span class="hljs-keyword">if</span>(root == <span class="hljs-literal">nullptr</span>) <span class="hljs-keyword">return</span> res;<br>        <span class="hljs-built_in">traverse</span>(root,targetSum,path,res);<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p>有序数组构造二叉搜索树</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><br><span class="hljs-function">TreeNode *<span class="hljs-title">createTree</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt; &amp;vec, <span class="hljs-type">int</span> left, <span class="hljs-type">int</span> right)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (left &gt; right) <span class="hljs-keyword">return</span> <span class="hljs-literal">nullptr</span>;<br>    <span class="hljs-type">int</span> mid = (left + right) / <span class="hljs-number">2</span>;<br>    TreeNode *node = <span class="hljs-keyword">new</span> <span class="hljs-built_in">TreeNode</span>(vec[mid]);<br>    node-&gt;left = <span class="hljs-built_in">createTree</span>(vec, left, mid - <span class="hljs-number">1</span>);<br>    node-&gt;right = <span class="hljs-built_in">createTree</span>(vec, mid + <span class="hljs-number">1</span>, right);<br>    <span class="hljs-keyword">return</span> node;<br>&#125;<br></code></pre></td></tr></table></figure><p>利用二叉搜索树查找结果</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function">TreeNode* <span class="hljs-title">searchBST</span><span class="hljs-params">(TreeNode* root, <span class="hljs-type">int</span> val)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (root == <span class="hljs-literal">NULL</span> || root-&gt;val == val) <span class="hljs-keyword">return</span> root;<br>    TreeNode* result = <span class="hljs-literal">NULL</span>;<br>    <span class="hljs-keyword">if</span> (root-&gt;val &gt; val) result = <span class="hljs-built_in">searchBST</span>(root-&gt;left, val);<br>    <span class="hljs-keyword">if</span> (root-&gt;val &lt; val) result = <span class="hljs-built_in">searchBST</span>(root-&gt;right, val);<br>    <span class="hljs-keyword">return</span> result;<br>&#125;<br></code></pre></td></tr></table></figure><p>判定二叉搜索树</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs cpp">TreeNode* pre = <span class="hljs-literal">NULL</span>; <span class="hljs-comment">// 用来记录前一个节点</span><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">isValidBST</span><span class="hljs-params">(TreeNode* root)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (root == <span class="hljs-literal">NULL</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    <span class="hljs-type">bool</span> left = <span class="hljs-built_in">isValidBST</span>(root-&gt;left);<br><br>    <span class="hljs-keyword">if</span> (pre != <span class="hljs-literal">NULL</span> &amp;&amp; pre-&gt;val &gt;= root-&gt;val) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    pre = root; <span class="hljs-comment">// 记录前一个节点</span><br><br>    <span class="hljs-type">bool</span> right = <span class="hljs-built_in">isValidBST</span>(root-&gt;right);<br>    <span class="hljs-keyword">return</span> left &amp;&amp; right;<br>&#125;<br></code></pre></td></tr></table></figure><p>考虑设置 全局变量<code>public: TreeNode* pre</code>递归过程更新全局指针变量。</p><p>求公共最近公共邻居 leetcode.236：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">TreeNode* <span class="hljs-title">lowestCommonAncestor</span><span class="hljs-params">(TreeNode* root, TreeNode* p, TreeNode* q)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (root == q || root == p || root == <span class="hljs-literal">NULL</span>) <span class="hljs-keyword">return</span> root;<br>        TreeNode* left = <span class="hljs-built_in">lowestCommonAncestor</span>(root-&gt;left, p, q);<br>        TreeNode* right = <span class="hljs-built_in">lowestCommonAncestor</span>(root-&gt;right, p, q);<br>        <span class="hljs-keyword">if</span> (left != <span class="hljs-literal">NULL</span> &amp;&amp; right != <span class="hljs-literal">NULL</span>) <span class="hljs-keyword">return</span> root;<br><br>        <span class="hljs-keyword">if</span> (left == <span class="hljs-literal">NULL</span> &amp;&amp; right != <span class="hljs-literal">NULL</span>) <span class="hljs-keyword">return</span> right;<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (left != <span class="hljs-literal">NULL</span> &amp;&amp; right == <span class="hljs-literal">NULL</span>) <span class="hljs-keyword">return</span> left;<br>        <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;<br>        &#125;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p><strong>递归一定看函数返回什么，指针？整数？，利用起来<code>root-&gt;left = deleteNode(root-&gt;left,key);</code>。</strong></p><h3 id="图论"><a href="#图论" class="headerlink" title="图论"></a>图论</h3><p>DFS 模板</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// 第一种</span><br><span class="hljs-type">bool</span> visited[MAX_V];<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">DFS</span><span class="hljs-params">(vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; &amp;graph, <span class="hljs-type">int</span> u)</span> </span>&#123;<br><span class="hljs-comment">// visit(G, u);</span><br>visited[u] = <span class="hljs-literal">true</span>;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> v:graph[u]) &#123;<br><span class="hljs-keyword">if</span> (!visited[v]) &#123;<br><span class="hljs-built_in">DFS</span>(graph, v);<br>&#125;<br>&#125;<br>&#125;<br><br><span class="hljs-comment">// 第二种</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(参数)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (终止条件) &#123;<br>        存放结果;<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br><br>    <span class="hljs-keyword">for</span> (选择：本节点所连接的其他节点) &#123;<br>        处理节点;<br>        <span class="hljs-built_in">dfs</span>(图，选择的节点); <span class="hljs-comment">// 递归</span><br>        回溯，撤销处理结果<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>例题：797 所有可能的路径</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// 给你一个有 n 个节点的 有向无环图（DAG），请你找出所有从节点 0 到节点 n-1 的路径并输出（不要求按特定顺序）</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">private</span>:<br>    vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; result; <span class="hljs-comment">// 收集符合条件的路径</span><br>    vector&lt;<span class="hljs-type">int</span>&gt; path; <span class="hljs-comment">// 0节点到终点的路径</span><br>    <span class="hljs-comment">// x：目前遍历的节点</span><br>    <span class="hljs-comment">// graph：存当前的图</span><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">dfs</span> <span class="hljs-params">(vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt;&amp; graph, <span class="hljs-type">int</span> x)</span> </span>&#123;<br>        <span class="hljs-comment">// 要求从节点 0 到节点 n-1 的路径并输出，所以是 graph.size() - 1</span><br>        <span class="hljs-keyword">if</span> (x == graph.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>) &#123; <span class="hljs-comment">// 找到符合条件的一条路径</span><br>            result.<span class="hljs-built_in">push_back</span>(path);<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; graph[x].<span class="hljs-built_in">size</span>(); i++) &#123; <span class="hljs-comment">// 遍历节点n链接的所有节点</span><br>            path.<span class="hljs-built_in">push_back</span>(graph[x][i]); <span class="hljs-comment">// 遍历到的节点加入到路径中来</span><br>            <span class="hljs-built_in">dfs</span>(graph, graph[x][i]); <span class="hljs-comment">// 进入下一层递归</span><br>            path.<span class="hljs-built_in">pop_back</span>(); <span class="hljs-comment">// 回溯，撤销本节点</span><br>        &#125;<br>    &#125;<br><span class="hljs-keyword">public</span>:<br>    vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">allPathsSourceTarget</span>(vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt;&amp; graph) &#123;<br>        path.<span class="hljs-built_in">push_back</span>(<span class="hljs-number">0</span>); <span class="hljs-comment">// 无论什么路径已经是从0节点出发</span><br>        <span class="hljs-built_in">dfs</span>(graph, <span class="hljs-number">0</span>); <span class="hljs-comment">// 开始遍历</span><br>        <span class="hljs-keyword">return</span> result;<br>    &#125;<br>&#125;;<br><br></code></pre></td></tr></table></figure><p><strong>Dijkstra 求单源最短路径</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// 堆优化</span><br><span class="hljs-comment">// graph[u] 存放 (v,dis) 邻点距离集合</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">dijkstra</span><span class="hljs-params">(vector&lt;vector&lt;pair&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt;&gt;&gt;&amp; graph, <span class="hljs-type">int</span> start)</span> </span>&#123;<br>    <span class="hljs-type">int</span> n = graph.<span class="hljs-built_in">size</span>();<br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">dist</span><span class="hljs-params">(n, INT_MAX)</span></span>; <span class="hljs-comment">// 用于存储最短距离的数组</span><br>    dist[start] = <span class="hljs-number">0</span>; <span class="hljs-comment">// 初始节点的距离为0</span><br><br>    priority_queue&lt;pair&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt;, vector&lt;pair&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt;&gt;, greater&lt;pair&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt;&gt;&gt; pq; <span class="hljs-comment">// 小顶堆</span><br>    pq.<span class="hljs-built_in">push</span>(<span class="hljs-built_in">make_pair</span>(<span class="hljs-number">0</span>, start)); <span class="hljs-comment">// 将起始节点加入最小堆</span><br><br>    <span class="hljs-keyword">while</span> (!pq.<span class="hljs-built_in">empty</span>()) &#123;<br>        pair&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt; current = pq.<span class="hljs-built_in">top</span>();<br>        pq.<span class="hljs-built_in">pop</span>();<br><br>        <span class="hljs-type">int</span> u = current.second;<br>        <span class="hljs-type">int</span> weight = current.first;<br><br>        <span class="hljs-comment">// 如果当前距离已经不是最小值，则跳过</span><br>        <span class="hljs-keyword">if</span> (weight &gt; dist[u]) <span class="hljs-keyword">continue</span>;<br><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">const</span> pair&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt;&amp; neighbor : graph[u]) &#123;<br>            <span class="hljs-type">int</span> v = neighbor.first;<br>            <span class="hljs-type">int</span> w = neighbor.second;<br><br>            <span class="hljs-comment">// 如果通过u到v的路径更短，则更新距离</span><br>            <span class="hljs-keyword">if</span> (dist[u] + w &lt; dist[v]) &#123;<br>                dist[v] = dist[u] + w;<br>                pq.<span class="hljs-built_in">push</span>(<span class="hljs-built_in">make_pair</span>(dist[v], v)); <span class="hljs-comment">// 将更新后的距离加入最小堆</span><br>            &#125;<br>        &#125;<br>    &#125;<br><span class="hljs-comment">// dist[i] 存放 start 到 i 的最短距离</span><br>&#125;<br></code></pre></td></tr></table></figure><p><strong>拓扑排序</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">topologicalSort</span><span class="hljs-params">(vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt;&amp; graph, vector&lt;<span class="hljs-type">int</span>&gt;&amp; inDegree)</span> </span>&#123;<br>    <span class="hljs-type">int</span> n = graph.<span class="hljs-built_in">size</span>();<br>    vector&lt;<span class="hljs-type">int</span>&gt; result; <span class="hljs-comment">// 存储拓扑排序的结果</span><br>    queue&lt;<span class="hljs-type">int</span>&gt; q;<br><br>    <span class="hljs-comment">// 将入度为0的节点加入队列</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; ++i) &#123;<br>        <span class="hljs-keyword">if</span> (inDegree[i] == <span class="hljs-number">0</span>) &#123;<br>            q.<span class="hljs-built_in">push</span>(i);<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">while</span> (!q.<span class="hljs-built_in">empty</span>()) &#123;<br>        <span class="hljs-type">int</span> u = q.<span class="hljs-built_in">front</span>();<br>        q.<span class="hljs-built_in">pop</span>();<br>        result.<span class="hljs-built_in">push_back</span>(u);<br><br>        <span class="hljs-comment">// 更新与u相邻节点的入度</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> v : graph[u]) &#123;<br>            inDegree[v]--;<br>            <span class="hljs-comment">// 如果入度为0，将其加入队列</span><br>            <span class="hljs-keyword">if</span> (inDegree[v] == <span class="hljs-number">0</span>) &#123;<br>                q.<span class="hljs-built_in">push</span>(v);<br>            &#125;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> result;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="并查集"><a href="#并查集" class="headerlink" title="并查集"></a>并查集</h3><p>并查集常用来解决连通性问题</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-type">int</span> n = <span class="hljs-number">1005</span>; <span class="hljs-comment">// n根据题目中节点数量而定，一般比节点数量大一点就好</span><br>vector&lt;<span class="hljs-type">int</span>&gt; father = <span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">int</span>&gt; (n, <span class="hljs-number">0</span>); <span class="hljs-comment">// C++里的一种数组结构</span><br><br><span class="hljs-comment">// 并查集初始化</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">init</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; ++i) &#123;<br>        father[i] = i;<br>    &#125;<br>&#125;<br><span class="hljs-comment">// 并查集里寻根的过程</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">find</span><span class="hljs-params">(<span class="hljs-type">int</span> u)</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> u == father[u] ? u : father[u] = <span class="hljs-built_in">find</span>(father[u]); <span class="hljs-comment">// 路径压缩</span><br>&#125;<br><br><span class="hljs-comment">// 判断 u 和 v是否找到同一个根</span><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">isSame</span><span class="hljs-params">(<span class="hljs-type">int</span> u, <span class="hljs-type">int</span> v)</span> </span>&#123;<br>    u = <span class="hljs-built_in">find</span>(u);<br>    v = <span class="hljs-built_in">find</span>(v);<br>    <span class="hljs-keyword">return</span> u == v;<br>&#125;<br><br><span class="hljs-comment">// 将v-&gt;u 这条边加入并查集</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">join</span><span class="hljs-params">(<span class="hljs-type">int</span> u, <span class="hljs-type">int</span> v)</span> </span>&#123;<br>    u = <span class="hljs-built_in">find</span>(u); <span class="hljs-comment">// 寻找u的根</span><br>    v = <span class="hljs-built_in">find</span>(v); <span class="hljs-comment">// 寻找v的根</span><br>    <span class="hljs-keyword">if</span> (u == v) <span class="hljs-keyword">return</span> ; <span class="hljs-comment">// 如果发现根相同，则说明在一个集合，不用两个节点相连直接返回</span><br>    father[v] = u;<br>&#125;<br></code></pre></td></tr></table></figure><p>并查集主要有三个功能。</p><ol><li>寻找根节点，函数：find(int u)，也就是判断这个节点的祖先节点是哪个</li><li>将两个节点接入到同一个集合，函数：join(int u, int v)，将两个节点连在同一个根节点上</li><li>判断两个节点是否在同一个集合，函数：isSame(int u, int v)，就是判断两个节点是不是同一个根节点</li></ol><h3 id="回溯法"><a href="#回溯法" class="headerlink" title="回溯法"></a>回溯法</h3><p>回溯法的效率：回溯法就是暴力搜索，并不是什么高效的算法，最多在剪枝一下。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-type">void</span> backtracking（参数） &#123;<br>  <span class="hljs-keyword">if</span> （终止条件） &#123;<br>      存放结果；<br>      <span class="hljs-keyword">return</span>;<br>  &#125;<br>  <span class="hljs-keyword">for</span> （选择：本层集合中元素（树中节点孩子的数量就是集合的大小）) &#123;<br>      处理节点；<br>      backtracking（路径，选择列表）; <span class="hljs-comment">// 递归</span><br>      回溯，撤销处理结果!<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="组合问题"><a href="#组合问题" class="headerlink" title="组合问题"></a>组合问题</h4><p>元素不可重复选取，n 里选 k 个</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// 给定两个整数 n 和 k，返回 1 ... n 中所有可能的 k 个数的组合。</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">private</span>:<br>  vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; result; <span class="hljs-comment">// 存放符合条件结果的集合</span><br>  vector&lt;<span class="hljs-type">int</span>&gt; path; <span class="hljs-comment">// 用来存放符合条件结果</span><br>  <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">backtracking</span><span class="hljs-params">(<span class="hljs-type">int</span> n, <span class="hljs-type">int</span> k, <span class="hljs-type">int</span> startIndex)</span> </span>&#123;<br>      <span class="hljs-keyword">if</span> (path.<span class="hljs-built_in">size</span>() == k) &#123;<br>          result.<span class="hljs-built_in">push_back</span>(path);<br>          <span class="hljs-keyword">return</span>;<br>      &#125;<br>      <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = startIndex; i &lt;= n; i++) &#123;<br>          path.<span class="hljs-built_in">push_back</span>(i); <span class="hljs-comment">// 处理节点</span><br>          <span class="hljs-built_in">backtracking</span>(n, k, i + <span class="hljs-number">1</span>);   <span class="hljs-comment">//注意 传 i+1, 不是 startIndex</span><br>          path.<span class="hljs-built_in">pop_back</span>(); <span class="hljs-comment">// 回溯，撤销处理的节点</span><br>      &#125;<br>  &#125;<br><span class="hljs-keyword">public</span>:<br>  vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">combine</span>(<span class="hljs-type">int</span> n, <span class="hljs-type">int</span> k) &#123;<br>      result.<span class="hljs-built_in">clear</span>();<br>      path.<span class="hljs-built_in">clear</span>();<br>      <span class="hljs-built_in">backtracking</span>(n, k, <span class="hljs-number">1</span>);<br>      <span class="hljs-keyword">return</span> result;<br>  &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p>元素可重复选取</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// 给定一个无重复元素的数组 candidates 和一个目标数 target ，找出 candidates 中所有可以使数字和为 target 的组合。</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">private</span>:<br>    vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; result;<br>    vector&lt;<span class="hljs-type">int</span>&gt; path;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">backtracking</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; candidates, <span class="hljs-type">int</span> target, <span class="hljs-type">int</span> sum, <span class="hljs-type">int</span> startIndex)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (sum &gt; target) &#123;<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        <span class="hljs-keyword">if</span> (sum == target) &#123;<br>            result.<span class="hljs-built_in">push_back</span>(path);<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = startIndex; i &lt; candidates.<span class="hljs-built_in">size</span>(); i++) &#123;<br>            sum += candidates[i];<br>            path.<span class="hljs-built_in">push_back</span>(candidates[i]);<br><br>            <span class="hljs-comment">// 不用i+1了，表示可以重复读取当前的数</span><br>            <span class="hljs-built_in">backtracking</span>(candidates, target, sum, i);<br><br>            sum -= candidates[i];<br>            path.<span class="hljs-built_in">pop_back</span>();<br>        &#125;<br>    &#125;<br><span class="hljs-keyword">public</span>:<br>    vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">combinationSum</span>(vector&lt;<span class="hljs-type">int</span>&gt;&amp; candidates, <span class="hljs-type">int</span> target) &#123;<br>        result.<span class="hljs-built_in">clear</span>();<br>        path.<span class="hljs-built_in">clear</span>();<br>        <span class="hljs-built_in">backtracking</span>(candidates, target, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>);<br>        <span class="hljs-keyword">return</span> result;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><ul><li><p>组合问题是无序的，取过的元素不会重复取，for 就要从 startIndex 开始</p></li><li><p>排列问题是有序的，{1, 2}和{2, 1}是两个集合，for 就要从 0 开始</p></li></ul><h4 id="切割问题"><a href="#切割问题" class="headerlink" title="切割问题"></a>切割问题</h4><p>给定一个字符串 s，将 s 分割成一些子串，使每个子串都是回文串，返回 s 所有可能的分割方案。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// 二重for循环，不用回溯</span><br><span class="hljs-comment">// 每次以i开始，[i+1,end]结束，判断是否为回文</span><br><br><span class="hljs-comment">// 记忆优化的回文判断</span><br>vector&lt;vector&lt;<span class="hljs-type">bool</span>&gt;&gt; isPalindrome; <span class="hljs-comment">// 放事先计算好的是否回文子串的结果</span><br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">computePalindrome</span><span class="hljs-params">(<span class="hljs-type">const</span> string&amp; s)</span> </span>&#123;<br>    <span class="hljs-comment">// isPalindrome[i][j] 代表 s[i:j](双边包括)是否是回文字串</span><br>    isPalindrome.<span class="hljs-built_in">resize</span>(s.<span class="hljs-built_in">size</span>(), <span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">bool</span>&gt;(s.<span class="hljs-built_in">size</span>(), <span class="hljs-literal">false</span>));<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = s.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>; i &gt;= <span class="hljs-number">0</span>; i--) &#123;<br>        <span class="hljs-comment">// 需要倒序计算, 保证在i行时, i+1行已经计算好了</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = i; j &lt; s.<span class="hljs-built_in">size</span>(); j++) &#123;<br>            <span class="hljs-keyword">if</span> (j == i) &#123;<br>                isPalindrome[i][j] = <span class="hljs-literal">true</span>;<br>            &#125;<br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (j - i == <span class="hljs-number">1</span>) &#123;<br>                isPalindrome[i][j] = (s[i] == s[j]);<br>            &#125;<br>            <span class="hljs-keyword">else</span> &#123;<br>                isPalindrome[i][j] = (s[i] == s[j] &amp;&amp; isPalindrome[i+<span class="hljs-number">1</span>][j<span class="hljs-number">-1</span>]);<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="子集问题"><a href="#子集问题" class="headerlink" title="子集问题"></a>子集问题</h4><p>给定一组<strong>不含重复元素</strong>的整数数组 nums，返回该数组所有可能的子集（幂集）</p><ul><li>求取子集问题，不需要任何剪枝！因为子集就是要遍历整棵树</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">private</span>:<br>    vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; result;<br>    vector&lt;<span class="hljs-type">int</span>&gt; path;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">backtracking</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums, <span class="hljs-type">int</span> startIndex)</span> </span>&#123;<br>        result.<span class="hljs-built_in">push_back</span>(path); <span class="hljs-comment">// 收集子集，要放在终止添加的上面，否则会漏掉自己</span><br>        <span class="hljs-keyword">if</span> (startIndex &gt;= nums.<span class="hljs-built_in">size</span>()) &#123; <span class="hljs-comment">// 终止条件可以不加</span><br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = startIndex; i &lt; nums.<span class="hljs-built_in">size</span>(); i++) &#123;<br>            path.<span class="hljs-built_in">push_back</span>(nums[i]);<br>            <span class="hljs-built_in">backtracking</span>(nums, i + <span class="hljs-number">1</span>);<br>            path.<span class="hljs-built_in">pop_back</span>();<br>        &#125;<br>    &#125;<br><span class="hljs-keyword">public</span>:<br>    vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">subsets</span>(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums) &#123;<br>        result.<span class="hljs-built_in">clear</span>();<br>        path.<span class="hljs-built_in">clear</span>();<br>        <span class="hljs-built_in">backtracking</span>(nums, <span class="hljs-number">0</span>);<br>        <span class="hljs-keyword">return</span> result;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p>给定一个可能<strong>包含重复元素</strong>的整数数组 nums，返回该数组所有可能的子集（幂集）。</p><ul><li><strong>对于结果有重复子集，需去重，则先排序，通过判断相邻结点是否重复使用过。</strong></li><li><code>if (used[i-1] == false) &#123; ... &#125;</code>，记住前提条件，<strong>上一层已选过，就不考虑啦</strong></li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">private</span>:<br>  vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; result;<br>  vector&lt;<span class="hljs-type">int</span>&gt; path;<br>  <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">backtracking</span> <span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums, vector&lt;<span class="hljs-type">bool</span>&gt;&amp; used)</span> </span>&#123;<br>      <span class="hljs-comment">// 此时说明找到了一组</span><br>      <span class="hljs-keyword">if</span> (path.<span class="hljs-built_in">size</span>() == nums.<span class="hljs-built_in">size</span>()) &#123;<br>          result.<span class="hljs-built_in">push_back</span>(path);<br>          <span class="hljs-keyword">return</span>;<br>      &#125;<br>      <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; nums.<span class="hljs-built_in">size</span>(); i++) &#123;<br>          <span class="hljs-comment">// used[i - 1] == true，说明同一树枝 nums[i - 1] 使用过</span><br>          <span class="hljs-comment">// used[i - 1] == false，说明同一树层 nums[i - 1] 使用过</span><br>          <span class="hljs-comment">// 如果同一树层 nums[i - 1] 使用过则直接跳过</span><br>          <span class="hljs-keyword">if</span> (i &gt; <span class="hljs-number">0</span> &amp;&amp; nums[i] == nums[i - <span class="hljs-number">1</span>] &amp;&amp; used[i - <span class="hljs-number">1</span>] == <span class="hljs-literal">false</span>) &#123;<br>              <span class="hljs-keyword">continue</span>;<br>          &#125;<br>          <span class="hljs-comment">//if ( used[i] == true ) continue;</span><br>          <span class="hljs-keyword">if</span> (used[i] == <span class="hljs-literal">false</span>) &#123;<br>              used[i] = <span class="hljs-literal">true</span>;<br>              path.<span class="hljs-built_in">push_back</span>(nums[i]);<br>              <span class="hljs-built_in">backtracking</span>(nums, used);<br>              path.<span class="hljs-built_in">pop_back</span>();<br>              used[i] = <span class="hljs-literal">false</span>;<br>          &#125;<br>      &#125;<br>  &#125;<br><span class="hljs-keyword">public</span>:<br>  vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">permuteUnique</span>(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums) &#123;<br>      result.<span class="hljs-built_in">clear</span>();<br>      path.<span class="hljs-built_in">clear</span>();<br>      <span class="hljs-built_in">sort</span>(nums.<span class="hljs-built_in">begin</span>(), nums.<span class="hljs-built_in">end</span>()); <span class="hljs-comment">// 排序</span><br>      <span class="hljs-function">vector&lt;<span class="hljs-type">bool</span>&gt; <span class="hljs-title">used</span><span class="hljs-params">(nums.size(), <span class="hljs-literal">false</span>)</span></span>;<br>      <span class="hljs-built_in">backtracking</span>(nums, used);<br>      <span class="hljs-keyword">return</span> result;<br>  &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p>递归和回溯：<br>1）要遍历所有元素找全部结果，函数 void 无返回值。<br>2）只要找到一条路径&#x2F;结果，函数有返回值 bool（同二叉树）。</p><h3 id="贪心算法"><a href="#贪心算法" class="headerlink" title="贪心算法"></a>贪心算法</h3><p><strong>贪心的本质是选择每一阶段的局部最优，从而达到全局最优。</strong></p><p><strong>1.序列问题</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// 给定一个整数数组 nums ，找到一个具有最大和的连续子数组（子数组最少包含一个元素），返回其最大和。</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">maxSubArray</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums)</span> </span>&#123;<br>        <span class="hljs-type">int</span> result = INT32_MIN;<br>        <span class="hljs-type">int</span> count = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; nums.<span class="hljs-built_in">size</span>(); i++) &#123; <span class="hljs-comment">// 设置起始位置</span><br>            count = <span class="hljs-number">0</span>;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = i; j &lt; nums.<span class="hljs-built_in">size</span>(); j++) &#123; <span class="hljs-comment">// 每次从起始位置i开始遍历寻找最大值</span><br>                count += nums[j];<br>                result = count &gt; result ? count : result;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> result;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p><strong>2.汽车加油站问题</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// 在一条环路上有 N 个加油站，其中第 i 个加油站有汽油 gas[i] 升。你有一辆油箱容量无限的的汽车，从第 i 个加油站开往第 i+1 个加油站需要消耗汽油 cost[i] 升。你从其中的一个加油站出发，开始时油箱为空。如果你可以绕环路行驶一周，则返回出发时加油站的编号，否则返回 -1。</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">canCompleteCircuit</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; gas, vector&lt;<span class="hljs-type">int</span>&gt;&amp; cost)</span> </span>&#123;<br>        <span class="hljs-type">int</span> curSum = <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> totalSum = <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> start = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; gas.<span class="hljs-built_in">size</span>(); i++) &#123;<br>            curSum += gas[i] - cost[i];<br>            totalSum += gas[i] - cost[i];<br>            <span class="hljs-keyword">if</span> (curSum &lt; <span class="hljs-number">0</span>) &#123;   <span class="hljs-comment">// 当前累加rest[i]和 curSum一旦小于0</span><br>                start = i + <span class="hljs-number">1</span>;  <span class="hljs-comment">// 起始位置更新为i+1</span><br>                curSum = <span class="hljs-number">0</span>;     <span class="hljs-comment">// curSum从0开始</span><br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">if</span> (totalSum &lt; <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>; <span class="hljs-comment">// 说明怎么走都不可能跑一圈了</span><br>        <span class="hljs-keyword">return</span> start;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p><strong>3.两个维度权衡问题</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// 分发糖果，有 N 个孩子站成了一条直线，老师会根据每个孩子的表现，预先给他们评分,每个孩子至少分配到 1 个糖果，相邻的孩子中，评分高的孩子必须获得更多的糖果。</span><br><br><span class="hljs-comment">// 思路：先确定一边之后，再确定另一边，例如比较每一个孩子的左边，然后再比较右边，如果两边一起考虑一定会顾此失彼。先确定右边评分大于左边的情况（也就是从前向后遍历）此时局部最优：只要右边评分比左边大，右边的孩子就多一个糖果，全局最优：相邻的孩子中，评分高的右孩子获得比左边孩子更多的糖果</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">candy</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; ratings)</span> </span>&#123;<br>        <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">candyVec</span><span class="hljs-params">(ratings.size(), <span class="hljs-number">1</span>)</span></span>;<br>        <span class="hljs-comment">// 从前向后</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt; ratings.<span class="hljs-built_in">size</span>(); i++) &#123;<br>            <span class="hljs-keyword">if</span> (ratings[i] &gt; ratings[i - <span class="hljs-number">1</span>]) candyVec[i] = candyVec[i - <span class="hljs-number">1</span>] + <span class="hljs-number">1</span>;<br>        &#125;<br>        <span class="hljs-comment">// 从后向前</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = ratings.<span class="hljs-built_in">size</span>() - <span class="hljs-number">2</span>; i &gt;= <span class="hljs-number">0</span>; i--) &#123;<br>            <span class="hljs-keyword">if</span> (ratings[i] &gt; ratings[i + <span class="hljs-number">1</span>] ) &#123;<br>                candyVec[i] = <span class="hljs-built_in">max</span>(candyVec[i], candyVec[i + <span class="hljs-number">1</span>] + <span class="hljs-number">1</span>);<br>            &#125;<br>        &#125;<br>        <span class="hljs-comment">// 统计结果</span><br>        <span class="hljs-type">int</span> result = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; candyVec.<span class="hljs-built_in">size</span>(); i++) result += candyVec[i];<br>        <span class="hljs-keyword">return</span> result;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p><strong>4.区间问题</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// 给出一个区间的集合，请合并所有重叠的区间。</span><br><br><span class="hljs-comment">// 思路：先排序，让所有的相邻区间尽可能的重叠在一起，按左边界。</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">merge</span>(vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt;&amp; intervals) &#123;<br>        vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; result;<br>        <span class="hljs-keyword">if</span> (intervals.<span class="hljs-built_in">size</span>() == <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> result; <span class="hljs-comment">// 区间集合为空直接返回</span><br>        <span class="hljs-comment">// 排序的参数使用了lambda表达式</span><br>        <span class="hljs-built_in">sort</span>(intervals.<span class="hljs-built_in">begin</span>(), intervals.<span class="hljs-built_in">end</span>(), [](<span class="hljs-type">const</span> vector&lt;<span class="hljs-type">int</span>&gt;&amp; a, <span class="hljs-type">const</span> vector&lt;<span class="hljs-type">int</span>&gt;&amp; b)&#123;<span class="hljs-keyword">return</span> a[<span class="hljs-number">0</span>] &lt; b[<span class="hljs-number">0</span>];&#125;);<br><br>        <span class="hljs-comment">// 第一个区间就可以放进结果集里，后面如果重叠，在result上直接合并</span><br>        result.<span class="hljs-built_in">push_back</span>(intervals[<span class="hljs-number">0</span>]);<br><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt; intervals.<span class="hljs-built_in">size</span>(); i++) &#123;<br>            <span class="hljs-keyword">if</span> (result.<span class="hljs-built_in">back</span>()[<span class="hljs-number">1</span>] &gt;= intervals[i][<span class="hljs-number">0</span>]) &#123; <span class="hljs-comment">// 发现重叠区间</span><br>                <span class="hljs-comment">// 合并区间，只更新右边界就好，因为result.back()的左边界一定是最小值，因为我们按照左边界排序的</span><br>                result.<span class="hljs-built_in">back</span>()[<span class="hljs-number">1</span>] = <span class="hljs-built_in">max</span>(result.<span class="hljs-built_in">back</span>()[<span class="hljs-number">1</span>], intervals[i][<span class="hljs-number">1</span>]);<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                result.<span class="hljs-built_in">push_back</span>(intervals[i]); <span class="hljs-comment">// 区间不重叠</span><br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> result;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="动态规划"><a href="#动态规划" class="headerlink" title="动态规划"></a>动态规划</h3><p>步骤：</p><ol><li><p>确定 dp 数组以及下标的含义</p></li><li><p>确定递推公式</p></li><li><p>dp 数组如何初始化</p></li><li><p>确定遍历顺序</p></li><li><p>举例推导 dp 数组</p></li></ol><blockquote><p><strong>debug 最好方式就是把 dp 数组打印出来，看看究竟是不是按照自己思路推导的！</strong></p></blockquote><blockquote><p><strong>dp 初始化后，遍历数组考虑初始值，避免越界。</strong></p></blockquote><p><strong>爬楼梯</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// 假设你正在爬楼梯。需要 n 阶你才能到达楼顶。每次你可以爬 1 或 2 个台阶。你有多少种不同的方法可以爬到楼顶呢？</span><br><br><span class="hljs-comment">// dp[i]： 爬到第i层楼梯，有dp[i]种方法</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">climbStairs</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (n &lt;= <span class="hljs-number">1</span>) <span class="hljs-keyword">return</span> n; <span class="hljs-comment">// 因为下面直接对dp[2]操作了，防止空指针</span><br>        <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">dp</span><span class="hljs-params">(n + <span class="hljs-number">1</span>)</span></span>;<br>        dp[<span class="hljs-number">1</span>] = <span class="hljs-number">1</span>;<br>        dp[<span class="hljs-number">2</span>] = <span class="hljs-number">2</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">3</span>; i &lt;= n; i++) &#123; <span class="hljs-comment">// 注意i是从3开始的</span><br>            dp[i] = dp[i - <span class="hljs-number">1</span>] + dp[i - <span class="hljs-number">2</span>];<br>        &#125;<br>        <span class="hljs-keyword">return</span> dp[n];<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p><strong>不同路径</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// 机器人位于一个 m x n 网格的左上角机器人每次只能向下或者向右移动一步。机器人试图达到网格的右下角,问总共有多少条不同的路径？</span><br><br><span class="hljs-comment">// dp[i][j] ：表示从（0 ，0）出发，到(i, j) 有dp[i][j]条不同的路径。</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">uniquePaths</span><span class="hljs-params">(<span class="hljs-type">int</span> m, <span class="hljs-type">int</span> n)</span> </span>&#123;<br>        vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">dp</span>(m, <span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">int</span>&gt;(n, <span class="hljs-number">0</span>));<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; m; i++) dp[i][<span class="hljs-number">0</span>] = <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; n; j++) dp[<span class="hljs-number">0</span>][j] = <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt; m; i++) &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">1</span>; j &lt; n; j++) &#123;<br>                dp[i][j] = dp[i - <span class="hljs-number">1</span>][j] + dp[i][j - <span class="hljs-number">1</span>];<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> dp[m - <span class="hljs-number">1</span>][n - <span class="hljs-number">1</span>];<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p><strong>01 背包问题</strong></p><ul><li><p>每个物品只能放入一次。</p></li><li><p>外层遍历物品，<strong>内层遍历容量</strong>。</p></li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">test_2_wei_bag_problem1</span><span class="hljs-params">()</span> </span>&#123;<br>    vector&lt;<span class="hljs-type">int</span>&gt; weight = &#123;<span class="hljs-number">1</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>&#125;;<br>    vector&lt;<span class="hljs-type">int</span>&gt; value = &#123;<span class="hljs-number">15</span>, <span class="hljs-number">20</span>, <span class="hljs-number">30</span>&#125;;<br>    <span class="hljs-type">int</span> bagweight = <span class="hljs-number">4</span>;<br><br>    <span class="hljs-comment">// 二维数组</span><br>    vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">dp</span>(weight.<span class="hljs-built_in">size</span>(), <span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">int</span>&gt;(bagweight + <span class="hljs-number">1</span>, <span class="hljs-number">0</span>));<br><br>    <span class="hljs-comment">// 初始化</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = weight[<span class="hljs-number">0</span>]; j &lt;= bagweight; j++) &#123;<br>        dp[<span class="hljs-number">0</span>][j] = value[<span class="hljs-number">0</span>];<br>    &#125;<br><br>    <span class="hljs-comment">// weight数组的大小 就是物品个数</span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt; weight.<span class="hljs-built_in">size</span>(); i++) &#123; <span class="hljs-comment">// 遍历物品</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt;= bagweight; j++) &#123; <span class="hljs-comment">// 遍历背包容量</span><br>            <span class="hljs-keyword">if</span> (j &lt; weight[i]) dp[i][j] = dp[i - <span class="hljs-number">1</span>][j];<br>            <span class="hljs-keyword">else</span> dp[i][j] = <span class="hljs-built_in">max</span>(dp[i - <span class="hljs-number">1</span>][j], dp[i - <span class="hljs-number">1</span>][j - weight[i]] + value[i]);<br><br>        &#125;<br>    &#125;<br><br>    cout &lt;&lt; dp[weight.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>][bagweight] &lt;&lt; endl;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li><strong>滚动数组</strong>：降低空间复杂度。先正序遍历物品，在倒序遍历背包容量，dp[j] 表示：容量维 j 的背包，所背的物品价值最大为 dp[j]，<strong>倒序遍历是为了保证物品 i 只被放入一次！</strong></li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// 初始化</span><br><span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">dp</span><span class="hljs-params">(bagWeight + <span class="hljs-number">1</span>, <span class="hljs-number">0</span>)</span></span>;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; weight.<span class="hljs-built_in">size</span>(); i++) &#123; <span class="hljs-comment">// 遍历物品</span><br>  <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = bagWeight; j &gt;= weight[i]; j--) &#123; <span class="hljs-comment">// 遍历背包容量</span><br>      dp[j] = <span class="hljs-built_in">max</span>(dp[j], dp[j - weight[i]] + value[i]);<br>  &#125;<br>&#125;<br>cout &lt;&lt; dp[bagWeight] &lt;&lt; endl;<br></code></pre></td></tr></table></figure><ul><li><code>dp[i]</code>表示不放物体，相当于<code>dp[i-1][j]</code>，不放物体 i，<code>dp[j - weight[i]] + value[i]</code>表示放物体 i，为放物体前容量的最大价值 + 物体 i 的价值。</li><li>为什么第二次循环<code>j&gt;=weight[i]</code>，因为<code>dp[j - weight[i]]</code>表示放物体前的容量，不能为负数，考虑能放下的情况，放还是不放；对于不能放下就默认等于上一次值，不考虑。</li><li>注意第二重<strong>循环 j 初始值</strong>，为 dp 容量最大值。</li></ul><p><strong>完全背包问题</strong></p><ul><li>每件物品无限件，可重复放入背包。</li><li><strong>内循环 从小到大遍历，因为每件物品添加多次</strong>。</li><li>滚动数组为了取代二维数组，但<strong>内循环一般是倒序</strong>的，防止重复选取，<strong>而完全背包是正序的</strong></li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// 先遍历物品，在遍历背包</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">test_CompletePack</span><span class="hljs-params">()</span> </span>&#123;<br>    vector&lt;<span class="hljs-type">int</span>&gt; weight = &#123;<span class="hljs-number">1</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>&#125;;<br>    vector&lt;<span class="hljs-type">int</span>&gt; value = &#123;<span class="hljs-number">15</span>, <span class="hljs-number">20</span>, <span class="hljs-number">30</span>&#125;;<br>    <span class="hljs-type">int</span> bagWeight = <span class="hljs-number">4</span>;<br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">dp</span><span class="hljs-params">(bagWeight + <span class="hljs-number">1</span>, <span class="hljs-number">0</span>)</span></span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; weight.<span class="hljs-built_in">size</span>(); i++) &#123; <span class="hljs-comment">// 遍历物品</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = weight[i]; j &lt;= bagWeight; j++) &#123; <span class="hljs-comment">// 遍历背包容量</span><br>            dp[j] = <span class="hljs-built_in">max</span>(dp[j], dp[j - weight[i]] + value[i]);<br>        &#125;<br>    &#125;<br>    cout &lt;&lt; dp[bagWeight] &lt;&lt; endl;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>最长递增子序列(不连续)</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// 给你一个整数数组 nums ，找到其中最长严格递增子序列的长度。子序列是由数组派生而来的序列，删除（或不删除）数组中的元素而不改变其余元素的顺序。</span><br><br><span class="hljs-comment">// dp[i]表示i之前包括i的以nums[i]结尾的最长递增子序列的长度，做 递增比较的时候，如果比较 nums[j] 和 nums[i] 的大小，那么两个递增子序列一定分别以nums[j]为结尾 和 nums[i]为结尾， 要不然这个比较就没有意义了，不是尾部元素的比较那么 如何算递增呢。</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">lengthOfLIS</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (nums.<span class="hljs-built_in">size</span>() &lt;= <span class="hljs-number">1</span>) <span class="hljs-keyword">return</span> nums.<span class="hljs-built_in">size</span>();<br>        <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">dp</span><span class="hljs-params">(nums.size(), <span class="hljs-number">1</span>)</span></span>;<br>        <span class="hljs-type">int</span> result = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt; nums.<span class="hljs-built_in">size</span>(); i++) &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; i; j++) &#123;<br>                <span class="hljs-keyword">if</span> (nums[i] &gt; nums[j]) dp[i] = <span class="hljs-built_in">max</span>(dp[i], dp[j] + <span class="hljs-number">1</span>);<br>            &#125;<br>            <span class="hljs-keyword">if</span> (dp[i] &gt; result) result = dp[i]; <span class="hljs-comment">// 取长的子序列</span><br>        &#125;<br>        <span class="hljs-keyword">return</span> result;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p><strong>最长重复子数组(连续)</strong></p><ul><li><code>dp[i][j]</code>：A 的前 i 个元素，B 的前 j 个元素，最长重复子数组<strong>长度</strong>为<code>dp[i][j]</code>。</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// 给两个整数数组 A 和 B ，返回两个数组中公共的、长度最长的子数组的长度。</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">findLength</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums1, vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums2)</span> </span>&#123;<br>        vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">dp</span> (nums1.<span class="hljs-built_in">size</span>() + <span class="hljs-number">1</span>, <span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">int</span>&gt;(nums2.<span class="hljs-built_in">size</span>() + <span class="hljs-number">1</span>, <span class="hljs-number">0</span>));<br>        <span class="hljs-type">int</span> result = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= nums1.<span class="hljs-built_in">size</span>(); i++) &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">1</span>; j &lt;= nums2.<span class="hljs-built_in">size</span>(); j++) &#123;<br>                <span class="hljs-keyword">if</span> (nums1[i - <span class="hljs-number">1</span>] == nums2[j - <span class="hljs-number">1</span>]) &#123;<br>                    dp[i][j] = dp[i - <span class="hljs-number">1</span>][j - <span class="hljs-number">1</span>] + <span class="hljs-number">1</span>;<br>                &#125;<br>                <span class="hljs-keyword">if</span> (dp[i][j] &gt; result) result = dp[i][j];<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> result;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p><strong>最长公共子序列(不连续)</strong></p><ul><li><code>dp[i][j]</code>：A 的前 i 个元素，B 的前 j 个元素，最长重复子数组<strong>长度</strong>为<code>dp[i][j]</code>。</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// 给定两个字符串 text1 和 text2，返回这两个字符串的最长公共子序列的长度。</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>  <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">longestCommonSubsequence</span><span class="hljs-params">(string text1, string text2)</span> </span>&#123;<br>      vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">dp</span>(text1.<span class="hljs-built_in">size</span>()+<span class="hljs-number">1</span>,<span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">int</span>&gt;(text2.<span class="hljs-built_in">size</span>()+<span class="hljs-number">1</span>,<span class="hljs-number">0</span>));<br>      <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=text1.<span class="hljs-built_in">size</span>();i++)&#123;<br>          <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">1</span>;j&lt;=text2.<span class="hljs-built_in">size</span>();j++)&#123;<br>              <span class="hljs-keyword">if</span>(text1[i<span class="hljs-number">-1</span>] == text2[j<span class="hljs-number">-1</span>])&#123;<br>                  dp[i][j] = dp[i<span class="hljs-number">-1</span>][j<span class="hljs-number">-1</span>] + <span class="hljs-number">1</span>;<br>              &#125;<span class="hljs-keyword">else</span>&#123;<br>                  dp[i][j] = <span class="hljs-built_in">max</span>(dp[i<span class="hljs-number">-1</span>][j],dp[i][j<span class="hljs-number">-1</span>]);<br>              &#125;<br>          &#125;<br>      &#125;<br>      <span class="hljs-keyword">return</span> dp[text1.<span class="hljs-built_in">size</span>()][text2.<span class="hljs-built_in">size</span>()];<br>  &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p><strong>不同的子序列</strong></p><ul><li><code>dp[i][j]</code>：以 i-1 为结尾的 s 子序列中出现以 j-1 为结尾的 t 的个数为<code>dp[i][j]</code>。</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// 给定一个字符串 s 和一个字符串 t ，计算在 s 的子序列中 t 出现的个数。</span><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">numDistinct</span><span class="hljs-params">(string s, string t)</span> </span>&#123;<br>        vector&lt;vector&lt;<span class="hljs-type">uint64_t</span>&gt;&gt; <span class="hljs-built_in">dp</span>(s.<span class="hljs-built_in">size</span>() + <span class="hljs-number">1</span>, <span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">uint64_t</span>&gt;(t.<span class="hljs-built_in">size</span>() + <span class="hljs-number">1</span>));<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; s.<span class="hljs-built_in">size</span>(); i++) dp[i][<span class="hljs-number">0</span>] = <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">1</span>; j &lt; t.<span class="hljs-built_in">size</span>(); j++) dp[<span class="hljs-number">0</span>][j] = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= s.<span class="hljs-built_in">size</span>(); i++) &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">1</span>; j &lt;= t.<span class="hljs-built_in">size</span>(); j++) &#123;<br>                <span class="hljs-keyword">if</span> (s[i - <span class="hljs-number">1</span>] == t[j - <span class="hljs-number">1</span>]) &#123;<br>                    dp[i][j] = dp[i - <span class="hljs-number">1</span>][j - <span class="hljs-number">1</span>] + dp[i - <span class="hljs-number">1</span>][j];<br>                &#125; <span class="hljs-keyword">else</span> &#123;<br>                    dp[i][j] = dp[i - <span class="hljs-number">1</span>][j];<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> dp[s.<span class="hljs-built_in">size</span>()][t.<span class="hljs-built_in">size</span>()];<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p>这一类问题，基本是要分析两种情况</p><ol><li>s[i-1] 与 t[j-1]相等:<ul><li>用 s[i-1]来匹配，那么个数为<code>dp[i-1][j-1]</code>。即不需要考虑当前 s 子串和 t 子串的最后一位字母，所以只需要 <code>dp[i-1][j-1]</code>。</li><li>不用 s[i-1]来匹配，个数为<code>dp[i-1][j]</code>。</li></ul></li><li>s[i-1] 与 t[j-1] 不相等:<ul><li><code>dp[i][j]</code>只有一部分组成，不用 s[i-1]来匹配（就是模拟在 s 中删除这个元素）</li></ul></li></ol><p><strong>两个字符串的删除操作</strong></p><p><code>dp[i][j]</code>：A 的前 i 个元素，B 的前 j 个元素，想要相等时，所需要删除的最少次数。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// 给定两个单词 word1 和 word2，找到使得 word1 和 word2 相同所需的最小步数，每步可以删除任意一个字符串中的一个字符。</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">minDistance</span><span class="hljs-params">(string word1, string word2)</span> </span>&#123;<br>        vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">dp</span>(word1.<span class="hljs-built_in">size</span>() + <span class="hljs-number">1</span>, <span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">int</span>&gt;(word2.<span class="hljs-built_in">size</span>() + <span class="hljs-number">1</span>));<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt;= word1.<span class="hljs-built_in">size</span>(); i++) dp[i][<span class="hljs-number">0</span>] = i;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt;= word2.<span class="hljs-built_in">size</span>(); j++) dp[<span class="hljs-number">0</span>][j] = j;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= word1.<span class="hljs-built_in">size</span>(); i++) &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">1</span>; j &lt;= word2.<span class="hljs-built_in">size</span>(); j++) &#123;<br>                <span class="hljs-keyword">if</span> (word1[i - <span class="hljs-number">1</span>] == word2[j - <span class="hljs-number">1</span>]) &#123;<br>                    dp[i][j] = dp[i - <span class="hljs-number">1</span>][j - <span class="hljs-number">1</span>];<br>                &#125; <span class="hljs-keyword">else</span> &#123;<br>                    dp[i][j] = <span class="hljs-built_in">min</span>(dp[i - <span class="hljs-number">1</span>][j] + <span class="hljs-number">1</span>, dp[i][j - <span class="hljs-number">1</span>] + <span class="hljs-number">1</span>);<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> dp[word1.<span class="hljs-built_in">size</span>()][word2.<span class="hljs-built_in">size</span>()];<br>    &#125;<br>&#125;;<br><br></code></pre></td></tr></table></figure><h3 id="单调栈"><a href="#单调栈" class="headerlink" title="单调栈"></a>单调栈</h3><p>通常是<strong>一维数组</strong>，要寻找任一个元素的右边或者左边第一个比自己大或者小的元素的位置，此时我们就要想到可以用单调栈了</p><p><strong>单调栈的本质是空间换时间</strong>，因为在遍历的过程中需要用一个栈来记录右边第一个比当前元素高的元素，优点是整个数组只需要遍历一次。</p><p><strong>更直白来说，就是用一个栈来记录我们遍历过的元素</strong>，因为我们遍历数组的时候，我们不知道之前都遍历了哪些元素，以至于遍历一个元素找不到是不是之前遍历过一个更小的，所以我们需要用一个容器（这里用单调栈）来记录我们遍历过的元素。</p><p><strong>接雨水</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// 给定 n 个非负整数表示每个宽度为 1 的柱子的高度图，计算按此排列的柱子，下雨之后能接多少雨水。</span><br><br><span class="hljs-comment">// 暴力解法</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">trap</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; height)</span> </span>&#123;<br>        <span class="hljs-type">int</span> sum = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; height.<span class="hljs-built_in">size</span>(); i++) &#123;<br>            <span class="hljs-comment">// 第一个柱子和最后一个柱子不接雨水</span><br>            <span class="hljs-keyword">if</span> (i == <span class="hljs-number">0</span> || i == height.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>) <span class="hljs-keyword">continue</span>;<br><br>            <span class="hljs-type">int</span> rHeight = height[i]; <span class="hljs-comment">// 记录右边柱子的最高高度</span><br>            <span class="hljs-type">int</span> lHeight = height[i]; <span class="hljs-comment">// 记录左边柱子的最高高度</span><br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> r = i + <span class="hljs-number">1</span>; r &lt; height.<span class="hljs-built_in">size</span>(); r++) &#123;<br>                <span class="hljs-keyword">if</span> (height[r] &gt; rHeight) rHeight = height[r];<br>            &#125;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> l = i - <span class="hljs-number">1</span>; l &gt;= <span class="hljs-number">0</span>; l--) &#123;<br>                <span class="hljs-keyword">if</span> (height[l] &gt; lHeight) lHeight = height[l];<br>            &#125;<br>            <span class="hljs-type">int</span> h = <span class="hljs-built_in">min</span>(lHeight, rHeight) - height[i];<br>            <span class="hljs-keyword">if</span> (h &gt; <span class="hljs-number">0</span>) sum += h;<br>        &#125;<br>        <span class="hljs-keyword">return</span> sum;<br>    &#125;<br>&#125;;<br><br><span class="hljs-comment">// 单调栈</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">trap</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; height)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (height.<span class="hljs-built_in">size</span>() &lt;= <span class="hljs-number">2</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>; <span class="hljs-comment">// 可以不加</span><br>        stack&lt;<span class="hljs-type">int</span>&gt; st; <span class="hljs-comment">// 存着下标，计算的时候用下标对应的柱子高度</span><br>        st.<span class="hljs-built_in">push</span>(<span class="hljs-number">0</span>);<br>        <span class="hljs-type">int</span> sum = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt; height.<span class="hljs-built_in">size</span>(); i++) &#123;<br>            <span class="hljs-keyword">if</span> (height[i] &lt; height[st.<span class="hljs-built_in">top</span>()]) &#123;     <span class="hljs-comment">// 情况一</span><br>                st.<span class="hljs-built_in">push</span>(i);<br>            &#125; <span class="hljs-keyword">if</span> (height[i] == height[st.<span class="hljs-built_in">top</span>()]) &#123;  <span class="hljs-comment">// 情况二</span><br>                st.<span class="hljs-built_in">pop</span>(); <span class="hljs-comment">// 其实这一句可以不加，效果是一样的，但处理相同的情况的思路却变了。</span><br>                st.<span class="hljs-built_in">push</span>(i);<br>            &#125; <span class="hljs-keyword">else</span> &#123;                                <span class="hljs-comment">// 情况三</span><br>                <span class="hljs-keyword">while</span> (!st.<span class="hljs-built_in">empty</span>() &amp;&amp; height[i] &gt; height[st.<span class="hljs-built_in">top</span>()]) &#123;<br>                    <span class="hljs-type">int</span> mid = st.<span class="hljs-built_in">top</span>();<br>                    st.<span class="hljs-built_in">pop</span>();<br>                    <span class="hljs-keyword">if</span> (!st.<span class="hljs-built_in">empty</span>()) &#123;<br>                        <span class="hljs-type">int</span> h = <span class="hljs-built_in">min</span>(height[st.<span class="hljs-built_in">top</span>()], height[i]) - height[mid];<br>                        <span class="hljs-type">int</span> w = i - st.<span class="hljs-built_in">top</span>() - <span class="hljs-number">1</span>; <span class="hljs-comment">// 注意减一，只求中间宽度</span><br>                        sum += h * w;<br>                    &#125;<br>                &#125;<br>                st.<span class="hljs-built_in">push</span>(i);<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> sum;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="进制转换"><a href="#进制转换" class="headerlink" title="进制转换"></a>进制转换</h3><p>利用 bitset 进行任意进制转二进制</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// stol() 第二个参数默认为 NULL，第三个默认 10 进制，可 8/16 进制</span><br><span class="hljs-function">bitset&lt;16&gt; <span class="hljs-title">bin</span><span class="hljs-params">(stol(t, <span class="hljs-literal">nullptr</span>, <span class="hljs-number">16</span>))</span></span>;   先转为 <span class="hljs-type">long</span>，通过 bitset 转为二进制 <span class="hljs-number">16</span> 位<br>string s = bin.<span class="hljs-built_in">to_string</span>();<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>刷题笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>cpp</tag>
      
      <tag>note</tag>
      
      <tag>algorithm</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>cpp 刷题笔记</title>
    <link href="/cpp%E5%88%B7%E9%A2%98%E7%AC%94%E8%AE%B0.html"/>
    <url>/cpp%E5%88%B7%E9%A2%98%E7%AC%94%E8%AE%B0.html</url>
    
    <content type="html"><![CDATA[<h3 id="基本数据"><a href="#基本数据" class="headerlink" title="基本数据"></a>基本数据</h3><table><thead><tr><th align="left">Type</th><th align="left">Size</th><th align="left">Range</th></tr></thead><tbody><tr><td align="left">char</td><td align="left">1byte</td><td align="left">-127 ~ 127</td></tr><tr><td align="left">short</td><td align="left">2bytes</td><td align="left">-32,768 ~ 32,767</td></tr><tr><td align="left">int</td><td align="left">4bytes</td><td align="left">-2,147,483,648 ~ 2,147,483,647</td></tr><tr><td align="left">long</td><td align="left">8bytes</td><td align="left">-2,147,483,648 ~ 2,147,483,647</td></tr><tr><td align="left">float</td><td align="left">4bytes</td><td align="left">-2^128 ~ 2^128</td></tr><tr><td align="left">double</td><td align="left">8bytes</td><td align="left">-2^1024 ~ 2^1024</td></tr></tbody></table><h3 id="string-x2F-char"><a href="#string-x2F-char" class="headerlink" title="string&#x2F;char"></a>string&#x2F;char</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string&gt;</span></span><br><br>string s;<br>string s&#123;<span class="hljs-string">&quot;hello&quot;</span>&#125;;<br><br><span class="hljs-comment">// 常用function</span><br>s.<span class="hljs-built_in">clear</span>();<br>s.<span class="hljs-built_in">empty</span>();<br><br>s1.<span class="hljs-built_in">append</span>(s2); <span class="hljs-comment">// 字符串连接</span><br><br>s1.<span class="hljs-built_in">swap</span>(s2); <span class="hljs-comment">// 字符串交换：</span><br><br>s.<span class="hljs-built_in">size</span>(); <span class="hljs-comment">// 二者没有任何区别</span><br>s.<span class="hljs-built_in">length</span>();<br><br>s.<span class="hljs-built_in">count</span>(s.<span class="hljs-built_in">begin</span>(), s.<span class="hljs-built_in">end</span>(), <span class="hljs-type">char</span>); <span class="hljs-comment">// 计算范围内char出现的次数</span><br><br>s1.<span class="hljs-built_in">find</span>(sub_s，pos); <span class="hljs-comment">// 从下标pos开始，返回字符串 b 在 s 中的下标，找不到返回-1</span><br><br><span class="hljs-built_in">reverse</span>(s.<span class="hljs-built_in">begin</span>(), s.<span class="hljs-built_in">end</span>()); <span class="hljs-comment">// 字串反转(无返回值)</span><br>s = <span class="hljs-built_in">string</span>(s.<span class="hljs-built_in">rbegin</span>(), s.<span class="hljs-built_in">rend</span>()); <span class="hljs-comment">// 使用iterator来反转，产生一个新的字串</span><br><br>s = s.<span class="hljs-built_in">replace</span>(s.<span class="hljs-built_in">find</span>(<span class="hljs-string">&quot;a&quot;</span>),<span class="hljs-number">2</span>,<span class="hljs-string">&quot;####&quot;</span>); <span class="hljs-comment">//替换 把 &quot;abc&quot; 换成 &quot;####c&quot;</span><br><br>s.<span class="hljs-built_in">push_back</span>();<br>s.<span class="hljs-built_in">pop_back</span>();<br><br>string s = s1 + s2;<br><br>string sub = s2.<span class="hljs-built_in">substr</span>(pos, len); <span class="hljs-comment">//从pos开始取len长度</span><br>string sub2 = s2.<span class="hljs-built_in">substr</span>(pos); <span class="hljs-comment">// 从pos开始到最后</span><br><br><span class="hljs-comment">// 移除string中某个char</span><br>str.<span class="hljs-built_in">erase</span>(<span class="hljs-built_in">remove</span>(str.<span class="hljs-built_in">begin</span>(), str.<span class="hljs-built_in">end</span>(), <span class="hljs-string">&#x27;.&#x27;</span>), str.<span class="hljs-built_in">end</span>());<br><br><span class="hljs-comment">// 计算某个char出现的次数</span><br><span class="hljs-built_in">count</span>(str.<span class="hljs-built_in">begin</span>(), str.<span class="hljs-built_in">end</span>(), <span class="hljs-string">&#x27;.&#x27;</span>);<br><br>str.<span class="hljs-built_in">erase</span>(intdex_start, n);<span class="hljs-comment">// 从start位置起删除 n 个字符</span><br>str.<span class="hljs-built_in">erase</span>(str.<span class="hljs-built_in">begin</span>() + offset); <span class="hljs-comment">// 移除begin开始第offset个char</span><br>str.<span class="hljs-built_in">erase</span>(str.<span class="hljs-built_in">begin</span>(), str.<span class="hljs-built_in">begin</span>() + <span class="hljs-number">3</span>); <span class="hljs-comment">// 移除前3个char</span><br><br><span class="hljs-comment">// 判断函式</span><br><span class="hljs-built_in">isalpha</span>(c);    <span class="hljs-comment">// 是否为字母 &#x27;a&#x27;~&#x27;z&#x27; &#x27;A&#x27;~&#x27;Z&#x27;</span><br><span class="hljs-built_in">isdigit</span>(c);    <span class="hljs-comment">// 是否为数字 &#x27;0&#x27;~&#x27;9&#x27;</span><br><span class="hljs-built_in">isalnum</span>(c);    <span class="hljs-comment">// 是否为字母和数字</span><br><span class="hljs-built_in">islower</span>(c);    <span class="hljs-comment">// 是否为小写 &#x27;a&#x27; ~ &#x27;z&#x27;</span><br><span class="hljs-built_in">isupper</span>(c);    <span class="hljs-comment">// 是否为大写 &#x27;A&#x27; ~ &#x27;Z&#x27;</span><br><span class="hljs-built_in">isspace</span>(c);    <span class="hljs-comment">// 是否为space</span><br><br><span class="hljs-comment">// 转换成大写或小写</span><br><span class="hljs-built_in">toupper</span>(c);<br><span class="hljs-built_in">tolower</span>(c);<br><br><span class="hljs-comment">// string 和 int 互转</span><br><span class="hljs-type">int</span> i = <span class="hljs-built_in">stoi</span>(str);<br>string s = <span class="hljs-built_in">to_string</span>(val);<br></code></pre></td></tr></table></figure><h3 id="vector"><a href="#vector" class="headerlink" title="vector"></a>vector</h3><ul><li>随机存取</li><li>集合尾端增删元素很快 : O(1)</li><li>集合中间增删元素比较费时 : O(n)，可以先 swap 要删除的值到最后，然后再删除。</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;vector&gt;</span></span><br><br><span class="hljs-comment">// 定义并初始化</span><br>vector&lt;T&gt; v;<br><span class="hljs-function">vector&lt;T&gt; <span class="hljs-title">v</span><span class="hljs-params">(n)</span></span>;<br><span class="hljs-function">vector&lt;T&gt; <span class="hljs-title">sub</span><span class="hljs-params">(v.begin(), v.begin() + <span class="hljs-number">5</span>)</span></span>; <span class="hljs-comment">// subvector</span><br><span class="hljs-function">vector&lt;T&gt; <span class="hljs-title">v</span><span class="hljs-params">(s.begin(), s.end())</span></span>;<br>vector&lt;vector&lt;T&gt;&gt; <span class="hljs-built_in">v_2d</span>(n, <span class="hljs-built_in">vector</span>&lt;T&gt;(m，<span class="hljs-number">0</span>));<br><br><span class="hljs-comment">// 常用function</span><br>v.<span class="hljs-built_in">empty</span>();<br><br>v.<span class="hljs-built_in">size</span>();<br><br>v.<span class="hljs-built_in">front</span>();<br>v.<span class="hljs-built_in">back</span>();<br><br>v.<span class="hljs-built_in">push_back</span>();<br>v.<span class="hljs-built_in">emplace_back</span>(); <span class="hljs-comment">// 如果用这个construct obj则可以减少copy或是move</span><br><br>v.<span class="hljs-built_in">pop_back</span>();<br><br>v.<span class="hljs-built_in">insert</span>();      <span class="hljs-comment">// 插入到指定位置</span><br>v.<span class="hljs-built_in">insert</span>(v.<span class="hljs-built_in">begin</span>(), target) <span class="hljs-comment">// 加入target到最前面</span><br>v.<span class="hljs-built_in">insert</span>(v.<span class="hljs-built_in">begin</span>() + n, target) <span class="hljs-comment">// 加入taret到任意位置, n &lt;= v.size()</span><br><br>v.<span class="hljs-built_in">erase</span>();       <span class="hljs-comment">// 移除某个指定位置element</span><br><br><span class="hljs-built_in">swap</span>(v[n], v.<span class="hljs-built_in">back</span>()); <span class="hljs-comment">// 交换n和最后一个位置后删除，改变顺序</span><br>v.<span class="hljs-built_in">pop_back</span>();<br><br>v.<span class="hljs-built_in">clear</span>();       <span class="hljs-comment">// 清除全部element</span><br><br>v.<span class="hljs-built_in">count</span>(v.<span class="hljs-built_in">begin</span>(), v.<span class="hljs-built_in">end</span>(), val); <span class="hljs-comment">// 计算范围内val出现的次数</span><br><br><span class="hljs-keyword">auto</span> it = <span class="hljs-built_in">find</span>(v.<span class="hljs-built_in">begin</span>(), v.<span class="hljs-built_in">end</span>(), val); <span class="hljs-comment">// 寻找第一个val出现的位置，返回迭代器</span><br><br><span class="hljs-built_in">reverse</span>(v.<span class="hljs-built_in">begin</span>(), v.<span class="hljs-built_in">end</span>())<br><br>v1.<span class="hljs-built_in">insert</span>(v1.<span class="hljs-built_in">end</span>(), v2.<span class="hljs-built_in">begin</span>(), v2.<span class="hljs-built_in">end</span>()); <span class="hljs-comment">// 把 v2 插入 v1 的尾部</span><br><br>v.<span class="hljs-built_in">resize</span>(n, <span class="hljs-number">-1</span>); <span class="hljs-comment">// 重新调整大小为n，新添加的元素为-1</span><br><br><span class="hljs-comment">// Traversal</span><br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; v.<span class="hljs-built_in">size</span>(); ++i) &#123;<br>    cout &lt;&lt; v[i] &lt;&lt; endl;<br>&#125;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">const</span> <span class="hljs-keyword">auto</span>&amp; i : v) &#123;<br>    cout &lt;&lt; i &lt;&lt; endl;<br>&#125;<br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> it = v.<span class="hljs-built_in">begin</span>(); it != v.<span class="hljs-built_in">end</span>(); ++it) &#123;<br>    cout &lt;&lt; *it &lt;&lt; endl;<br>&#125;<br><br><span class="hljs-comment">// accumulate 累加求和</span><br><span class="hljs-built_in">accumulate</span>(v.<span class="hljs-built_in">begin</span>(), v.<span class="hljs-built_in">end</span>(), bias); <span class="hljs-comment">// 累加初值，默认bias = 0</span><br><span class="hljs-built_in">accumulate</span>(v.<span class="hljs-built_in">begin</span>(), v.<span class="hljs-built_in">end</span>(), <span class="hljs-number">0l</span>); <span class="hljs-comment">// 避免overflow，可以使用long来相加。</span><br><br><span class="hljs-comment">// 使用lambda，当val为偶数才相加</span><br><span class="hljs-built_in">accumulate</span>(<span class="hljs-built_in">begin</span>(v), <span class="hljs-built_in">end</span>(v), bias, [](<span class="hljs-type">int</span>&amp; sum, <span class="hljs-type">int</span> val)&#123;<br>   <span class="hljs-keyword">return</span> sum + (val % <span class="hljs-number">2</span> == <span class="hljs-number">0</span> ? val : <span class="hljs-number">0</span>);<br>&#125;);<br><br><span class="hljs-built_in">fill</span>(v.<span class="hljs-built_in">begin</span>(), v.<span class="hljs-built_in">end</span>(), val);  <span class="hljs-comment">// 将一个区间的元素都赋予val值</span><br></code></pre></td></tr></table></figure><h3 id="list"><a href="#list" class="headerlink" title="list"></a>list</h3><ul><li>使用双链表实现，所以移动删除都是 O(1)</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs cpp"> <span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;list&gt;</span></span><br><br>list&lt;<span class="hljs-type">int</span>&gt; l;<br><br><span class="hljs-comment">// 常用function</span><br>l.<span class="hljs-built_in">empty</span>();<br>l.<span class="hljs-built_in">size</span>();<br>l.<span class="hljs-built_in">push_back</span>();<br>l.<span class="hljs-built_in">pop_back</span>();<br>l.<span class="hljs-built_in">push_front</span>(); <span class="hljs-comment">// 开头添加结点</span><br>l.<span class="hljs-built_in">pop_front</span>();<span class="hljs-comment">// 开头删除结点</span><br><br><span class="hljs-comment">//将一个list中的值移到另一个list中</span><br>l.<span class="hljs-built_in">splice</span>(iterator pos, list&amp; x); <span class="hljs-comment">// 把x所有的element接到l中pos的位置。</span><br>l.<span class="hljs-built_in">splice</span> (iterator pos, list&amp; x, iterator i); <span class="hljs-comment">// 把i单一个element从x中搬移到l中pos的位置。</span><br>l.<span class="hljs-built_in">splice</span> (iterator pos, list&amp; x, iterator first, iterator last); <span class="hljs-comment">// 把x中从first到last的element搬到l中pos的位置。</span><br></code></pre></td></tr></table></figure><h3 id="stack"><a href="#stack" class="headerlink" title="stack"></a>stack</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stack&gt;</span></span><br><br>stack&lt;T&gt; s;<br><br><span class="hljs-comment">// 常用function</span><br>s.<span class="hljs-built_in">empty</span>();<br>s.<span class="hljs-built_in">size</span>();<br>s.<span class="hljs-built_in">push</span>();<br>s.<span class="hljs-built_in">pop</span>();<br>s.<span class="hljs-built_in">top</span>();<br></code></pre></td></tr></table></figure><h3 id="queue"><a href="#queue" class="headerlink" title="queue"></a>queue</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;queue&gt;</span></span><br><br>queue&lt;T&gt; q;<br><br><span class="hljs-comment">// 常用function</span><br>q.<span class="hljs-built_in">empty</span>();<br>q.<span class="hljs-built_in">size</span>();<br>q.<span class="hljs-built_in">push</span>(); <span class="hljs-comment">// 队尾加入</span><br>q.<span class="hljs-built_in">pop</span>();  <span class="hljs-comment">// 队首删除</span><br>q.<span class="hljs-built_in">front</span>(); <span class="hljs-comment">// 队首元素</span><br></code></pre></td></tr></table></figure><h3 id="deque"><a href="#deque" class="headerlink" title="deque"></a>deque</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;deque&gt;</span></span><br><br>deque&lt;T&gt; dq;<br><span class="hljs-function">deque&lt;T&gt; <span class="hljs-title">dq</span><span class="hljs-params">(v.begin(), v.end())</span></span>; <span class="hljs-comment">// 把vector放入deque</span><br><br><span class="hljs-comment">// 常用function</span><br>dq.<span class="hljs-built_in">empty</span>();<br>dq.<span class="hljs-built_in">size</span>();<br>dq.<span class="hljs-built_in">push_front</span>();<br>dq.<span class="hljs-built_in">push_back</span>();<br>dq.<span class="hljs-built_in">pop_front</span>();<br>dq.<span class="hljs-built_in">pop_back</span>();<br>dq.<span class="hljs-built_in">front</span>(); <span class="hljs-comment">// 取得目前 deque 中最前端元素</span><br>dq.<span class="hljs-built_in">back</span>(); <span class="hljs-comment">// 取得目前 deque 中最后端元素</span><br><br><span class="hljs-comment">// 自定义比较函数，逆序</span><br><span class="hljs-keyword">auto</span> cmp = [](<span class="hljs-type">int</span>&amp; a, <span class="hljs-type">int</span>&amp; b) &#123;<br>    <span class="hljs-keyword">return</span> a &gt; b;<br>&#125;<br>priority_queue&lt;<span class="hljs-type">int</span>, vector&lt;<span class="hljs-type">int</span>&gt;, <span class="hljs-keyword">decltype</span>(cmp)&gt; <span class="hljs-built_in">pq</span>(cmp);<br></code></pre></td></tr></table></figure><h3 id="priority-queue"><a href="#priority-queue" class="headerlink" title="priority_queue"></a>priority_queue</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;queue&gt;</span></span><br><br>priority_queue&lt;T&gt; pq;    <span class="hljs-comment">// 优先队列默认是一个最大堆，每次输出的堆顶元素是此时堆中的最大元素</span><br>priority_queue&lt;T, vector&lt;T&gt;, less&lt;T&gt;&gt; pq； <span class="hljs-comment">// 大顶堆（默认）</span><br>priority_queue&lt;T, vector&lt;T&gt;, greater&lt;T&gt;&gt; pq;  <span class="hljs-comment">// 小顶堆</span><br><br><span class="hljs-comment">// 小顶堆，默认先按 first 排序，再按 second 排序（堆优化 Dijkstra）</span><br>priority_queue&lt;pair&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt;, vector&lt;pair&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt;&gt;, greater&lt;pair&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt;&gt;&gt; pq;<br><br><span class="hljs-comment">// 常用function</span><br>pq.<span class="hljs-built_in">empty</span>();<br>pq.<span class="hljs-built_in">size</span>();<br>pq.<span class="hljs-built_in">push</span>();<br>pq.<span class="hljs-built_in">pop</span>();<br>pq.<span class="hljs-built_in">top</span>();<br><br><span class="hljs-comment">// 自定义compare function</span><br><span class="hljs-comment">// 方法一：decltype()，用于获得函数指针的类型</span><br><span class="hljs-keyword">auto</span> cmp = [](<span class="hljs-type">int</span>&amp; a, <span class="hljs-type">int</span>&amp; b) &#123;<br>        <span class="hljs-keyword">return</span> a &gt; b;<br>&#125;;<br>priority_queue&lt;<span class="hljs-type">int</span>, vector&lt;<span class="hljs-type">int</span>&gt;, <span class="hljs-keyword">decltype</span>(cmp)&gt; <span class="hljs-built_in">pq</span>(cmp);  <span class="hljs-comment">// 小顶堆</span><br><br><span class="hljs-comment">// 方法二：class重载运算符</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">cmp</span>&#123;<br><span class="hljs-keyword">public</span>:<br>  <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">operator</span><span class="hljs-params">()</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp;a,vector&lt;<span class="hljs-type">int</span>&gt;&amp;b)</span></span>&#123;<br>      <span class="hljs-keyword">return</span> a[<span class="hljs-number">0</span>]&gt;b[<span class="hljs-number">0</span>];<br>  &#125;<br>&#125;;<br>priority_queue&lt;vector&lt;<span class="hljs-type">int</span>&gt;,vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt;,cmp&gt; q;  <span class="hljs-comment">// 小顶堆</span><br><br><span class="hljs-comment">// 方法三：自定义比较结构体 struct</span><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">cmp</span> &#123;<br>   <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">operator</span><span class="hljs-params">()</span><span class="hljs-params">(pair&lt;<span class="hljs-type">int</span>,<span class="hljs-type">int</span>&gt;&amp; a,pair&lt;<span class="hljs-type">int</span>,<span class="hljs-type">int</span>&gt;&amp; b)</span></span>&#123;<br>       <span class="hljs-keyword">return</span> a.second &gt; b.second;<br>  &#125;<br>&#125;;<br>priority_queue&lt;pair&lt;<span class="hljs-type">int</span>,<span class="hljs-type">int</span>&gt;, vector&lt;pair&lt;<span class="hljs-type">int</span>,<span class="hljs-type">int</span>&gt;&gt;, cmp&gt; q;<br></code></pre></td></tr></table></figure><h3 id="set-x2F-unordered-set"><a href="#set-x2F-unordered-set" class="headerlink" title="set&#x2F;unordered_set"></a>set&#x2F;unordered_set</h3><ul><li>set 默认有序</li><li>set 元素唯一</li><li>unordered_set 无序集合</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;set&gt;</span></span><br><br>set&lt;T&gt; s;<br>set&lt;T&gt; s&#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>&#125;;<br><span class="hljs-function">set&lt;T&gt; <span class="hljs-title">s</span><span class="hljs-params">(vector&lt;T&gt;)</span></span>;<br><br>set&lt;T,greater&lt;T&gt;&gt; s; <span class="hljs-comment">// 从大到小</span><br><br><span class="hljs-comment">// 常用function</span><br>s.<span class="hljs-built_in">empty</span>();<br>s.<span class="hljs-built_in">size</span>();<br><br>s.<span class="hljs-built_in">insert</span>();<br><span class="hljs-keyword">auto</span> it = s.<span class="hljs-built_in">insert</span>(val); <span class="hljs-comment">// 可以取得insert之后的位置</span><br><br>s.<span class="hljs-built_in">erase</span>(key);    <span class="hljs-comment">// 传入key或iterator</span><br>s.<span class="hljs-built_in">erase</span>(s.<span class="hljs-built_in">find</span>(value));<br><br>s.<span class="hljs-built_in">clear</span>();<br><br>s.<span class="hljs-built_in">count</span>(); <span class="hljs-comment">// 返回1/0</span><br><br>s.<span class="hljs-built_in">find</span>(); <span class="hljs-comment">// 返回iterator，所以还要判断使否是s.end();</span><br><br><span class="hljs-comment">// set 和 vector 互转</span><br><span class="hljs-function">vector&lt;T&gt; <span class="hljs-title">v</span><span class="hljs-params">(s.begin(), s.end())</span></span>;<br><span class="hljs-function">set&lt;T&gt; <span class="hljs-title">s</span><span class="hljs-params">(vector.begin(), vector.end())</span></span>;<br><br><span class="hljs-comment">// Traversal</span><br><span class="hljs-keyword">for</span>(<span class="hljs-type">const</span> <span class="hljs-keyword">auto</span>&amp; item : s) &#123;<br>    cout &lt;&lt; item &lt;&lt; endl;<br>&#125;<br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> it = s.<span class="hljs-built_in">begin</span>(); it != s.<span class="hljs-built_in">end</span>(); ++it)&#123;<br>    cout &lt;&lt; *it &lt;&lt; endl;<br>&#125;<br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> it = s.<span class="hljs-built_in">rbegin</span>(); it != s.<span class="hljs-built_in">rend</span>(); ++it) &#123;<br>    cout &lt;&lt; *it &lt;&lt; endl;<br>&#125;<br><br>cout &lt;&lt; *s.<span class="hljs-built_in">begin</span>() &lt;&lt; endl;    <span class="hljs-comment">// 取第一个element的值</span><br><br>cout &lt;&lt; *s.<span class="hljs-built_in">rbegin</span>() &lt;&lt; endl;   <span class="hljs-comment">// 取最后一个element的值，不可以直接使用end()</span><br>cout &lt;&lt; *(--s.<span class="hljs-built_in">end</span>()) &lt;&lt; end;   <span class="hljs-comment">// 必须使用end()的前一个</span><br></code></pre></td></tr></table></figure><h3 id="map-x2F-unordered-map"><a href="#map-x2F-unordered-map" class="headerlink" title="map&#x2F;unordered_map"></a>map&#x2F;unordered_map</h3><ul><li>第一个称为关键字 (key)，每个关键字只能在 map 中出现一次。</li><li>map 有序（从小到大），unordered_map 无序</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;map&gt;</span></span><br><br>map&lt;T, U&gt; m;<br>map&lt;T, U, greater&lt;T&gt;&gt; m; <span class="hljs-comment">// 从大到小</span><br><br><span class="hljs-comment">// 常用function</span><br>m.<span class="hljs-built_in">empty</span>();<br>m.<span class="hljs-built_in">size</span>();<br>m.<span class="hljs-built_in">insert</span>();<br>m.<span class="hljs-built_in">erase</span>();  <span class="hljs-comment">// 删除element</span><br>m.<span class="hljs-built_in">clear</span>();  <span class="hljs-comment">// 清空所有的element</span><br>m.<span class="hljs-built_in">count</span>();  <span class="hljs-comment">// 返回 0/1</span><br>m.<span class="hljs-built_in">find</span>();   <span class="hljs-comment">// 返回 iter</span><br>m.<span class="hljs-built_in">swap</span>(x);<br><br><span class="hljs-comment">// Traversal by reference</span><br><span class="hljs-keyword">for</span> (<span class="hljs-type">const</span> <span class="hljs-keyword">auto</span>&amp; item : m) &#123;<br>    cout &lt;&lt; item.first &lt;&lt; <span class="hljs-string">&quot;:&quot;</span> &lt;&lt; item.second &lt;&lt; endl;<br>&#125;<br><span class="hljs-comment">// Traversal by reference with name</span><br><span class="hljs-keyword">for</span>(<span class="hljs-type">const</span> <span class="hljs-keyword">auto</span>&amp; [key, value] : m) &#123;<br>    cout &lt;&lt; key &lt;&lt; <span class="hljs-string">&quot;:&quot;</span> &lt;&lt; value &lt;&lt; endl;<br>&#125;<br><span class="hljs-comment">// Traversal by iterator</span><br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> it = m.<span class="hljs-built_in">begin</span>(); it != m.<span class="hljs-built_in">end</span>(); ++it) &#123;<br>    cout &lt;&lt; it-&gt;first &lt;&lt; <span class="hljs-string">&quot;:&quot;</span> &lt;&lt; it-&gt;second &lt;&lt; endl;<br>    <span class="hljs-comment">// 使用prev()取得iterator的前一个</span><br>    cout &lt;&lt; <span class="hljs-built_in">prev</span>(it)-&gt;first &lt;&lt; <span class="hljs-string">&quot;:&quot;</span> &lt;&lt; <span class="hljs-built_in">prev</span>(it)-&gt;second &lt;&lt; endl;<br>&#125;<br><br>cout &lt;&lt; m.<span class="hljs-built_in">begin</span>()-&gt;first &lt;&lt; endl;    <span class="hljs-comment">// 取第一个元素</span><br><br>cout &lt;&lt; m.<span class="hljs-built_in">rbegin</span>()-&gt;first &lt;&lt; endl;   <span class="hljs-comment">// 取最后一个元素，不可以直接使用end()</span><br>cout &lt;&lt; (--m.<span class="hljs-built_in">end</span>())-&gt;first &lt;&lt; end;   <span class="hljs-comment">// 必须使用end()的前一个</span><br></code></pre></td></tr></table></figure><h3 id="sort"><a href="#sort" class="headerlink" title="sort"></a>sort</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;algorithm&gt;</span></span><br><br><span class="hljs-built_in">sort</span>(v.<span class="hljs-built_in">begin</span>(), v.<span class="hljs-built_in">end</span>());<br><span class="hljs-built_in">sort</span>(v.<span class="hljs-built_in">begin</span>(), v.<span class="hljs-built_in">end</span>(), <span class="hljs-built_in">greater</span>&lt;T&gt;()); <span class="hljs-comment">//从大到小</span><br><br><span class="hljs-built_in">sort</span>(v.<span class="hljs-built_in">begin</span>(), v.<span class="hljs-built_in">end</span>(), [](<span class="hljs-type">int</span> &amp;a, <span class="hljs-type">int</span> &amp;b)&#123;<span class="hljs-keyword">return</span> a &lt; b;&#125;); <span class="hljs-comment">//自定义 lambda</span><br><br><span class="hljs-comment">// 排序二维数组</span><br>vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; nums;<br><span class="hljs-built_in">sort</span>(nums.<span class="hljs-built_in">begin</span>(), nums.<span class="hljs-built_in">end</span>()); <span class="hljs-comment">// nums[0] 小的在前面，nums[0]一样则是nums[1]小的在前面。</span><br><br><span class="hljs-comment">// 只针对第二个element排序</span><br>vetor&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; nums;<br><span class="hljs-built_in">sort</span>(nums.<span class="hljs-built_in">begin</span>(), nums.<span class="hljs-built_in">end</span>(), [](vector&lt;<span class="hljs-type">int</span>&gt;&amp; a, vector&lt;<span class="hljs-type">int</span>&gt;&amp; b)&#123;<br>    <span class="hljs-keyword">return</span> a[<span class="hljs-number">1</span>] &lt; b[<span class="hljs-number">1</span>];<br>&#125;);<br></code></pre></td></tr></table></figure><h3 id="binary-search"><a href="#binary-search" class="headerlink" title="binary_search"></a>binary_search</h3><ul><li><strong>前提有序</strong></li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// 返回 true 或 false</span><br><span class="hljs-built_in">binary_search</span>(v.<span class="hljs-built_in">begin</span>(), v.<span class="hljs-built_in">end</span>(), val)<br><br><span class="hljs-comment">// 找到 第一个大于或等于val 的迭代器，找不到返回 end()</span><br><span class="hljs-keyword">auto</span> it = <span class="hljs-built_in">lower_bound</span>(v.<span class="hljs-built_in">begin</span>(), v.<span class="hljs-built_in">end</span>(), val);<br><br><span class="hljs-comment">// 找到 第一个大于val 的迭代器，找不到返回 end()</span><br><span class="hljs-keyword">auto</span> it = <span class="hljs-built_in">upper_bound</span>(v.<span class="hljs-built_in">begin</span>(), v.<span class="hljs-built_in">end</span>(), val);<br></code></pre></td></tr></table></figure><h3 id="stringstream"><a href="#stringstream" class="headerlink" title="stringstream"></a>stringstream</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sstream&gt;</span></span><br><br>string str= <span class="hljs-string">&quot;hello&quot;</span>;<br><span class="hljs-function">stringstream <span class="hljs-title">ss</span><span class="hljs-params">(str)</span></span>;<br>string word;<br><br><span class="hljs-comment">// 默认空格分割</span><br><span class="hljs-keyword">while</span>(ss &gt;&gt; word)<br>    cout &lt;&lt; word &lt;&lt; endl;<br><br><span class="hljs-comment">// 按指定char分割</span><br><span class="hljs-keyword">while</span>(<span class="hljs-built_in">getline</span>(ss, word, <span class="hljs-string">&#x27;,&#x27;</span>))<br>    cout &lt;&lt; word &lt;&lt; endl;<br><br>ss.<span class="hljs-built_in">clear</span>(); <span class="hljs-comment">// 清空</span><br><br><span class="hljs-comment">// 把string丢进ss，最后使用str()输出</span><br>ss &lt;&lt; <span class="hljs-string">&quot;123,&quot;</span>;<br>ss &lt;&lt; <span class="hljs-string">&quot;456&quot;</span>;<br>cout &lt;&lt; ss.<span class="hljs-built_in">str</span>() &lt;&lt; endl;  <span class="hljs-comment">// 123456</span><br></code></pre></td></tr></table></figure><h3 id="algorithm"><a href="#algorithm" class="headerlink" title="algorithm"></a>algorithm</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;algorithm&gt;</span></span><br><br><span class="hljs-built_in">sort</span>(vec.<span class="hljs-built_in">begin</span>(), vec.<span class="hljs-built_in">end</span>()); <span class="hljs-comment">// 排序</span><br><br><span class="hljs-comment">// sort 配合 lambda 逆序排序</span><br><span class="hljs-built_in">sort</span>(vec.<span class="hljs-built_in">begin</span>(), vec.<span class="hljs-built_in">end</span>(), [](<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b)-&gt;<span class="hljs-type">bool</span> &#123;<span class="hljs-keyword">return</span> a &gt; b; &#125;);<br><br><span class="hljs-built_in">binary_search</span>(vec.<span class="hljs-built_in">begin</span>(), vec.<span class="hljs-built_in">end</span>(), x) <span class="hljs-comment">// 二分查找 x，返回 bool</span><br><br><span class="hljs-comment">// 对数组中 相邻 的重复元素实现“去重&quot;，一般都是对排好序的数组&quot;去重&quot;</span><br>vec.<span class="hljs-built_in">erase</span>(<span class="hljs-built_in">unique</span>(vec.<span class="hljs-built_in">begin</span>(), vec.<span class="hljs-built_in">end</span>()), vec.<span class="hljs-built_in">end</span>()); <span class="hljs-comment">// 排序-&gt;去重-&gt;删除重复值</span><br><br><span class="hljs-built_in">is_sorted</span>(vec.<span class="hljs-built_in">begin</span>(), vec.<span class="hljs-built_in">end</span>(), comp); <span class="hljs-comment">// 是否有序？返回bool</span><br><br><span class="hljs-built_in">reverse</span>(vec.<span class="hljs-built_in">begin</span>(), vec.<span class="hljs-built_in">end</span>());  <span class="hljs-comment">//翻转数组或字符串，无返回值</span><br><span class="hljs-keyword">auto</span> arr = <span class="hljs-built_in">reverse_copy</span>(vec.<span class="hljs-built_in">begin</span>(), vec.<span class="hljs-built_in">end</span>())；  <span class="hljs-comment">//将反转结果拷贝到另外一个容器中</span><br><br><span class="hljs-built_in">fill</span>(s.<span class="hljs-built_in">begin</span>(), s.<span class="hljs-built_in">end</span>(), c); <span class="hljs-comment">// 填充</span><br><br><span class="hljs-built_in">count</span>(v.<span class="hljs-built_in">begin</span>(), v.<span class="hljs-built_in">end</span>(), val); <span class="hljs-comment">// 计算val出现的次数</span><br><br><span class="hljs-comment">// 使用count_if + lambda，如果条件成立才数</span><br><span class="hljs-type">int</span> val;<br><span class="hljs-type">int</span> cnt = <span class="hljs-built_in">count_if</span>(v.<span class="hljs-built_in">begin</span>(), v.<span class="hljs-built_in">end</span>(), [val](<span class="hljs-type">int</span>&amp; i)&#123;<br>    <span class="hljs-keyword">return</span> i &gt; val;<br>&#125;);<br><br>cout &lt;&lt; *<span class="hljs-built_in">min_element</span>(v.<span class="hljs-built_in">begin</span>(), v.<span class="hljs-built_in">end</span>()) &lt;&lt; endl;  <span class="hljs-comment">// 范围内最小元素</span><br>cout &lt;&lt; *<span class="hljs-built_in">max_element</span>(v.<span class="hljs-built_in">begin</span>(), v.<span class="hljs-built_in">end</span>()) &lt;&lt; endl;  <span class="hljs-comment">// 范围内最大元素</span><br><br><span class="hljs-built_in">min</span>(a, b);<br><span class="hljs-built_in">max</span>(a, b);<br><br><span class="hljs-comment">// 从多个数中找出最大最小值</span><br><span class="hljs-built_in">min</span>(&#123;a, b, c, d, ...&#125;);<br><span class="hljs-built_in">max</span>(&#123;a, b, c, d, ...&#125;);<br><br><span class="hljs-comment">// 求给定范围内数据前缀和</span><br><span class="hljs-comment">// 第三个参数为输出序列的迭代器，用于存储部分求和结果</span><br><span class="hljs-built_in">partial_sum</span>(v.<span class="hljs-built_in">begin</span>(), v.<span class="hljs-built_in">end</span>(), v.<span class="hljs-built_in">begin</span>());<br></code></pre></td></tr></table></figure><h3 id="相互转换"><a href="#相互转换" class="headerlink" title="相互转换"></a>相互转换</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// int转string</span><br><span class="hljs-type">int</span> i;<br>string str = <span class="hljs-built_in">to_string</span>(i);<br><br><span class="hljs-comment">// string转int</span><br>String str;<br><span class="hljs-type">int</span> i = <span class="hljs-built_in">stoi</span>(str);<br><br><span class="hljs-comment">// char转int</span><br><span class="hljs-type">char</span> ch;<br><span class="hljs-type">int</span> i = ch - <span class="hljs-string">&#x27;0&#x27;</span>;<br><br><span class="hljs-comment">// int转char</span><br><span class="hljs-type">int</span> i;<br><span class="hljs-type">char</span> ch = i + <span class="hljs-string">&#x27;0&#x27;</span>;<br><br><span class="hljs-comment">// char[]转int</span><br><span class="hljs-type">char</span> s[] = <span class="hljs-string">&quot;111&quot;</span>;<br><span class="hljs-type">int</span> i = <span class="hljs-built_in">atoi</span>(s);<br><br><span class="hljs-comment">// int转char[]</span><br><span class="hljs-type">int</span> i = <span class="hljs-number">111</span>;<br><span class="hljs-type">char</span> ch[<span class="hljs-number">100</span>];<br><span class="hljs-built_in">itoa</span>(i, ch, <span class="hljs-number">10</span>);<br><span class="hljs-comment">// 第一个参数为待转化的整数</span><br><span class="hljs-comment">// 第二个参数为输出的字符串数组</span><br><span class="hljs-comment">// 第三个参数为进制，范围为2 - 36</span><br><br><span class="hljs-comment">// String转char[]</span><br>string str;<br><span class="hljs-type">char</span> *ch = (<span class="hljs-type">char</span> *)str.<span class="hljs-built_in">data</span>();<br><br><span class="hljs-comment">// char[]转String</span><br><span class="hljs-type">char</span> ch[] = <span class="hljs-string">&quot;abcd&quot;</span>;<br><span class="hljs-function">string <span class="hljs-title">str</span><span class="hljs-params">(ch)</span></span>;<br><br><span class="hljs-comment">// char转String</span><br><span class="hljs-type">char</span> ch = <span class="hljs-string">&#x27;a&#x27;</span>;<br><span class="hljs-function">string <span class="hljs-title">str</span><span class="hljs-params">(<span class="hljs-number">1</span>, ch)</span></span>;<br><br><span class="hljs-comment">// int[]转vector</span><br><span class="hljs-type">int</span> a[] = &#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>&#125;;<br><span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">vec</span><span class="hljs-params">(a, a + <span class="hljs-keyword">sizeof</span>(a) / <span class="hljs-keyword">sizeof</span>(<span class="hljs-type">int</span>))</span></span>;<br><br><span class="hljs-comment">// vector转int[]</span><br>vector&lt;<span class="hljs-type">int</span>&gt; vec&#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>&#125;;<br><span class="hljs-type">int</span> i[vec.<span class="hljs-built_in">size</span>()];<br><span class="hljs-built_in">memcpy</span>(i, &amp;vec[<span class="hljs-number">0</span>], vec.<span class="hljs-built_in">size</span>() * <span class="hljs-built_in">sizeof</span>(vec[<span class="hljs-number">0</span>]));<br></code></pre></td></tr></table></figure><h3 id="数学计算"><a href="#数学计算" class="headerlink" title="数学计算"></a>数学计算</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs cpp">INT_MAX;<br>INT_MIN;<br><br><span class="hljs-function"><span class="hljs-type">double</span> <span class="hljs-title">sqrt</span><span class="hljs-params">(x)</span></span>; <span class="hljs-comment">// 开方</span><br><br><span class="hljs-function"><span class="hljs-type">double</span> <span class="hljs-title">pow</span><span class="hljs-params">(x, y)</span></span>; <span class="hljs-comment">// x的y次方</span><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">abs</span><span class="hljs-params">(x)</span></span>; <span class="hljs-comment">// 绝对值</span><br><br><span class="hljs-function"><span class="hljs-type">double</span> <span class="hljs-title">ceil</span><span class="hljs-params">(x)</span></span>; <span class="hljs-comment">// 向上取整</span><br><span class="hljs-function"><span class="hljs-type">double</span> <span class="hljs-title">floor</span><span class="hljs-params">(x)</span></span>; <span class="hljs-comment">// 向下取整</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>刷题笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>cpp</tag>
      
      <tag>note</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Java 刷题笔记</title>
    <link href="/java%E5%88%B7%E9%A2%98%E7%AC%94%E8%AE%B0.html"/>
    <url>/java%E5%88%B7%E9%A2%98%E7%AC%94%E8%AE%B0.html</url>
    
    <content type="html"><![CDATA[<h3 id="Character"><a href="#Character" class="headerlink" title="Character"></a>Character</h3><p>判断是否为字母或数字：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">boolean</span> <span class="hljs-variable">res</span> <span class="hljs-operator">=</span> Character.isLetterOrDigit(<span class="hljs-type">char</span>);<br></code></pre></td></tr></table></figure><p>转小写：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">char</span> <span class="hljs-variable">res</span> <span class="hljs-operator">=</span> Character.toLowerCase(<span class="hljs-type">char</span>);<br></code></pre></td></tr></table></figure><p>下一个字符：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-string">&#x27;b&#x27;</span> == (<span class="hljs-type">char</span>) (<span class="hljs-string">&#x27;a&#x27;</span> + <span class="hljs-number">1</span>);<br></code></pre></td></tr></table></figure><h3 id="Integer"><a href="#Integer" class="headerlink" title="Integer"></a>Integer</h3><p>最大值最小值：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">int</span> <span class="hljs-variable">max</span> <span class="hljs-operator">=</span> Integer.MAX_VALUE;<br><span class="hljs-type">int</span> <span class="hljs-variable">min</span> <span class="hljs-operator">=</span> Integer.MIN_VALUE;<br></code></pre></td></tr></table></figure><p>比较相等：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">Integer</span> <span class="hljs-variable">a</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>;<br><span class="hljs-type">Integer</span> <span class="hljs-variable">b</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>;<br>a == b;<span class="hljs-comment">// true 两对象指向同一内存地址</span><br><span class="hljs-type">Integer</span> <span class="hljs-variable">c</span> <span class="hljs-operator">=</span> <span class="hljs-number">200</span>;<br><span class="hljs-type">Integer</span> <span class="hljs-variable">d</span> <span class="hljs-operator">=</span> <span class="hljs-number">200</span>;<br>c == d;<span class="hljs-comment">// false</span><br>Objects.equals(c, d);  <span class="hljs-comment">// true</span><br></code></pre></td></tr></table></figure><blockquote><p>Integer 默认缓存 [-128,127]，故 a，b 指向同一对象（地址），而非重新创建对象。</p></blockquote><p>四则运算</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">Integer</span> <span class="hljs-variable">a</span> <span class="hljs-operator">=</span> <span class="hljs-number">3</span>;<br><span class="hljs-type">Integer</span> <span class="hljs-variable">b</span> <span class="hljs-operator">=</span> <span class="hljs-number">5</span>;<br><span class="hljs-type">Integer</span> <span class="hljs-variable">result</span> <span class="hljs-operator">=</span> a + b; <span class="hljs-comment">// 自动拆箱为int相加，再自动装箱为Integer类型</span><br>System.out.println(result); <span class="hljs-comment">// 输出：8</span><br></code></pre></td></tr></table></figure><h3 id="Array"><a href="#Array" class="headerlink" title="Array"></a>Array</h3><p>创建数组：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">int</span>[] array = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[<span class="hljs-number">5</span>];<br><span class="hljs-type">int</span>[] array = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[]&#123;<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>&#125;;<br><span class="hljs-type">int</span>[] array = &#123;<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>&#125;;<br></code></pre></td></tr></table></figure><p>引用：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">array[<span class="hljs-number">3</span>];<br></code></pre></td></tr></table></figure><p>获取长度：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java">array.length;<br><span class="hljs-comment">// length 是数组的一个属性，不加()</span><br></code></pre></td></tr></table></figure><p>排序：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// int</span><br>Arrays.sort(array); <span class="hljs-comment">// 升序排列</span><br><br><span class="hljs-comment">// Integer</span><br>Integer[] array = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Integer</span>[<span class="hljs-number">2</span>];<br>Arrays.sort(array, Comparitor.naturalOrder());<span class="hljs-comment">// 升序排列</span><br>Arrays.sort(array, Comparator.reverseOrder());<span class="hljs-comment">// 降序排列</span><br><br>Arrays.sort(array, (a, b) -&gt; b - a); <span class="hljs-comment">// 降序排列（lambda表达式）</span><br><span class="hljs-comment">//基本类型(int) 不能使用lambda</span><br></code></pre></td></tr></table></figure><p>二维数组排序：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">int</span>[][] array = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[][]&#123;&#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>&#125;, &#123;<span class="hljs-number">2</span>, <span class="hljs-number">3</span>&#125;&#125;;<br>Arrays.sort(array, (o1, o2) -&gt; o1[<span class="hljs-number">0</span>] - o2[<span class="hljs-number">0</span>]);<span class="hljs-comment">// 按照二维数组的第一个元素从小到大排序</span><br>Arrays.sort(array, (o1, o2) -&gt; o1[<span class="hljs-number">1</span>] - o2[<span class="hljs-number">1</span>]);<span class="hljs-comment">// 按照二维数组的第二个元素从小到大排序</span><br></code></pre></td></tr></table></figure><p>打印：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">System.out.println(Arrays.toString(array));<br></code></pre></td></tr></table></figure><p>填满：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">int</span>[] array = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[];<br><span class="hljs-type">int</span> num;<br>Arrays.fill(array, num);<span class="hljs-comment">// array全部元素等于num</span><br></code></pre></td></tr></table></figure><h3 id="String"><a href="#String" class="headerlink" title="String"></a>String</h3><p>创建字符串：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">String</span> <span class="hljs-variable">string</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;java&quot;</span>;<br></code></pre></td></tr></table></figure><p>指定位置的字符</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">char</span> <span class="hljs-variable">charAt3</span> <span class="hljs-operator">=</span> string.charAt(<span class="hljs-number">3</span>);<span class="hljs-comment">// charAt3 = &#x27;a&#x27;</span><br></code></pre></td></tr></table></figure><p>字符串相等：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">String</span> <span class="hljs-variable">string1</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;abc&quot;</span>;<br><span class="hljs-type">String</span> <span class="hljs-variable">string2</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;abc&quot;</span>;<br>string1.equals(string2);<br></code></pre></td></tr></table></figure><p>字符串转整数：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">String</span> <span class="hljs-variable">string</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;123&quot;</span>;<br><span class="hljs-type">int</span> <span class="hljs-variable">integer</span> <span class="hljs-operator">=</span> Integer.parseInt(string);<br></code></pre></td></tr></table></figure><p>字符串遍历：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">String</span> <span class="hljs-variable">str</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;hello&quot;</span>;<br><span class="hljs-comment">// 方法一</span><br><span class="hljs-type">char</span>[] charArray = str.toCharArray();<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; charArray.length; i++)&#123;<br>    System.out.println(c[i]);<br>&#125;<br><span class="hljs-comment">// 方法二</span><br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;str.length();i++)&#123;<br><span class="hljs-type">char</span> <span class="hljs-variable">ch</span> <span class="hljs-operator">=</span> str.charAt(i);<br>    System.out.println(ch);<br>&#125;<br></code></pre></td></tr></table></figure><p>字符串长度：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">int</span> <span class="hljs-variable">length</span> <span class="hljs-operator">=</span> string.length();<br><span class="hljs-comment">// length() 是 String 类的一个方法，需要加（）</span><br></code></pre></td></tr></table></figure><p>截取字符串：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">String</span> <span class="hljs-variable">sb</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;abc&quot;</span>;<br><span class="hljs-type">String</span> <span class="hljs-variable">str</span> <span class="hljs-operator">=</span> sb.substring(<span class="hljs-number">0</span>, <span class="hljs-number">1</span>);<span class="hljs-comment">// str = &quot;a&quot;;</span><br></code></pre></td></tr></table></figure><p>字符的位置：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">String</span> <span class="hljs-variable">str</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;abc&quot;</span>;<br><span class="hljs-type">int</span> <span class="hljs-variable">index</span> <span class="hljs-operator">=</span> str.indexOf(b);<span class="hljs-comment">// index = 1</span><br></code></pre></td></tr></table></figure><p>String 转 char 数组：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java">String str;<br><span class="hljs-type">char</span>[] temp = str.toCharArray();<br></code></pre></td></tr></table></figure><p>字符串分割：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">String</span> <span class="hljs-variable">str</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;hello,world&quot;</span>;<br>String[] word = str.split(<span class="hljs-string">&quot;,&quot;</span>);<span class="hljs-comment">// word = [&quot;hello&quot;, &quot;world&quot;]</span><br><span class="hljs-comment">// 这里必须是字符串</span><br><span class="hljs-comment">// 如果有两个空格连在一起，会在数组中加入一个&quot;&quot;（空字符串）</span><br></code></pre></td></tr></table></figure><p>将字符串数组合并为长字符串（中间插入）：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java">String[] words = <span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>[]&#123;<span class="hljs-string">&quot;hello&quot;</span>, <span class="hljs-string">&quot;world&quot;</span>&#125;;<br><span class="hljs-type">String</span> <span class="hljs-variable">str</span> <span class="hljs-operator">=</span> String.join(<span class="hljs-string">&quot; &quot;</span>, words);<br><span class="hljs-comment">// str = &quot;hello world&quot;;</span><br></code></pre></td></tr></table></figure><p>字符串替换：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">String</span> <span class="hljs-variable">str</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;a! b&quot;</span>;<br>str = str.replace(<span class="hljs-string">&quot;!&quot;</span>, <span class="hljs-string">&quot; &quot;</span>);<span class="hljs-comment">// str = &quot;a  b&quot;;</span><br><span class="hljs-comment">// 字符或者字符串都可以替换</span><br></code></pre></td></tr></table></figure><p>删除字符串头尾的空格：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">String</span> <span class="hljs-variable">str</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;  abc  &quot;</span>;<br>str.trim();<span class="hljs-comment">// str = &quot;abc&quot;</span><br></code></pre></td></tr></table></figure><p>字符串翻转:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">String</span> <span class="hljs-variable">str1</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;hello&quot;</span>;<br><span class="hljs-type">String</span> <span class="hljs-variable">str2</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">StringBuffer</span>(str1).reverse().toString();<br></code></pre></td></tr></table></figure><h3 id="Stack"><a href="#Stack" class="headerlink" title="Stack"></a>Stack</h3><blockquote><p><a href="https://cloud.tencent.com/developer/article/1815753">Java 中用 Deque 接口代替 Stack 接口完成栈功能</a></p></blockquote><p>创建 stack：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">Deque&lt;Integer&gt; stack = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayDeque</span>&lt;Integer&gt;();<br></code></pre></td></tr></table></figure><p>栈顶：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">stack.peek()<br></code></pre></td></tr></table></figure><p>入栈：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">stack.push();<br></code></pre></td></tr></table></figure><p>出栈：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">stack.pop();<br></code></pre></td></tr></table></figure><p>栈是否为空：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">stack.isEmpty();<br></code></pre></td></tr></table></figure><p>栈的长度：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">stack.size();<br></code></pre></td></tr></table></figure><h3 id="ArrayList"><a href="#ArrayList" class="headerlink" title="ArrayList"></a>ArrayList</h3><p>创建列表：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java">List&lt;Integer&gt; array = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;Integer&gt;();<br>List&lt;Integer&gt; array = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;Integer&gt;(Arrays.asList(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>));<span class="hljs-comment">// 初始化值</span><br></code></pre></td></tr></table></figure><p>添加元素：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">array.add(<span class="hljs-number">1</span>);<br></code></pre></td></tr></table></figure><p>指定位置的元素：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">array.get(<span class="hljs-number">0</span>);<br></code></pre></td></tr></table></figure><p>列表中是否存在某元素：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">array.contains(<span class="hljs-number">0</span>);<br></code></pre></td></tr></table></figure><p>删除列表元素：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java">array.remove(<span class="hljs-number">0</span>);<span class="hljs-comment">// 删除array[0]</span><br>array.remove(Integer.valueOf(<span class="hljs-number">0</span>));<span class="hljs-comment">// 删除元素0</span><br></code></pre></td></tr></table></figure><p>列表大小：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">array.size();<br></code></pre></td></tr></table></figure><p>判断列表是否为空：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">array.isEmpty();<br></code></pre></td></tr></table></figure><p>清空列表：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">array.clear();<br></code></pre></td></tr></table></figure><p>升序排列：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">array.sort(Comparator.naturalOrder());<br></code></pre></td></tr></table></figure><p>降序排列：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">array.sort(Comparator.reverseOrder());<br></code></pre></td></tr></table></figure><p>修改值：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">array.set(<span class="hljs-type">int</span> index, <span class="hljs-type">int</span> value);<br></code></pre></td></tr></table></figure><p>反转：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">Collections.reverse(array);<br></code></pre></td></tr></table></figure><h3 id="HashMap"><a href="#HashMap" class="headerlink" title="HashMap"></a>HashMap</h3><p>创建一个哈希映射：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">Map&lt;Integer, Integer&gt; map = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;Integer, Integer&gt;();<br></code></pre></td></tr></table></figure><p>存储键值对（修改键值对）：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">map.put(key, value);<br></code></pre></td></tr></table></figure><p>获取 key 的内容：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">map.get(key);<br></code></pre></td></tr></table></figure><p>如果不知道有没有内容：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 如果存在key，返回key的值</span><br><span class="hljs-comment">// 如果不存在key，返回default</span><br>map.getOrDefault(key, <span class="hljs-keyword">default</span>);<br>map.put(key, map.getOrDefault(key, <span class="hljs-number">0</span>) + <span class="hljs-number">1</span>);<br></code></pre></td></tr></table></figure><p>查询是否存在 key：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">map.containsKey(key);<br></code></pre></td></tr></table></figure><p>遍历键值对：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 遍历key</span><br><span class="hljs-keyword">for</span> (Integer key : map.keySet()) &#123;<br>&#125;<br><span class="hljs-comment">// 遍历value</span><br><span class="hljs-keyword">for</span> (Integer value : map.values()) &#123;<br>&#125;<br></code></pre></td></tr></table></figure><p>是否为空：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">map.isEmpty();<br></code></pre></td></tr></table></figure><p>删除 Key：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">map.remove(key);<br></code></pre></td></tr></table></figure><p>排序：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java">Map&lt;Integer, Integer&gt; map = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;Integer, Integer&gt;();<span class="hljs-comment">// 创建一个哈希映射</span><br>List&lt;Map.Entry&lt;Integer, Integer&gt;&gt; mapList = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;Map.Entry&lt;Integer, Integer&gt;&gt;(map.entrySet());<span class="hljs-comment">// 我们无法对HashMap排序，需要把HashMap转换为ArrayList再排序</span><br>Collections.sort(mapList, <span class="hljs-keyword">new</span> <span class="hljs-title class_">Comparator</span>&lt;Map.Entry&lt;Integer, Integer&gt;&gt;() &#123;<br>            <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">compare</span><span class="hljs-params">(Map.Entry&lt;Integer, Integer&gt; o1, Map.Entry&lt;Integer, Integer&gt; o2)</span> &#123;<br>                <span class="hljs-keyword">return</span> (o2.getValue() - o1.getValue());<span class="hljs-comment">// 按照值的大小，从大到小排序</span><br>            &#125;<br>        &#125;);<br>mapList.get(i).getKey();<span class="hljs-comment">// 排序后第i个的键</span><br>mapList.get(i).getValue();<span class="hljs-comment">// 排序后第i个的值</span><br></code></pre></td></tr></table></figure><h3 id="HashSet"><a href="#HashSet" class="headerlink" title="HashSet"></a>HashSet</h3><p>创建哈希表：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">Set&lt;Integer&gt; set = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashSet</span>&lt;Integer&gt;();<br></code></pre></td></tr></table></figure><p>添加元素：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">set.add();<br></code></pre></td></tr></table></figure><p>判断元素是否存在：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">set.contains();<span class="hljs-comment">// HashSet查找元素要优于ArrayList</span><br></code></pre></td></tr></table></figure><p>删除元素：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">set.remove();<br></code></pre></td></tr></table></figure><p>清空：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">set.clear();<br></code></pre></td></tr></table></figure><p>遍历：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> temp : set) &#123;<br>    ...<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="StringBuilder"><a href="#StringBuilder" class="headerlink" title="StringBuilder"></a>StringBuilder</h3><p>创建 StringBuilder：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">StringBuilder</span> <span class="hljs-variable">sb</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">StringBuilder</span>();<br></code></pre></td></tr></table></figure><p>在末尾添加字符或字符串：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">sb.append(<span class="hljs-type">char</span>);<br></code></pre></td></tr></table></figure><p>在末尾删除字符：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">sb.deleteCharAt(sb.length() - <span class="hljs-number">1</span>);<br></code></pre></td></tr></table></figure><p>长度：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">sb.length();<br></code></pre></td></tr></table></figure><p>转化为 String：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">sb.toString();<br></code></pre></td></tr></table></figure><p>取反：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">sb.reverse();<br></code></pre></td></tr></table></figure><p>插入：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">sb.insert(<span class="hljs-number">0</span>, <span class="hljs-string">&quot;abcd&quot;</span>);<span class="hljs-comment">// 在第0个元素插入&quot;abcd&quot;</span><br></code></pre></td></tr></table></figure><p>清空：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">sb.setLength(<span class="hljs-number">0</span>);<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">sb.delete(<span class="hljs-number">0</span>, sb.length());<br></code></pre></td></tr></table></figure><p>取字符：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">sb.charAt(i);<br></code></pre></td></tr></table></figure><p>修改位置的字符：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">sb.setCharAt(i);<br></code></pre></td></tr></table></figure><h3 id="Queue"><a href="#Queue" class="headerlink" title="Queue"></a>Queue</h3><p>创建 queue:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">Queue&lt;Integer&gt; queue = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedList</span>&lt;Integer&gt;();<br></code></pre></td></tr></table></figure><p>加入元素：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">queue.offer(<span class="hljs-number">1</span>);<br></code></pre></td></tr></table></figure><p>删除元素（先进先出）：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">queue.poll();<br></code></pre></td></tr></table></figure><p>队首元素：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">queue.peek();<br></code></pre></td></tr></table></figure><p>队列大小：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">queue.size();<br></code></pre></td></tr></table></figure><p>是否为空：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">queue.isEmpty();<br></code></pre></td></tr></table></figure><p>队列清空：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">queue.clear();<br></code></pre></td></tr></table></figure><h3 id="Deque"><a href="#Deque" class="headerlink" title="Deque"></a>Deque</h3><p>创建 Deque：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">Deque&lt;Integer&gt; deque = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayDeque</span>&lt;Integer&gt;();<br></code></pre></td></tr></table></figure><p>队尾添加元素：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">deque.offerLast();<span class="hljs-comment">// queue的用法</span><br></code></pre></td></tr></table></figure><p>队首弹出元素：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">deque.pollFirst();<span class="hljs-comment">// queue的用法</span><br></code></pre></td></tr></table></figure><p>取队首元素：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">deque.peekFirst();<span class="hljs-comment">// queue的用法</span><br></code></pre></td></tr></table></figure><p>队首添加元素：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">deque.offerFirst();<br></code></pre></td></tr></table></figure><p>队尾弹出元素：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">deque.pollLast();<br></code></pre></td></tr></table></figure><p>取队尾元素：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">deque.peekLast();<br></code></pre></td></tr></table></figure><h3 id="LinkedList"><a href="#LinkedList" class="headerlink" title="LinkedList"></a>LinkedList</h3><p>新建链表：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">LinkedList&lt;Integer&gt; link = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedList</span>&lt;Integer&gt;();<br></code></pre></td></tr></table></figure><p>末尾插入：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java">link.add();<br><span class="hljs-comment">// 注意这个函数返回boolean，因此不要重复赋值</span><br>link.addLast();<br><span class="hljs-comment">// 返回void</span><br></code></pre></td></tr></table></figure><p>指定位置插入：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">link.add(<span class="hljs-type">int</span> index, <span class="hljs-type">int</span> Ele);<br></code></pre></td></tr></table></figure><p>头部插入：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">link.addFirst();<br></code></pre></td></tr></table></figure><p>清空：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">link.clear();<br></code></pre></td></tr></table></figure><p>删除并返回第一个：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">link.removeFirst();<br></code></pre></td></tr></table></figure><p>删除并返回最后一个：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">link.removeLast();<br></code></pre></td></tr></table></figure><p>删除特定位置：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">link.remove(<span class="hljs-type">int</span> index)<br></code></pre></td></tr></table></figure><p>重设：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">link.set();<br></code></pre></td></tr></table></figure><p>头部取值：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">link.getFirst();<br></code></pre></td></tr></table></figure><p>尾部取值：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">link.getLast();<br></code></pre></td></tr></table></figure><p>特定位置取值：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">link.get(<span class="hljs-type">int</span> index);<br></code></pre></td></tr></table></figure><p>是否存在：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">link.contains(<span class="hljs-type">int</span> key);<br></code></pre></td></tr></table></figure><h3 id="PriorityQueue"><a href="#PriorityQueue" class="headerlink" title="PriorityQueue:"></a>PriorityQueue:</h3><p>创建优先队列：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 如果不加Comparator默认为小根堆</span><br>PriorityQueue&lt;Integer&gt; heap = <span class="hljs-keyword">new</span> <span class="hljs-title class_">PriorityQueue</span>&lt;Integer&gt;();<br><br><span class="hljs-comment">// lambda大顶堆</span><br>PriorityQueue&lt;Integer&gt; bigHeap = <span class="hljs-keyword">new</span> <span class="hljs-title class_">PriorityQueue</span>&lt;&gt;((o1, o2) -&gt; o2 - o1);<br><br><span class="hljs-comment">// 自定义比较器大顶堆</span><br>PriorityQueue&lt;Integer&gt;bigHeap=<span class="hljs-keyword">new</span> <span class="hljs-title class_">PriorityQueue</span>&lt;&gt;(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Comparator</span>&lt;Integer&gt;() &#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">compare</span><span class="hljs-params">(Integer o1, Integer o2)</span> &#123;<br>        <span class="hljs-keyword">return</span> o2-o1;<br>    &#125;<br>&#125;);<br></code></pre></td></tr></table></figure><p>插入元素：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">heap.offer();<br></code></pre></td></tr></table></figure><p>取堆顶：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">heap.peek();<br></code></pre></td></tr></table></figure><p>弹出堆顶：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">heap.poll();<br></code></pre></td></tr></table></figure><p>删除特定元素：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">heap.remove();<br></code></pre></td></tr></table></figure><p>堆大小：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">heap.size();<br></code></pre></td></tr></table></figure><h3 id="Arrays-工具类"><a href="#Arrays-工具类" class="headerlink" title="Arrays 工具类"></a>Arrays 工具类</h3><p><strong>打印数组:Arrays.toString()</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">int</span> <span class="hljs-variable">a</span> <span class="hljs-operator">=</span> &#123;<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>&#125;;<br>System.out.println(Arrays.toString(a));<br><span class="hljs-comment">// 输出：[1,2,3]</span><br></code></pre></td></tr></table></figure><p><strong>比较数组:Arrays.equals(int[] a, int[] a2)</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">int</span> [] arrA=&#123;<span class="hljs-number">23</span>,<span class="hljs-number">34</span>,<span class="hljs-number">345</span>,<span class="hljs-number">234</span>&#125;;<br><span class="hljs-type">int</span> [] arrB=&#123;<span class="hljs-number">23</span>,<span class="hljs-number">34</span>,<span class="hljs-number">345</span>,<span class="hljs-number">234</span>&#125;;<br>System.out.println(Arrays.equals(arrA, arrB));<span class="hljs-comment">//true</span><br>System.out.println(arrA.equals(arrB));<span class="hljs-comment">//false</span><br></code></pre></td></tr></table></figure><p><strong>复制数组:Arrays.copyOf(int[] original, int newLength)</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">int</span> [] arrA=&#123;<span class="hljs-number">23</span>,<span class="hljs-number">34</span>,<span class="hljs-number">345</span>,<span class="hljs-number">234</span>&#125;;<br><span class="hljs-type">int</span> [] arrB=<span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[<span class="hljs-number">5</span>]; <span class="hljs-comment">// [0,0,0,0,0]</span><br>arrB=Arrays.copyOf(arrA, <span class="hljs-number">5</span>); <span class="hljs-comment">// [23,34,345,234,0]</span><br></code></pre></td></tr></table></figure><p><strong>填充数组：Arrays.fill(int[] a, int val) &#x2F; Arrays.fill(int[] a, int fromIndex, int toIndex, int val)</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">int</span>[] a= &#123;<span class="hljs-number">0</span>,<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>&#125;;<br>Arrays.fill(a, <span class="hljs-number">2</span>, <span class="hljs-number">4</span>, <span class="hljs-number">10</span>); <span class="hljs-comment">// [0,1,10,10,4]</span><br>Arrays.fill(a, <span class="hljs-number">5</span>);  <span class="hljs-comment">// [5,5,5,5,5]</span><br><br><span class="hljs-comment">// 填充二维数组</span><br><span class="hljs-type">int</span>[][] array = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[numRows][numCols];<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; numRows; i++) &#123;<br>    Arrays.fill(array[i], <span class="hljs-number">1</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>排序数组：Arrays.sort(int[] a, int formIndex, int toIndex, Comparator&lt;&gt;)</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">int</span>[] a = &#123;<span class="hljs-number">1</span>,<span class="hljs-number">3</span>,<span class="hljs-number">2</span>&#125;;<br><span class="hljs-comment">// 升序（默认）</span><br>Arrays.sort(a); <span class="hljs-comment">// [1,2,3]</span><br><br><span class="hljs-comment">// 降序(Integer)</span><br>Integer[] arr = &#123;<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>&#125;<br><br>Arrays.sort(arr，(<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b) -&gt; b-a); <span class="hljs-comment">// lambda</span><br><br>Arrays.sort(arr, Comparator.reverseOrder());<br><br>Arrays.sort(arr, <span class="hljs-keyword">new</span> <span class="hljs-title class_">Comparator</span>&lt;Integer&gt;() &#123;<br>        <span class="hljs-meta">@Override</span><br>        <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">compare</span><span class="hljs-params">(Integer i1, Integer i2)</span> &#123;<br>            <span class="hljs-comment">// return 0; // 相当于没有进行排序操作</span><br>            <span class="hljs-comment">// return i1 - i2; // 升序排序</span><br>            <span class="hljs-keyword">return</span> i2 - i1; <span class="hljs-comment">// 降序排序</span><br>        &#125;<br>&#125;);<br></code></pre></td></tr></table></figure><p><strong>二分查找：Arrays.binarySearch(int[] a, int key)</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">int</span>[] a = &#123;<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">323</span>,<span class="hljs-number">23</span>,<span class="hljs-number">543</span>,<span class="hljs-number">12</span>,<span class="hljs-number">59</span>&#125;;<br>Arrays.sort(a);   <span class="hljs-comment">// 先排序;</span><br><span class="hljs-type">int</span> <span class="hljs-variable">idx</span> <span class="hljs-operator">=</span> Arrays.binarySearch(a, <span class="hljs-number">12</span>)); <span class="hljs-comment">// 返回排序后新的索引位置,若未找到返回负数。</span><br></code></pre></td></tr></table></figure><h3 id="互相转换"><a href="#互相转换" class="headerlink" title="互相转换"></a>互相转换</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// int转String</span><br><span class="hljs-type">int</span> i;<br><span class="hljs-type">String</span> <span class="hljs-variable">str</span> <span class="hljs-operator">=</span> String.valueOf(i);<br><br><span class="hljs-comment">// String转int</span><br>String str;<br><span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> Integer.parseInt(str);<br><br><span class="hljs-comment">// char转int</span><br><span class="hljs-type">char</span> ch;<br><span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> ch - <span class="hljs-string">&#x27;0&#x27;</span>;<br><br><span class="hljs-comment">// int转char</span><br><span class="hljs-type">int</span> i;<br><span class="hljs-type">char</span> <span class="hljs-variable">ch</span> <span class="hljs-operator">=</span> (<span class="hljs-type">char</span>) (i + <span class="hljs-string">&#x27;0&#x27;</span>);<br><br><span class="hljs-comment">// String转char[]</span><br>String str;<br><span class="hljs-type">char</span>[] ch = str.toCharArray();<br><br><span class="hljs-comment">// char[]转String</span><br><span class="hljs-type">char</span>[] ch;<br><span class="hljs-type">String</span> <span class="hljs-variable">str</span> <span class="hljs-operator">=</span> String.valueOf(ch);<br><span class="hljs-type">String</span> <span class="hljs-variable">str</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>(ch);<br><br><span class="hljs-comment">// char转String</span><br><span class="hljs-type">char</span> <span class="hljs-variable">ch</span> <span class="hljs-operator">=</span> <span class="hljs-string">&#x27;a&#x27;</span>;<br><span class="hljs-type">String</span> <span class="hljs-variable">str</span> <span class="hljs-operator">=</span> ch + <span class="hljs-string">&quot;&quot;</span>;<br><br><span class="hljs-comment">// String 转基本类型</span><br><span class="hljs-type">int</span> <span class="hljs-variable">a</span> <span class="hljs-operator">=</span> Integer.parseInt(str);<br><span class="hljs-type">double</span> <span class="hljs-variable">a</span> <span class="hljs-operator">=</span> Double.parseDouble(str);<br><span class="hljs-type">float</span> <span class="hljs-variable">a</span> <span class="hljs-operator">=</span> Float.parseFloat(str);<br><span class="hljs-type">long</span> <span class="hljs-variable">a</span> <span class="hljs-operator">=</span> Long.parseLong(str);<br><span class="hljs-type">byte</span> <span class="hljs-variable">a</span> <span class="hljs-operator">=</span> Byte.parseByte(str);<br><span class="hljs-type">boolean</span> <span class="hljs-variable">a</span> <span class="hljs-operator">=</span> Boolean.parseBoolean(str);<br><span class="hljs-type">short</span> <span class="hljs-variable">a</span> <span class="hljs-operator">=</span> Short.parseShort(str);<br><br><br><span class="hljs-comment">// int[] -&gt; Integer[]</span><br>Integer[] integerArr = Arrays.stream(intArr).boxed().toArray(Integer[]::<span class="hljs-keyword">new</span>);<br><br><span class="hljs-comment">// Integer[] -&gt; int[]</span><br>intArr  = Arrays.stream(integerArr).mapToInt(Integer::valueOf).toArray();<br><br><span class="hljs-comment">// ArrayList转Integer[]</span><br>List&lt;Integer&gt; list;<br>Integer[] array = list.toArray(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Integer</span>[list.size()]);<br><br><span class="hljs-comment">// Integer[]转ArrayList</span><br>Integer[] array;<br>List&lt;Integer&gt; list = Arrays.asList(array);<br><br><span class="hljs-comment">// 对象转 String</span><br><span class="hljs-type">Integer</span> <span class="hljs-variable">a</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br><span class="hljs-type">String</span> <span class="hljs-variable">s</span> <span class="hljs-operator">=</span> a.toString();  <span class="hljs-comment">// 也能用valueOf</span><br></code></pre></td></tr></table></figure><h3 id="输入输出"><a href="#输入输出" class="headerlink" title="输入输出"></a>输入输出</h3><p><strong>Scanner</strong>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.util.Scanner;<br><br><span class="hljs-type">Scanner</span> <span class="hljs-variable">sc</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Scanner</span>(System.in);<br><span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> sc.nextInt(); <span class="hljs-comment">// 读一个整数</span><br><span class="hljs-type">String</span> <span class="hljs-variable">s</span> <span class="hljs-operator">=</span> sc.next(); <span class="hljs-comment">// 读一个字符串</span><br><span class="hljs-type">double</span> <span class="hljs-variable">t</span> <span class="hljs-operator">=</span> sc.nextDouble(); <span class="hljs-comment">// 读一个浮点数</span><br>...<br><span class="hljs-type">String</span> <span class="hljs-variable">s</span> <span class="hljs-operator">=</span> sc.nextLine(); <span class="hljs-comment">// 读一整行，以回车符作为分割符</span><br><br><span class="hljs-comment">// 判断是否有下一个输入可以用</span><br><span class="hljs-keyword">while</span>(sc.hasNext())&#123;&#125;<br><span class="hljs-comment">// 或sc.hasNextInt()或sc.hasNextDouble()或sc.hasNextLine()</span><br><br><span class="hljs-comment">// 多行空格分开的字符串</span><br><span class="hljs-keyword">while</span> (in.hasNextLine()) &#123;<br>    String[] s = in.nextLine().split(<span class="hljs-string">&quot; &quot;</span>);<br>    <span class="hljs-comment">// 处理</span><br>&#125;<br></code></pre></td></tr></table></figure><p><strong>StreamTokenizer</strong>：(快读)</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.io.*;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">test</span> &#123;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String args[])</span> <span class="hljs-keyword">throws</span> IOException&#123;<br><span class="hljs-type">StreamTokenizer</span> <span class="hljs-variable">st</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">StreamTokenizer</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">BufferedReader</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">InputStreamReader</span>(System.in)));<br>st.nextToken();<br><span class="hljs-type">String</span> <span class="hljs-variable">str</span> <span class="hljs-operator">=</span> st.sval;<span class="hljs-comment">//读取String类型数据</span><br>st.nextToken();<br><span class="hljs-type">double</span> <span class="hljs-variable">num1</span> <span class="hljs-operator">=</span>  st.nval;<span class="hljs-comment">//读取double类型数据</span><br>st.nextToken();<br><span class="hljs-type">int</span> <span class="hljs-variable">num2</span> <span class="hljs-operator">=</span> (<span class="hljs-type">int</span>)st.nval;<span class="hljs-comment">//读取int类型数据</span><br>st.nextToken();<br><span class="hljs-type">long</span> <span class="hljs-variable">num3</span> <span class="hljs-operator">=</span> (<span class="hljs-type">long</span>)st.nval;<span class="hljs-comment">//读取long类型数据</span><br>&#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><p>注意：</p><ul><li><p>我们在使用 StreamTokenizer 类时，我们要导入 io 包，它是 io 包中的类</p></li><li><p>在使用这个类时，函数要抛出 IOException 异常（throws IOException）</p></li><li><p>每一次读入之前都要用 nextToken（）方法获取下一个数据</p></li><li><p>读取数据的方法，sval 方法读取字符串类型（以空格或者换行分隔），nval 方法读取数字类型数据。读取字符串类型的数据时，一次只能读一个字符串，读取数字类型的数据时，默认为 double 类型</p></li></ul><p><strong>输出</strong>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 当输出的是一个基本数据类型时，会自动转换成字符串，如果输出的是一个对象，会自动调用对象的toString();</span><br>System.out.print(); <span class="hljs-comment">// 不换行</span><br>System.out.println(); <span class="hljs-comment">// 换行</span><br><br><span class="hljs-comment">// 格式化输出</span><br>System.out.printf(<span class="hljs-string">&quot;%.2f&quot;</span>,<span class="hljs-number">3.1415</span>);<br>String.format(<span class="hljs-string">&quot;%.2f&quot;</span>, value).toString();<br></code></pre></td></tr></table></figure><p><strong>高精度计算</strong>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">double</span> d1=<span class="hljs-number">3.56</span>;<br><span class="hljs-type">double</span> d2=<span class="hljs-number">5.13</span>;<br><span class="hljs-type">BigDecimal</span> <span class="hljs-variable">b1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">BigDecimal</span>(Double.toString(d1)); <span class="hljs-comment">// 先转换乘 String ！！</span><br><span class="hljs-type">BigDecimal</span> <span class="hljs-variable">b2</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">BigDecimal</span>(Double.toString(d2));<br>System.out.println(b1.add(b2)); <span class="hljs-comment">// add()、subtract()、multiply()、divide()，</span><br></code></pre></td></tr></table></figure><ol><li><code>double</code> 参数的构造方法，不允许使用，因为它不能精确的得到相应的值;</li><li><code>String</code> 构造方法是完全可预知的: 写入 new BigDecimal(“0.1”) 将创建一个值正好等于 0.1 的 BigDecimal。</li></ol><h3 id="坑"><a href="#坑" class="headerlink" title="坑"></a>坑</h3><p>Math.ceil：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">double</span> Math.ceil(<span class="hljs-type">double</span> a);<span class="hljs-comment">// 原函数</span><br>Math.ceil(<span class="hljs-number">24</span> / <span class="hljs-number">23</span>);<span class="hljs-comment">// 1.0</span><br>Math.ceil(<span class="hljs-number">22</span> / <span class="hljs-number">23</span>);<span class="hljs-comment">// 0.0</span><br>Math.ceil((<span class="hljs-type">double</span>) <span class="hljs-number">24</span> / <span class="hljs-number">23</span>);<span class="hljs-comment">// 2.0</span><br>(<span class="hljs-type">int</span>) Math.ceil((<span class="hljs-type">double</span>) <span class="hljs-number">24</span> / <span class="hljs-number">23</span>);<span class="hljs-comment">// 2</span><br></code></pre></td></tr></table></figure><p>Math.pow:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java">Math.pow(<span class="hljs-number">10</span>, <span class="hljs-number">9</span>);<span class="hljs-comment">// 如果想求次方必须要用pow函数，返回double</span><br><span class="hljs-number">10</span> ^ <span class="hljs-number">9</span>;<span class="hljs-comment">// 这里表示的是亦或而不是次方</span><br></code></pre></td></tr></table></figure><p>二维数组：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">int</span>[][] a = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[][] &#123;&#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>&#125;, &#123;<span class="hljs-number">3</span>, <span class="hljs-number">4</span>&#125;&#125;;<br><span class="hljs-type">int</span>[] b = a[<span class="hljs-number">1</span>];<span class="hljs-comment">// b = [3, 4]</span><br>b[<span class="hljs-number">1</span>] = <span class="hljs-number">100</span>;<br><span class="hljs-comment">// a = [[1, 2], [3, 100]]</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>leetcode</category>
      
    </categories>
    
    
    <tags>
      
      <tag>笔记</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>webserver 知识点</title>
    <link href="/webserver%E5%AD%A6%E4%B9%A0.html"/>
    <url>/webserver%E5%AD%A6%E4%B9%A0.html</url>
    
    <content type="html"><![CDATA[<h2 id="五种-I-x2F-O-模型"><a href="#五种-I-x2F-O-模型" class="headerlink" title="五种 I&#x2F;O 模型"></a>五种 I&#x2F;O 模型</h2><ul><li><strong>阻塞 IO</strong>:调用者调用了某个函数，等待这个函数返回，期间什么也不做，不停的去检查这个函数有没有返回，必须等这个函数返回才能进行下一步动作</li><li><strong>非阻塞 IO</strong>:非阻塞等待，每隔一段时间就去检测 IO 事件是否就绪。没有就绪就可以做其他事。非阻塞 I&#x2F;O 执行系统调用总是立即返回，不管时间是否已经发生，若时间没有发生，则返回-1，此时可以根据 errno 区分这两种情况，对于 accept，recv 和 send，事件未发生时，errno 通常被设置成 eagain</li><li><strong>信号驱动 IO</strong>:linux 用套接口进行信号驱动 IO，安装一个信号处理函数，进程继续运行并不阻塞，当 IO 时间就绪，进程收到 SIGIO 信号。然后处理 IO 事件。</li><li><strong>IO 复用</strong>:linux 用 select&#x2F;poll 函数实现 IO 复用模型，这两个函数也会使进程阻塞，但是和阻塞 IO 所不同的是这两个函数可以同时阻塞多个 IO 操作。而且可以同时对多个读操作、写操作的 IO 函数进行检测。知道有数据可读或可写时，才真正调用 IO 操作函数</li><li><strong>异步 IO</strong>:linux 中，可以调用 aio_read 函数告诉内核描述字缓冲区指针和缓冲区的大小、文件偏移及通知的方式，然后立即返回，当内核将数据拷贝到缓冲区后，再通知应用程序。</li></ul><p>注意：阻塞 I&#x2F;O，非阻塞 I&#x2F;O，信号驱动 I&#x2F;O 和 I&#x2F;O 复用都是同步 I&#x2F;O。同步 I&#x2F;O 指内核向应用程序通知的是就绪事件，比如只通知有客户端连接，要求用户代码自行执行 I&#x2F;O 操作，异步 I&#x2F;O 是指内核向应用程序通知的是完成事件，比如读取客户端的数据后才通知应用程序，由内核完成 I&#x2F;O 操作。</p><h2 id="事件处理模式"><a href="#事件处理模式" class="headerlink" title="事件处理模式"></a>事件处理模式</h2><ul><li>reactor 模式中，主线程(<strong>I&#x2F;O 处理单元</strong>)只负责监听文件描述符上是否有事件发生，有的话立即通知工作线程(<strong>逻辑单元</strong> )，读写数据、接受新连接及处理客户请求均在工作线程中完成。通常由<strong>同步 I&#x2F;O</strong>实现。</li><li>proactor 模式中，主线程和内核负责处理读写数据、接受新连接等 I&#x2F;O 操作，工作线程仅负责业务逻辑，如处理客户请求。通常由<strong>异步 I&#x2F;O</strong>实现。</li></ul><h2 id="同步-I-x2F-O-模拟-proactor-模式"><a href="#同步-I-x2F-O-模拟-proactor-模式" class="headerlink" title="同步 I&#x2F;O 模拟 proactor 模式"></a>同步 I&#x2F;O 模拟 proactor 模式</h2><p>同步 I&#x2F;O 模型的工作流程如下（epoll_wait 为例）：</p><ul><li>主线程往 epoll 内核事件表注册 socket 上的读就绪事件。</li><li>主线程调用 epoll_wait 等待 socket 上有数据可读</li><li>当 socket 上有数据可读，epoll_wait 通知主线程,主线程从 socket 循环读取数据，直到没有更多数据可读，然后将读取到的数据封装成一个请求对象并插入请求队列。</li><li>睡眠在请求队列上某个工作线程被唤醒，它获得请求对象并处理客户请求，然后往 epoll 内核事件表中注册该 socket 上的写就绪事件</li><li>主线程调用 epoll_wait 等待 socket 可写。</li><li>当 socket 上有数据可写，epoll_wait 通知主线程。主线程往 socket 上写入服务器处理客户请求的结果。</li></ul><h2 id="并发编程模式"><a href="#并发编程模式" class="headerlink" title="并发编程模式"></a>并发编程模式</h2><p>并发编程方法的实现有多线程和多进程两种，但这里涉及的并发模式指 I&#x2F;O 处理单元与逻辑单元的协同完成任务的方法。</p><ul><li>半同步&#x2F;半异步模式</li><li>领导者&#x2F;追随者模式</li></ul><h2 id="半同步-x2F-半反应堆"><a href="#半同步-x2F-半反应堆" class="headerlink" title="半同步&#x2F;半反应堆"></a>半同步&#x2F;半反应堆</h2><p>半同步&#x2F;半反应堆并发模式是半同步&#x2F;半异步的变体，将半异步具体化为某种事件处理模式。</p><p><strong>并发模式中的同步和异步：</strong></p><ul><li>同步指的是程序完全按照代码序列的顺序执行</li><li>异步指的是程序的执行需要由系统事件驱动</li></ul><p><strong>半同步&#x2F;半异步模式工作流程</strong>:</p><ul><li>同步线程用于处理客户逻辑</li><li>异步线程用于处理 I&#x2F;O 事件</li><li>异步线程监听到客户请求后，就将其封装成请求对象并插入请求队列中</li><li>请求队列将通知某个工作在同步模式的工作线程来读取并处理该请求对象</li></ul><p><strong>半同步&#x2F;半反应堆工作流程（以 Proactor 模式为例）</strong></p><ul><li>主线程充当异步线程，负责监听所有 socket 上的事件</li><li>若有新请求到来，主线程接收之以得到新的连接 socket，然后往 epoll 内核事件表中注册该 socket 上的读写事件</li><li>如果连接 socket 上有读写事件发生，主线程从 socket 上接收数据，并将数据封装成请求对象插入到请求队列中</li><li>所有工作线程睡眠在请求队列上，当有任务到来时，通过竞争（如互斥锁）获得任务的接管权</li></ul><h2 id="线程池"><a href="#线程池" class="headerlink" title="线程池"></a>线程池</h2><ul><li>空间换时间,浪费服务器的硬件资源,换取运行效率.</li><li>池是一组资源的集合,这组资源在服务器启动之初就被完全创建好并初始化,这称为静态资源.</li><li>当服务器进入正式运行阶段,开始处理客户请求的时候,如果它需要相关的资源,可以直接从池中获取,无需动态分配.</li><li>当服务器处理完一个客户连接后,可以把相关的资源放回池中,无需执行系统调用释放资源.</li></ul><h2 id="select-x2F-poll-x2F-epoll"><a href="#select-x2F-poll-x2F-epoll" class="headerlink" title="select&#x2F;poll&#x2F;epoll"></a><strong>select&#x2F;poll&#x2F;epoll</strong></h2><ul><li><p>调用函数</p></li><li><ul><li>select 和 poll 都是一个函数，epoll 是一组函数</li></ul></li><li><p>文件描述符数量</p></li><li><ul><li>select 通过线性表描述文件描述符集合，文件描述符有上限，一般是 1024，但可以修改源码，重新编译内核，不推荐</li><li>poll 是链表描述，突破了文件描述符上限，最大可以打开文件的数目</li><li>epoll 通过红黑树描述，最大可以打开文件的数目，可以通过命令 ulimit -n number 修改，仅对当前终端有效</li></ul></li><li><p>将文件描述符从用户传给内核</p></li><li><ul><li>select 和 poll 通过将所有文件描述符拷贝到内核态，每次调用都需要拷贝</li><li>epoll 通过 epoll_create 建立一棵红黑树，通过 epoll_ctl 将要监听的文件描述符注册到红黑树上</li></ul></li><li><p>内核判断就绪的文件描述符</p></li><li><ul><li>select 和 poll 通过遍历文件描述符集合，判断哪个文件描述符上有事件发生</li><li>epoll_create 时，内核除了帮我们在 epoll 文件系统里建了个红黑树用于存储以后 epoll_ctl 传来的 fd 外，还会再建立一个 list 链表，用于存储准备就绪的事件，当 epoll_wait 调用时，仅仅观察这个 list 链表里有没有数据即可。</li><li>epoll 是根据每个 fd 上面的回调函数(中断函数)判断，只有发生了事件的 socket 才会主动的去调用 callback 函数，其他空闲状态 socket 则不会，若是就绪事件，插入 list</li></ul></li><li><p>应用程序索引就绪文件描述符</p></li><li><ul><li>select&#x2F;poll 只返回发生了事件的文件描述符的个数，若知道是哪个发生了事件，同样需要遍历</li><li>epoll 返回的发生了事件的个数和结构体数组，结构体包含 socket 的信息，因此直接处理返回的数组即可</li></ul></li><li><p>工作模式</p></li><li><ul><li>select 和 poll 都只能工作在相对低效的 LT 模式下</li><li>epoll 则可以工作在 ET 高效模式，并且 epoll 还支持 EPOLLONESHOT 事件，该事件能进一步减少可读、可写和异常事件被触发的次数。</li></ul></li><li><p>应用场景</p></li><li><ul><li>当所有的 fd 都是活跃连接，使用 epoll，需要建立文件系统，红黑书和链表对于此来说，效率反而不高，不如 selece 和 poll</li><li>当监测的 fd 数目较小，且各个 fd 都比较活跃，建议使用 select 或者 poll</li><li>当监测的 fd 数目非常大，成千上万，且单位时间只有其中的一部分 fd 处于就绪状态，这个时候使用 epoll 能够明显提升性能</li></ul></li></ul><h2 id="ET、LT、EPOLLONESHOT"><a href="#ET、LT、EPOLLONESHOT" class="headerlink" title="ET、LT、EPOLLONESHOT"></a>ET、LT、EPOLLONESHOT</h2><ul><li><p>LT 水平触发模式</p></li><li><ul><li>epoll_wait 检测到文件描述符有事件发生，则将其通知给应用程序，应用程序可以不立即处理该事件。</li><li>当下一次调用 epoll_wait 时，epoll_wait 还会再次向应用程序报告此事件，直至被处理</li></ul></li><li><p>ET 边缘触发模式</p></li><li><ul><li>epoll_wait 检测到文件描述符有事件发生，则将其通知给应用程序，应用程序必须立即处理该事件</li><li>必须要一次性将数据读取完，使用非阻塞 I&#x2F;O，读取到出现 eagain</li></ul></li><li><p>EPOLLONESHOT</p></li><li><ul><li>一个线程读取某个 socket 上的数据后开始处理数据，在处理过程中该 socket 上又有新数据可读，此时另一个线程被唤醒读取，此时出现两个线程处理同一个 socket</li><li>我们期望的是一个 socket 连接在任一时刻都只被一个线程处理，通过 epoll_ctl 对该文件描述符注册 epolloneshot 事件，一个线程处理 socket 时，其他线程将无法处理，<strong>当该线程处理完后，需要通过 epoll_ctl 重置 epolloneshot 事件</strong></li></ul></li></ul>]]></content>
    
    
    <categories>
      
      <category>知识储备</category>
      
    </categories>
    
    
    <tags>
      
      <tag>webserver</tag>
      
      <tag>linux</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>pSCAN 图结构聚类</title>
    <link href="/pSCAN.html"/>
    <url>/pSCAN.html</url>
    
    <content type="html"><![CDATA[<p>pSCAN 研究了结构图聚类问题，这是图数据管理和分析的基本问题。给定一个无向无权图，结构图聚类就是将顶点分配给簇，并识别中心顶点和离群顶点的集合，使得同一簇中的顶点彼此紧密连接，而不同簇中的顶点松散连接。</p><span id="more"></span><blockquote><p>pSCAN: Fast and Exact Structural Graph Clustering.Lijun Chang, Wei Li, Lu Qin, Wenjie Zhang, and Shiyu Yang.</p></blockquote><h2 id="1-Contributions："><a href="#1-Contributions：" class="headerlink" title="1.Contributions："></a>1.Contributions：</h2><ul><li>作者证明了现有的 SCAN 算法在最坏情况下最优的。</li><li>作者对结构图聚类做了三个观察，提出了可扩展结的两步范式，减少结构相似性计算。</li><li>此外，作者提供了优化技术加速检查两个顶点是否结构相似。</li></ul><h2 id="2-Three-observations"><a href="#2-Three-observations" class="headerlink" title="2.Three observations:"></a>2.Three observations:</h2><ol><li>结构图聚类中的聚类可能存在重叠。</li><li>核顶点的集群不相交。</li><li>非核心顶点的簇由核心顶点唯一确定。</li></ol><h2 id="3-Definition"><a href="#3-Definition" class="headerlink" title="3.Definition:"></a>3.Definition:</h2><ul><li>顶点 u 的结构领域 N[u] 为 u 的闭领域，即：N[u] &#x3D; {v ∈ V|(u,v) ∈ E} ∪ {u}。</li><li>顶点 u 和 v 之间的结构相似性定义为：N[u]和 N[v]中共有顶点的数量按其基数的几个平均值归一化。</li><li>给定相似度阈值 0 &lt; $\epsilon$ &lt;&#x3D; 1 和一个整数 $\mu$ ≥ 2，一个顶点是核心顶点如果 $N_{eps}$[u] ≥ $\mu$。</li><li>集群 C 是 V 的一个子集，它至少有两个顶点，则：<ul><li>（最大化）如果核心顶点 u∈C，那么所欲有从 u 到结构可达的顶点 v 也属于 C。</li><li>（连通性）对于任意两个顶点 $v_1$,$v_2$ ∈ C，有顶点 u ∈ C，使得 $v_1$ 和 $v_2$ 都可以从 u 可达。</li></ul></li><li>给定聚类 C，C 中不属于任何集群的顶点 u，如果它的邻居属于两个或者两个以上的集群，则为 hub，否则为 outlier。</li></ul><h2 id="4-Two-step-Paradigm"><a href="#4-Two-step-Paradigm" class="headerlink" title="4.Two-step Paradigm:"></a>4.Two-step Paradigm:</h2><ul><li>step-1：<u>聚类核心顶点</u>，把所有核心顶点分类到对应簇。</li><li>step-2：<u>聚类非核心顶点</u>，是 non-core 且和邻点 core 相似，分到 core 的簇中。</li></ul><img src="https://cdn.jsdelivr.net/gh/gejoyy/Pictures@main/image-20230627152627744.png" alt="pscan-algorithm-2" style="zoom: 67%;" /><h2 id="5-Algorithm"><a href="#5-Algorithm" class="headerlink" title="5.Algorithm"></a>5.Algorithm</h2><h3 id="5-1-pSCAN"><a href="#5-1-pSCAN" class="headerlink" title="5.1 pSCAN"></a>5.1 pSCAN</h3><p>算法目标是减少结构相似性计算的次数，把边分为 $E_{c,c}$，$E_{c,n}$，分别讨论。</p><img src="https://cdn.jsdelivr.net/gh/gejoyy/Pictures@main/image-20230627153257747.png" alt="pscan-algorithm-3" style="zoom:67%;" /><ul><li>行 1，初始化每个顶点成单个子集。</li><li>行 2-4，初始化每个顶点 sd(u), ed(u)。</li><li>行 5-7，按有效度 ed(u) 非递增顺序遍历顶点 u，检测 u 是否为 core，如果 u 是 core，把 u 和已经确定为 core 的邻点聚类到一起。</li><li>行 8-9，得到 core 顶点聚类 $C_c$，再聚类 non-core 顶点集合。</li><li>用不相交数据结构(disjoint-set data) 聚类 $G_c$ 中的 core，形成多个不相交的集合 S &#x3D; {s1, s2,…}<ul><li>find-subset：查看元素在哪一个子集中。</li><li>union：合并两个子集。</li></ul></li><li>union(u, v) 相当于在 $G_c$ 中添加一条边(u, v)。</li><li>两个顶点 u，v 属于同一连接组件（聚类）当且仅当 u，v 所在的子集相同，即：find-subset(u) &#x3D; find-subset(v)。</li></ul><p><strong>effective-degree: ed(u)</strong></p><ul><li>目的：为了减少相似度计算，按 ed(u) <strong>非递增</strong>顺序排序顶点。</li><li>定义：|N[u]|减去与 u 不相似的邻点的数量，得到可能相似的邻点的数量，满足 |$N_{eps}[u]$| ≤ ed(u)，ed(u) 是上界。</li><li>如果 ed(u) ≤ $\mu$，上界小于 $\mu$，则 u 是 non-core，从而减少<strong>顶点对 $E_{n,n}$ 的计算次数</strong>，对两个 non-core 顶点，不用计算它们之间相似度。</li></ul><p><strong>similar-degree: sd(u)</strong></p><ul><li>目的：为了有效检查一个顶点是否为 core。</li><li>定义：sd(u) 是已经确定与 u 相似的邻居的数量，满足|$N_{eps}[u]$| ≥ sd(u)，sd(u) 是下界。</li><li>如果 sd(u) ≥ $\mu$，下界大于 $\mu$，则 u 是 core。</li></ul><h3 id="5-2-CheckCore"><a href="#5-2-CheckCore" class="headerlink" title="5.2 CheckCore"></a>5.2 CheckCore</h3><p>目的：检测一个顶点是否为 core，减少顶点对 $E_{n,n}$的计算。</p><img src="https://cdn.jsdelivr.net/gh/gejoyy/Pictures@main/image-20230627153654828.png" alt="pscan-algorithm-4" style="zoom:67%;" /><ul><li>行 1，对于 ed(u) &lt; $\mu$（确定为 non-core）和 sd(u) ≥ $\mu$（确定 core）两种情况无需讨论，因为 ed(u) ≥ sd(u)，所以讨论第三种情况，ed(u) ≥ $\mu$ &gt;sd(u)，需要计算 u 和其邻居的相似性，<strong>以检测 u 是否为core</strong>。</li><li>行 2，初始化 ed(u)，sd(u)。</li><li>行 3-6，计算相似度，然后更新 ed(u)，sd(u)。</li><li>行 7-9，如果邻点 v 还没有被探索，更新 ed(v)，sd(v)，如果 ed(u) &lt; $\mu$ 或者 sd(u) ≥ $\mu$，则<strong>后面不需要探索 v</strong>，即可确定 v 是 core 还是 non-core。</li><li>行 10，知道确定 u 是 core 还是 non-core。</li><li>最后，标记 u 已被探索过，之后不需要更新 ed(u)，sd(u)。</li></ul><h3 id="5-3-ClusterCore"><a href="#5-3-ClusterCore" class="headerlink" title="5.3 ClusterCore"></a>5.3 ClusterCore</h3><p>目的：聚类核心顶点的邻居顶点（也是核心顶点），减少了 $E_{c,c}$ 相似对的计算。</p><img src="https://cdn.jsdelivr.net/gh/gejoyy/Pictures@main/image-20230627154338133.png" alt="pscan-algorithm-5" style="zoom:67%;" /><ul><li>行 1-3，将与 u 结构相似的核心顶点（同时也是 u 的邻居顶点）分配到与 u 相同的集群中。</li><li>行 4-6，N’[u] 表示已经被计算过结构相似性邻居顶点 v 的集合，对于每个尚未被计算的 u 的结构相似邻居 v，如果 u 和 v 尚未分配给相同的集群，并且 v 可能是 core，则计算相似度(u, v)。</li><li>行 7-9，若 v 未被探索，如果(u, v)结构相似，更新 sd，否则不相似，更新 ed。</li><li>行 10，若 v 确定为 core，并且(u, v)相似，合并 u，v 到同一个集群中，属于同一聚类。</li></ul><h3 id="5-4-ClusterNoncore"><a href="#5-4-ClusterNoncore" class="headerlink" title="5.4 ClusterNoncore"></a>5.4 ClusterNoncore</h3><p>目的：减少 $E_{c,n}$ 相似对的计算。</p><img src="https://cdn.jsdelivr.net/gh/gejoyy/Pictures@main/image-20230627154711792.png" alt="pscan-algorithm-6" style="zoom:60%;" /><ul><li>行 4-7，遍历核心顶点的每个邻居 v，如果 v 是 non-core 并且 v 不在 u 的集群（可能包含 non-core）里，计算相似度(u,v)，如果还没计算的话。</li><li>行 8，如果（u，v）相似，把 v 加入 u 的集群。</li><li>行 6，如果 sd(v) ≥ $\mu$（v 为 core）或者 v 属于 u 的集群，则不需要计算 u，v 的相似度。</li><li>思考：计算 core 的时候，能够得出其邻居是 non-core（ed &lt; $\mu$），则不需要探索 non-core。</li></ul><p><strong>bin-sort</strong>: 桶排序，桶号 i 表示有效度 ed(u) &#x3D; i，顶点放入对应桶里，有效度 ed 只会减少，每一个桶是单链表。</p><p><strong>adjacency list</strong>: 输入图存储为邻接表，N(u)以顶点 id 排序，实践中计算 N[u] ∩ N[v] 表现更好。</p><h3 id="5-5-Optimization-Techniques"><a href="#5-5-Optimization-Techniques" class="headerlink" title="5.5 Optimization Techniques"></a>5.5 Optimization Techniques</h3><ol><li><strong>Criss link：</strong> 交叉连接 (u,v) 和 (v,u)，相似度计算减少一半，对于 N[u] 和 (u,v)，用二分查找 N[v] 中相反边(v,u)</li><li><strong>Pruning Rule：</strong> 修剪规则有效决定 u，v 是否相似，若 d[u] &lt; $\epsilon^2$·d[v] 或者 d[v] &lt; $\epsilon^2$·d[u]，则 $\sigma$(u, v) &lt; $\mu$。</li></ol><img src="https://cdn.jsdelivr.net/gh/gejoyy/Pictures@main/image-20230627155057753.png" alt="pscan-algorithm-6" style="zoom:67%;" /><ol start="3"><li><strong>Adaptive Structural Similarity Checking：</strong><ul><li>cn(u, v) 是满足 u，v 相似的<strong>最小公共邻居数量</strong>。</li><li>cn(u, v) &#x3D; $\lceil\sigma\cdot\sqrt{d[u]\cdot d[v]}\rceil$。</li><li>顶点相似等价于 |N[u] ∩ N[v]| ≥ cn(u,v)。</li></ul></li></ol><img src="https://cdn.jsdelivr.net/gh/gejoyy/Pictures@main/image-20230627155232123.png" alt="pscan-algorithm-7" style="zoom:67%;" /><ul><li><strong>cn(u,v) &lt; min{$d_u,d_v$} 不可能相似（提前结束）</strong></li><li><strong>只要满足 公共邻居数量 ≥ cn(u,v)，退出 while，返回 true（提前结束）</strong></li></ul><h2 id="6-Dynameically-cluster-maintenance"><a href="#6-Dynameically-cluster-maintenance" class="headerlink" title="6.Dynameically cluster maintenance"></a>6.Dynameically cluster maintenance</h2><ul><li>经过 pSCAN 算法，我们已知道 1. 顶点 u 是否为 core，2.部分顶点是否相似。</li><li>由于剪枝算法，1) 存在一些顶点间是否相似并不知道 ；2) 一些顶点间具体相似值不知道。</li><li>为了维护聚类，维持以下两个数据：<ul><li>每个顶点，维护 sd(u)，或者说<strong>维护核心顶点的集合</strong>。、</li><li>每个边，维护 t(u, v) &#x3D; |N[u] ∩ N[v]|，t(u, v) 的值可能为 0(没有边)，为 1（没有边但有一个共同邻居）。</li></ul></li><li>在 pSCAN 算法过程中，维护 t(u, v)：<ul><li>若 u，v 相似，则 t(u, v) &gt; 0，反之 t &gt; 0，不一定相似（t&#x3D;1）。</li><li>若 u，v 不相似，则 t(u, v) &lt; 0 （不存在边，或者有边且有多个共同邻居但<strong>不相似</strong>，此时为负整数）。</li><li>其他情况，t(u, v) &#x3D; 0，对与未知的 t(x,y)值，默认 t(x,y)&#x3D;0。</li><li>此外 |t(u, v) | ≥ 2，则 |t(u, v) | &#x3D; |N[u] ∩ N[v]|，注意是<strong>绝对值</strong>，t 可能为负数（-2，-3，···）</li></ul></li></ul><h3 id="6-1-ClusterMaintenance"><a href="#6-1-ClusterMaintenance" class="headerlink" title="6.1 ClusterMaintenance"></a>6.1 ClusterMaintenance</h3><img src="https://cdn.jsdelivr.net/gh/gejoyy/Pictures@main/image-20230627155758739.png" alt="pscan-algorithm-8" style="zoom:67%;" /><h3 id="6-2-Maintaining-Core-Vertices"><a href="#6-2-Maintaining-Core-Vertices" class="headerlink" title="6.2 Maintaining Core Vertices"></a>6.2 Maintaining Core Vertices</h3><ul><li>定义 N[u, v] &#x3D; N[u] ∪ N[v]。</li><li>在插入或删除边（u，v）后，只有边相关顶点相似值可能改变，那些不在 N[u,v]的顶点相似值不变，可能从 core 变为 non-core，或相反，因此考虑 N[u,v] 中的顶点，维护核心顶点集合。</li></ul><h4 id="6-2-1-Edge-insert"><a href="#6-2-1-Edge-insert" class="headerlink" title="6.2.1 Edge insert"></a>6.2.1 <strong>Edge insert</strong></h4><p>对每个 w ∈ N[u, v]，维护 sd(w)，N[u, v]划分四个集合分别考虑。</p><ul><li><strong>w ∈ N(u) 但不属于 N(v)：</strong><ul><li>若 t(w, u) ≤ 0，则 t(w, u)，sd(w) 不改变，因为 $\sigma$(w, u) 变小了，不存在 u 从 non-core 变为 core。</li><li>若 t(w, u) &gt; 0 且 sd(w) &lt; $\mu$，即 w 是 non-core，则 w 还是 non-core，需要更新 t(w,u)，sd(w)。</li><li>若 t(w, u) &gt; 0 且 sd(w) ≥ $\mu$，即 w 是 core，需要更新 t(w,u)，sd(w)，如果 $sd’$(w) &lt; $\mu$，需要计算相似性，对那些 w 的邻接点 x，满足 t(w, x) &#x3D; 0，去检查 w 是否仍然为 core。</li></ul></li><li><strong>w ∈ N(v) 但不属于 N(u)，做法同上。</strong></li><li><strong>w ∈ N(u) ∩ N(v)：</strong><ul><li>w 是共同邻接点，则 $\sigma’$(w, u) &gt; $\sigma$(w, u)，相似度变大了，同理 $\sigma$(w,v) 也变大（三角形数加一）。</li><li>若更新前 w 是 core，更新后仍然为 core，也要更新 t(w, u), t(w,v)。</li><li>若更新前 w 是 non-core，则需要更新 t(w,u), t(w, v)，其他邻接点 x 满足 t(w,x) &#x3D; 0 决定 w 是一个 core 更新后。</li></ul></li><li><strong>对于顶点 u，v：</strong><ul><li>考虑 u，由于 sd(u) &lt; $\mu$ 并且 邻接点 x 满足 t(u, x) &#x3D; 0，即在更新后（删除边 x,u）u 可能成为 core，则计算|N[u] ∩ N[v]|，更新 t(u, x) 和 sd(u)。</li><li>对于其他 邻接点 y 满足 t(u, y) $\neq$ 0，t(u, y)已经被更新过，在插入边 (u,x) 时候。</li><li>对于 v，做法一样。</li></ul></li></ul><p><strong>MaintainCoreVertices</strong>: </p><ul><li>对应上面四种处理方法</li></ul><img src="https://cdn.jsdelivr.net/gh/gejoyy/Pictures@main/image-20230627160221009.png" alt="pscan-algorithm-9" style="zoom:80%;" /><ul><li>行 2-10，w ∈ N(v)\N(u)；</li><li>行 12-22，w ∈ N(u)∩N(v)；</li><li>行 23-26，处理 u，v。</li><li>三角形 t(u, v) &#x3D; |N[u] ∩ N[v]|，若（u，v）确定不相似（可以没有边），则 t(u, v) &#x3D; - t(u, v)，变成负数。</li><li>行 27-29，若 |t(x, y)| ≤ 1，则重新计算 |N[x] ∩ N[y]|，否则更新 t(x,y) &#x3D; |t(x,y)| + 三角形。</li><li>行 30，判断 x，y 是否相似，赋值 t(x, y) 正负号。</li></ul><h4 id="6-2-2-Edge-Deletion"><a href="#6-2-2-Edge-Deletion" class="headerlink" title="6.2.2 Edge Deletion"></a>6.2.2 Edge Deletion</h4><ul><li>对 w ∈ N[u,v]，维护 sd(w)，与 insert edge 做法相似。</li><li>w ∈ N[u] \ N[v]，有 $\sigma’$(w, u) &gt; $\sigma$(w, u)。</li><li>w ∈ N[u] ∩ N[v]，有 $\sigma’$(w, u) &lt; $\sigma$(w, u)。</li></ul><h3 id="6-3-Maintaining-Structral-Similarities"><a href="#6-3-Maintaining-Structral-Similarities" class="headerlink" title="6.3 Maintaining Structral Similarities"></a>6.3 Maintaining Structral Similarities</h3><ul><li>考虑 t (x, y) 不在 N[u, v]：<ul><li>t(x,y)可能为 0 ，对（x,y）∈ E，在运行 pSCAN，维护聚类时候，例如删除边(x,y)，则 t()&#x3D;0。</li><li>聚类 C 可能分成两部分，由于里面一些边从相似 <strong>变为</strong> 不相似。</li><li>存在一个边在 C 中，满足 t(x,y)&#x3D;0 且 $\sigma$(x, y) ≥ $\epsilon$，把两个集合连接成一个聚类。</li></ul></li><li>因此要考虑 t(x,y)&#x3D;0，但不是对所有 edge（x,y）满足 t(x,y)&#x3D;0 ，都要更新，会延迟更新信息时间，因此关键在于如何选取哪些边 t&#x3D;0。</li><li>若聚类 C 中所有边满足 t&gt;0，聚类能够获得通过 BFS，基于 sd()，t()。</li><li>对于聚类 C，如果满足以下条件，不需要探索聚类 C 中顶点去更新 t()：<ul><li>不存在边 从 t&gt;0 变成 t&lt;0；</li><li>不存在核心顶点的邻接边，满足 t() &#x3D; 0；</li></ul></li><li>因此对每一个 core，提出一个平衡值 AllCh，<code>AllCh(x) = true</code> 当且仅当聚类 C 中不存在核心顶点邻接边 t &#x3D; 0。</li></ul><img src="https://cdn.jsdelivr.net/gh/gejoyy/Pictures@main/image-20230627160648438.png" alt="pscan-algorithm-10" style="zoom:80%" align="center" /><ul><li>edge(x,y) 从 t(x,y)&gt;0 变成 t(x,y)&lt;0：<ul><li>若更新前 x 是 core，则对所有与 x 结构可达的 core 满足 <code>AllCh() = true</code>，计算所有未知的 t(·,·)（即 t&#x3D;0）。</li><li>对 y 做法同上。</li><li>若更新后 x 或 y，从 non-core 变成 core，则必定存在另一个邻接边从 t ≤ 0 变成 t ≥ 0。</li></ul></li><li>edge(x,y) 从 t(x,y)≤0 变成 t(x,y)&gt;0：<ul><li>若 x 从 non-core 变成 core，则计算未知 t(·,·)，对所有临界边。</li><li>对 y 做法同上。</li><li>若更新后 x 和 y 都是 core 且 AllCh(x) $\neq$ AllCh(y)，则计算未知的 t( , )，即 t 值为 0。</li></ul></li><li>AllCh(x) 初始化每个点为 <code>false</code>。</li><li>若 x 是 core，UpdateReachable(x)计算未知 t() 值，对所有聚类中的 core 且满足 <code>AllCh() = true</code>；否则 UpdateReachable(x) 等价于 UpdateReachable(y)，对每一个 y 的 core 邻接点。</li><li>注意如果 <code>AllCh(x) = true</code>，调用 UpdateReachable(x) 将什么都不做。</li></ul>]]></content>
    
    
    <categories>
      
      <category>论文笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>SCAN</tag>
      
      <tag>graph</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
