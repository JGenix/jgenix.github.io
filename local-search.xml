<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>webserver 知识点</title>
    <link href="/learn-webserver.html"/>
    <url>/learn-webserver.html</url>
    
    <content type="html"><![CDATA[<p>在学习开源轻量级 web 服务器 <a href="https://github.com/qinguoyi/TinyWebServer/tree/master">TinyWebServer</a> 过程中，总结记录的相关知识点。</p><span id="more"></span><h2 id="五种-I-x2F-O-模型"><a href="#五种-I-x2F-O-模型" class="headerlink" title="五种 I&#x2F;O 模型"></a>五种 I&#x2F;O 模型</h2><ul><li><strong>阻塞 IO</strong>:调用者调用了某个函数，等待这个函数返回，期间什么也不做，不停的去检查这个函数有没有返回，必须等这个函数返回才能进行下一步动作</li><li><strong>非阻塞 IO</strong>:非阻塞等待，每隔一段时间就去检测 IO 事件是否就绪。没有就绪就可以做其他事。非阻塞 I&#x2F;O 执行系统调用总是立即返回，不管时间是否已经发生，若时间没有发生，则返回-1，此时可以根据 errno 区分这两种情况，对于 accept，recv 和 send，事件未发生时，errno 通常被设置成 eagain</li><li><strong>信号驱动 IO</strong>:linux 用套接口进行信号驱动 IO，安装一个信号处理函数，进程继续运行并不阻塞，当 IO 时间就绪，进程收到 SIGIO 信号。然后处理 IO 事件。</li><li><strong>IO 复用</strong>:linux 用 select&#x2F;poll 函数实现 IO 复用模型，这两个函数也会使进程阻塞，但是和阻塞 IO 所不同的是这两个函数可以同时阻塞多个 IO 操作。而且可以同时对多个读操作、写操作的 IO 函数进行检测。知道有数据可读或可写时，才真正调用 IO 操作函数</li><li><strong>异步 IO</strong>:linux 中，可以调用 aio_read 函数告诉内核描述字缓冲区指针和缓冲区的大小、文件偏移及通知的方式，然后立即返回，当内核将数据拷贝到缓冲区后，再通知应用程序。</li></ul><p>注意：阻塞 I&#x2F;O，非阻塞 I&#x2F;O，信号驱动 I&#x2F;O 和 I&#x2F;O 复用都是同步 I&#x2F;O。同步 I&#x2F;O 指内核向应用程序通知的是就绪事件，比如只通知有客户端连接，要求用户代码自行执行 I&#x2F;O 操作，异步 I&#x2F;O 是指内核向应用程序通知的是完成事件，比如读取客户端的数据后才通知应用程序，由内核完成 I&#x2F;O 操作。</p><h2 id="事件处理模式"><a href="#事件处理模式" class="headerlink" title="事件处理模式"></a>事件处理模式</h2><ul><li>reactor 模式中，主线程(<strong>I&#x2F;O 处理单元</strong>)只负责监听文件描述符上是否有事件发生，有的话立即通知工作线程(<strong>逻辑单元</strong> )，读写数据、接受新连接及处理客户请求均在工作线程中完成。通常由<strong>同步 I&#x2F;O</strong>实现。</li><li>proactor 模式中，主线程和内核负责处理读写数据、接受新连接等 I&#x2F;O 操作，工作线程仅负责业务逻辑，如处理客户请求。通常由<strong>异步 I&#x2F;O</strong>实现。</li></ul><h2 id="同步-I-x2F-O-模拟-proactor-模式"><a href="#同步-I-x2F-O-模拟-proactor-模式" class="headerlink" title="同步 I&#x2F;O 模拟 proactor 模式"></a>同步 I&#x2F;O 模拟 proactor 模式</h2><p>同步 I&#x2F;O 模型的工作流程如下（epoll_wait 为例）：</p><ul><li>主线程往 epoll 内核事件表注册 socket 上的读就绪事件。</li><li>主线程调用 epoll_wait 等待 socket 上有数据可读</li><li>当 socket 上有数据可读，epoll_wait 通知主线程,主线程从 socket 循环读取数据，直到没有更多数据可读，然后将读取到的数据封装成一个请求对象并插入请求队列。</li><li>睡眠在请求队列上某个工作线程被唤醒，它获得请求对象并处理客户请求，然后往 epoll 内核事件表中注册该 socket 上的写就绪事件</li><li>主线程调用 epoll_wait 等待 socket 可写。</li><li>当 socket 上有数据可写，epoll_wait 通知主线程。主线程往 socket 上写入服务器处理客户请求的结果。</li></ul><h2 id="并发编程模式"><a href="#并发编程模式" class="headerlink" title="并发编程模式"></a>并发编程模式</h2><p>并发编程方法的实现有多线程和多进程两种，但这里涉及的并发模式指 I&#x2F;O 处理单元与逻辑单元的协同完成任务的方法。</p><ul><li>半同步&#x2F;半异步模式</li><li>领导者&#x2F;追随者模式</li></ul><h2 id="半同步-x2F-半反应堆"><a href="#半同步-x2F-半反应堆" class="headerlink" title="半同步&#x2F;半反应堆"></a>半同步&#x2F;半反应堆</h2><p>半同步&#x2F;半反应堆并发模式是半同步&#x2F;半异步的变体，将半异步具体化为某种事件处理模式。</p><p><strong>并发模式中的同步和异步：</strong></p><ul><li>同步指的是程序完全按照代码序列的顺序执行</li><li>异步指的是程序的执行需要由系统事件驱动</li></ul><p><strong>半同步&#x2F;半异步模式工作流程</strong>:</p><ul><li>同步线程用于处理客户逻辑</li><li>异步线程用于处理 I&#x2F;O 事件</li><li>异步线程监听到客户请求后，就将其封装成请求对象并插入请求队列中</li><li>请求队列将通知某个工作在同步模式的工作线程来读取并处理该请求对象</li></ul><p><strong>半同步&#x2F;半反应堆工作流程（以 Proactor 模式为例）</strong></p><ul><li>主线程充当异步线程，负责监听所有 socket 上的事件</li><li>若有新请求到来，主线程接收之以得到新的连接 socket，然后往 epoll 内核事件表中注册该 socket 上的读写事件</li><li>如果连接 socket 上有读写事件发生，主线程从 socket 上接收数据，并将数据封装成请求对象插入到请求队列中</li><li>所有工作线程睡眠在请求队列上，当有任务到来时，通过竞争（如互斥锁）获得任务的接管权</li></ul><h2 id="线程池"><a href="#线程池" class="headerlink" title="线程池"></a>线程池</h2><ul><li>空间换时间,浪费服务器的硬件资源,换取运行效率.</li><li>池是一组资源的集合,这组资源在服务器启动之初就被完全创建好并初始化,这称为静态资源.</li><li>当服务器进入正式运行阶段,开始处理客户请求的时候,如果它需要相关的资源,可以直接从池中获取,无需动态分配.</li><li>当服务器处理完一个客户连接后,可以把相关的资源放回池中,无需执行系统调用释放资源.</li></ul><h2 id="select-x2F-poll-x2F-epoll"><a href="#select-x2F-poll-x2F-epoll" class="headerlink" title="select&#x2F;poll&#x2F;epoll"></a><strong>select&#x2F;poll&#x2F;epoll</strong></h2><ul><li><p>调用函数</p></li><li><ul><li>select 和 poll 都是一个函数，epoll 是一组函数</li></ul></li><li><p>文件描述符数量</p></li><li><ul><li>select 通过线性表描述文件描述符集合，文件描述符有上限，一般是 1024，但可以修改源码，重新编译内核，不推荐</li><li>poll 是链表描述，突破了文件描述符上限，最大可以打开文件的数目</li><li>epoll 通过红黑树描述，最大可以打开文件的数目，可以通过命令 ulimit -n number 修改，仅对当前终端有效</li></ul></li><li><p>将文件描述符从用户传给内核</p></li><li><ul><li>select 和 poll 通过将所有文件描述符拷贝到内核态，每次调用都需要拷贝</li><li>epoll 通过 epoll_create 建立一棵红黑树，通过 epoll_ctl 将要监听的文件描述符注册到红黑树上</li></ul></li><li><p>内核判断就绪的文件描述符</p></li><li><ul><li>select 和 poll 通过遍历文件描述符集合，判断哪个文件描述符上有事件发生</li><li>epoll_create 时，内核除了帮我们在 epoll 文件系统里建了个红黑树用于存储以后 epoll_ctl 传来的 fd 外，还会再建立一个 list 链表，用于存储准备就绪的事件，当 epoll_wait 调用时，仅仅观察这个 list 链表里有没有数据即可。</li><li>epoll 是根据每个 fd 上面的回调函数(中断函数)判断，只有发生了事件的 socket 才会主动的去调用 callback 函数，其他空闲状态 socket 则不会，若是就绪事件，插入 list</li></ul></li><li><p>应用程序索引就绪文件描述符</p></li><li><ul><li>select&#x2F;poll 只返回发生了事件的文件描述符的个数，若知道是哪个发生了事件，同样需要遍历</li><li>epoll 返回的发生了事件的个数和结构体数组，结构体包含 socket 的信息，因此直接处理返回的数组即可</li></ul></li><li><p>工作模式</p></li><li><ul><li>select 和 poll 都只能工作在相对低效的 LT 模式下</li><li>epoll 则可以工作在 ET 高效模式，并且 epoll 还支持 EPOLLONESHOT 事件，该事件能进一步减少可读、可写和异常事件被触发的次数。</li></ul></li><li><p>应用场景</p></li><li><ul><li>当所有的 fd 都是活跃连接，使用 epoll，需要建立文件系统，红黑书和链表对于此来说，效率反而不高，不如 selece 和 poll</li><li>当监测的 fd 数目较小，且各个 fd 都比较活跃，建议使用 select 或者 poll</li><li>当监测的 fd 数目非常大，成千上万，且单位时间只有其中的一部分 fd 处于就绪状态，这个时候使用 epoll 能够明显提升性能</li></ul></li></ul><h2 id="ET、LT、EPOLLONESHOT"><a href="#ET、LT、EPOLLONESHOT" class="headerlink" title="ET、LT、EPOLLONESHOT"></a>ET、LT、EPOLLONESHOT</h2><ul><li><p>LT 水平触发模式</p></li><li><ul><li>epoll_wait 检测到文件描述符有事件发生，则将其通知给应用程序，应用程序可以不立即处理该事件。</li><li>当下一次调用 epoll_wait 时，epoll_wait 还会再次向应用程序报告此事件，直至被处理</li></ul></li><li><p>ET 边缘触发模式</p></li><li><ul><li>epoll_wait 检测到文件描述符有事件发生，则将其通知给应用程序，应用程序必须立即处理该事件</li><li>必须要一次性将数据读取完，使用非阻塞 I&#x2F;O，读取到出现 eagain</li></ul></li><li><p>EPOLLONESHOT</p></li><li><ul><li>一个线程读取某个 socket 上的数据后开始处理数据，在处理过程中该 socket 上又有新数据可读，此时另一个线程被唤醒读取，此时出现两个线程处理同一个 socket</li><li>我们期望的是一个 socket 连接在任一时刻都只被一个线程处理，通过 epoll_ctl 对该文件描述符注册 epolloneshot 事件，一个线程处理 socket 时，其他线程将无法处理，<strong>当该线程处理完后，需要通过 epoll_ctl 重置 epolloneshot 事件</strong></li></ul></li></ul>]]></content>
    
    
    <categories>
      
      <category>知识储备</category>
      
    </categories>
    
    
    <tags>
      
      <tag>webserver</tag>
      
      <tag>linux</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>论文笔记之 pSCAN</title>
    <link href="/pSCAN.html"/>
    <url>/pSCAN.html</url>
    
    <content type="html"><![CDATA[<p>pSCAN 研究了结构图聚类问题，这是图数据管理和分析的基本问题。给定一个无向无权图，结构图聚类就是将顶点分配给簇，并识别中心顶点和离群顶点的集合，使得同一簇中的顶点彼此紧密连接，而不同簇中的顶点松散连接。</p><span id="more"></span><blockquote><p>pSCAN: Fast and Exact Structural Graph Clustering.Lijun Chang, Wei Li, Lu Qin, Wenjie Zhang, and Shiyu Yang.</p></blockquote><h2 id="1-Contributions："><a href="#1-Contributions：" class="headerlink" title="1.Contributions："></a>1.Contributions：</h2><ul><li>作者证明了现有的 SCAN 算法在最坏情况下最优的。</li><li>作者对结构图聚类做了三个观察，提出了可扩展结的两步范式，减少结构相似性计算。</li><li>此外，作者提供了优化技术加速检查两个顶点是否结构相似。</li></ul><h2 id="2-Three-observations"><a href="#2-Three-observations" class="headerlink" title="2.Three observations:"></a>2.Three observations:</h2><ol><li>结构图聚类中的聚类可能存在重叠。</li><li>核顶点的集群不相交。</li><li>非核心顶点的簇由核心顶点唯一确定。</li></ol><h2 id="3-Definition"><a href="#3-Definition" class="headerlink" title="3.Definition:"></a>3.Definition:</h2><ul><li>顶点 u 的结构领域 N[u] 为 u 的闭领域，即：N[u] &#x3D; {v ∈ V|(u,v) ∈ E} ∪ {u}。</li><li>顶点 u 和 v 之间的结构相似性定义为：N[u]和 N[v]中共有顶点的数量按其基数的几个平均值归一化。</li><li>给定相似度阈值 0 &lt; $\epsilon$ &lt;&#x3D; 1 和一个整数 $\mu$ ≥ 2，一个顶点是核心顶点如果 $N_{eps}$[u] ≥ $\mu$。</li><li>集群 C 是 V 的一个子集，它至少有两个顶点，则：<ul><li>（最大化）如果核心顶点 u∈C，那么所欲有从 u 到结构可达的顶点 v 也属于 C。</li><li>（连通性）对于任意两个顶点 $v_1$,$v_2$ ∈ C，有顶点 u ∈ C，使得 $v_1$ 和 $v_2$ 都可以从 u 可达。</li></ul></li><li>给定聚类 C，C 中不属于任何集群的顶点 u，如果它的邻居属于两个或者两个以上的集群，则为 hub，否则为 outlier。</li></ul><h2 id="4-Two-step-Paradigm"><a href="#4-Two-step-Paradigm" class="headerlink" title="4.Two-step Paradigm:"></a>4.Two-step Paradigm:</h2><ul><li>step-1：<u>聚类核心顶点</u>，把所有核心顶点分类到对应簇。</li><li>step-2：<u>聚类非核心顶点</u>，是 non-core 且和邻点 core 相似，分到 core 的簇中。</li></ul><img src="https://cdn.jsdelivr.net/gh/gejoyy/Pictures@main/image-20230627152627744.png" alt="pscan-algorithm-2" style="zoom: 67%;" /><h2 id="5-Algorithm"><a href="#5-Algorithm" class="headerlink" title="5.Algorithm"></a>5.Algorithm</h2><h3 id="5-1-pSCAN"><a href="#5-1-pSCAN" class="headerlink" title="5.1 pSCAN"></a>5.1 pSCAN</h3><p>算法目标是减少结构相似性计算的次数，把边分为 $E_{c,c}$，$E_{c,n}$，分别讨论。</p><img src="https://cdn.jsdelivr.net/gh/gejoyy/Pictures@main/image-20230627153257747.png" alt="pscan-algorithm-3" style="zoom:67%;" /><ul><li>行 1，初始化每个顶点成单个子集。</li><li>行 2-4，初始化每个顶点 sd(u), ed(u)。</li><li>行 5-7，按有效度 ed(u) 非递增顺序遍历顶点 u，检测 u 是否为 core，如果 u 是 core，把 u 和已经确定为 core 的邻点聚类到一起。</li><li>行 8-9，得到 core 顶点聚类 $C_c$，再聚类 non-core 顶点集合。</li><li>用不相交数据结构(disjoint-set data) 聚类 $G_c$ 中的 core，形成多个不相交的集合 S &#x3D; {s1, s2,…}<ul><li>find-subset：查看元素在哪一个子集中。</li><li>union：合并两个子集。</li></ul></li><li>union(u, v) 相当于在 $G_c$ 中添加一条边(u, v)。</li><li>两个顶点 u，v 属于同一连接组件（聚类）当且仅当 u，v 所在的子集相同，即：find-subset(u) &#x3D; find-subset(v)。</li></ul><p><strong>effective-degree: ed(u)</strong></p><ul><li>目的：为了减少相似度计算，按 ed(u) <strong>非递增</strong>顺序排序顶点。</li><li>定义：|N[u]|减去与 u 不相似的邻点的数量，得到可能相似的邻点的数量，满足 |$N_{eps}[u]$| ≤ ed(u)，ed(u) 是上界。</li><li>如果 ed(u) ≤ $\mu$，上界小于 $\mu$，则 u 是 non-core，从而减少<strong>顶点对 $E_{n,n}$ 的计算次数</strong>，对两个 non-core 顶点，不用计算它们之间相似度。</li></ul><p><strong>similar-degree: sd(u)</strong></p><ul><li>目的：为了有效检查一个顶点是否为 core。</li><li>定义：sd(u) 是已经确定与 u 相似的邻居的数量，满足|$N_{eps}[u]$| ≥ sd(u)，sd(u) 是下界。</li><li>如果 sd(u) ≥ $\mu$，下界大于 $\mu$，则 u 是 core。</li></ul><h3 id="5-2-CheckCore"><a href="#5-2-CheckCore" class="headerlink" title="5.2 CheckCore"></a>5.2 CheckCore</h3><p>目的：检测一个顶点是否为 core，减少顶点对 $E_{n,n}$的计算。</p><img src="https://cdn.jsdelivr.net/gh/gejoyy/Pictures@main/image-20230627153654828.png" alt="pscan-algorithm-4" style="zoom:67%;" /><ul><li>行 1，对于 ed(u) &lt; $\mu$（确定为 non-core）和 sd(u) ≥ $\mu$（确定 core）两种情况无需讨论，因为 ed(u) ≥ sd(u)，所以讨论第三种情况，ed(u) ≥ $\mu$ &gt;sd(u)，需要计算 u 和其邻居的相似性，<strong>以检测 u 是否为core</strong>。</li><li>行 2，初始化 ed(u)，sd(u)。</li><li>行 3-6，计算相似度，然后更新 ed(u)，sd(u)。</li><li>行 7-9，如果邻点 v 还没有被探索，更新 ed(v)，sd(v)，如果 ed(u) &lt; $\mu$ 或者 sd(u) ≥ $\mu$，则<strong>后面不需要探索 v</strong>，即可确定 v 是 core 还是 non-core。</li><li>行 10，知道确定 u 是 core 还是 non-core。</li><li>最后，标记 u 已被探索过，之后不需要更新 ed(u)，sd(u)。</li></ul><h3 id="5-3-ClusterCore"><a href="#5-3-ClusterCore" class="headerlink" title="5.3 ClusterCore"></a>5.3 ClusterCore</h3><p>目的：聚类核心顶点的邻居顶点（也是核心顶点），减少了 $E_{c,c}$ 相似对的计算。</p><img src="https://cdn.jsdelivr.net/gh/gejoyy/Pictures@main/image-20230627154338133.png" alt="pscan-algorithm-5" style="zoom:67%;" /><ul><li>行 1-3，将与 u 结构相似的核心顶点（同时也是 u 的邻居顶点）分配到与 u 相同的集群中。</li><li>行 4-6，N’[u] 表示已经被计算过结构相似性邻居顶点 v 的集合，对于每个尚未被计算的 u 的结构相似邻居 v，如果 u 和 v 尚未分配给相同的集群，并且 v 可能是 core，则计算相似度(u, v)。</li><li>行 7-9，若 v 未被探索，如果(u, v)结构相似，更新 sd，否则不相似，更新 ed。</li><li>行 10，若 v 确定为 core，并且(u, v)相似，合并 u，v 到同一个集群中，属于同一聚类。</li></ul><h3 id="5-4-ClusterNoncore"><a href="#5-4-ClusterNoncore" class="headerlink" title="5.4 ClusterNoncore"></a>5.4 ClusterNoncore</h3><p>目的：减少 $E_{c,n}$ 相似对的计算。</p><img src="https://cdn.jsdelivr.net/gh/gejoyy/Pictures@main/image-20230627154711792.png" alt="pscan-algorithm-6" style="zoom:60%;" /><ul><li>行 4-7，遍历核心顶点的每个邻居 v，如果 v 是 non-core 并且 v 不在 u 的集群（可能包含 non-core）里，计算相似度(u,v)，如果还没计算的话。</li><li>行 8，如果（u，v）相似，把 v 加入 u 的集群。</li><li>行 6，如果 sd(v) ≥ $\mu$（v 为 core）或者 v 属于 u 的集群，则不需要计算 u，v 的相似度。</li><li>思考：计算 core 的时候，能够得出其邻居是 non-core（ed &lt; $\mu$），则不需要探索 non-core。</li></ul><p><strong>bin-sort</strong>: 桶排序，桶号 i 表示有效度 ed(u) &#x3D; i，顶点放入对应桶里，有效度 ed 只会减少，每一个桶是单链表。</p><p><strong>adjacency list</strong>: 输入图存储为邻接表，N(u)以顶点 id 排序，实践中计算 N[u] ∩ N[v] 表现更好。</p><h3 id="5-5-Optimization-Techniques"><a href="#5-5-Optimization-Techniques" class="headerlink" title="5.5 Optimization Techniques"></a>5.5 Optimization Techniques</h3><ol><li><strong>Criss link：</strong> 交叉连接 (u,v) 和 (v,u)，相似度计算减少一半，对于 N[u] 和 (u,v)，用二分查找 N[v] 中相反边(v,u)</li><li><strong>Pruning Rule：</strong> 修剪规则有效决定 u，v 是否相似，若 d[u] &lt; $\epsilon^2$·d[v] 或者 d[v] &lt; $\epsilon^2$·d[u]，则 $\sigma$(u, v) &lt; $\mu$。</li></ol><img src="https://cdn.jsdelivr.net/gh/gejoyy/Pictures@main/image-20230627155057753.png" alt="pscan-algorithm-6" style="zoom:67%;" /><ol start="3"><li><strong>Adaptive Structural Similarity Checking：</strong><ul><li>cn(u, v) 是满足 u，v 相似的<strong>最小公共邻居数量</strong>。</li><li>cn(u, v) &#x3D; $\lceil\sigma\cdot\sqrt{d[u]\cdot d[v]}\rceil$。</li><li>顶点相似等价于 |N[u] ∩ N[v]| ≥ cn(u,v)。</li></ul></li></ol><img src="https://cdn.jsdelivr.net/gh/gejoyy/Pictures@main/image-20230627155232123.png" alt="pscan-algorithm-7" style="zoom:67%;" /><ul><li><strong>cn(u,v) &lt; min{$d_u,d_v$} 不可能相似（提前结束）</strong></li><li><strong>只要满足 公共邻居数量 ≥ cn(u,v)，退出 while，返回 true（提前结束）</strong></li></ul><h2 id="6-Dynameically-cluster-maintenance"><a href="#6-Dynameically-cluster-maintenance" class="headerlink" title="6.Dynameically cluster maintenance"></a>6.Dynameically cluster maintenance</h2><ul><li>经过 pSCAN 算法，我们已知道 1. 顶点 u 是否为 core，2.部分顶点是否相似。</li><li>由于剪枝算法，1) 存在一些顶点间是否相似并不知道 ；2) 一些顶点间具体相似值不知道。</li><li>为了维护聚类，维持以下两个数据：<ul><li>每个顶点，维护 sd(u)，或者说<strong>维护核心顶点的集合</strong>。、</li><li>每个边，维护 t(u, v) &#x3D; |N[u] ∩ N[v]|，t(u, v) 的值可能为 0(没有边)，为 1（没有边但有一个共同邻居）。</li></ul></li><li>在 pSCAN 算法过程中，维护 t(u, v)：<ul><li>若 u，v 相似，则 t(u, v) &gt; 0，反之 t &gt; 0，不一定相似（t&#x3D;1）。</li><li>若 u，v 不相似，则 t(u, v) &lt; 0 （不存在边，或者有边且有多个共同邻居但<strong>不相似</strong>，此时为负整数）。</li><li>其他情况，t(u, v) &#x3D; 0，对与未知的 t(x,y)值，默认 t(x,y)&#x3D;0。</li><li>此外 |t(u, v) | ≥ 2，则 |t(u, v) | &#x3D; |N[u] ∩ N[v]|，注意是<strong>绝对值</strong>，t 可能为负数（-2，-3，···）</li></ul></li></ul><h3 id="6-1-ClusterMaintenance"><a href="#6-1-ClusterMaintenance" class="headerlink" title="6.1 ClusterMaintenance"></a>6.1 ClusterMaintenance</h3><img src="https://cdn.jsdelivr.net/gh/gejoyy/Pictures@main/image-20230627155758739.png" alt="pscan-algorithm-8" style="zoom:67%;" /><h3 id="6-2-Maintaining-Core-Vertices"><a href="#6-2-Maintaining-Core-Vertices" class="headerlink" title="6.2 Maintaining Core Vertices"></a>6.2 Maintaining Core Vertices</h3><ul><li>定义 N[u, v] &#x3D; N[u] ∪ N[v]。</li><li>在插入或删除边（u，v）后，只有边相关顶点相似值可能改变，那些不在 N[u,v]的顶点相似值不变，可能从 core 变为 non-core，或相反，因此考虑 N[u,v] 中的顶点，维护核心顶点集合。</li></ul><h4 id="6-2-1-Edge-insert"><a href="#6-2-1-Edge-insert" class="headerlink" title="6.2.1 Edge insert"></a>6.2.1 <strong>Edge insert</strong></h4><p>对每个 w ∈ N[u, v]，维护 sd(w)，N[u, v]划分四个集合分别考虑。</p><ul><li><strong>w ∈ N(u) 但不属于 N(v)：</strong><ul><li>若 t(w, u) ≤ 0，则 t(w, u)，sd(w) 不改变，因为 $\sigma$(w, u) 变小了，不存在 u 从 non-core 变为 core。</li><li>若 t(w, u) &gt; 0 且 sd(w) &lt; $\mu$，即 w 是 non-core，则 w 还是 non-core，需要更新 t(w,u)，sd(w)。</li><li>若 t(w, u) &gt; 0 且 sd(w) ≥ $\mu$，即 w 是 core，需要更新 t(w,u)，sd(w)，如果 $sd’$(w) &lt; $\mu$，需要计算相似性，对那些 w 的邻接点 x，满足 t(w, x) &#x3D; 0，去检查 w 是否仍然为 core。</li></ul></li><li><strong>w ∈ N(v) 但不属于 N(u)，做法同上。</strong></li><li><strong>w ∈ N(u) ∩ N(v)：</strong><ul><li>w 是共同邻接点，则 $\sigma’$(w, u) &gt; $\sigma$(w, u)，相似度变大了，同理 $\sigma$(w,v) 也变大（三角形数加一）。</li><li>若更新前 w 是 core，更新后仍然为 core，也要更新 t(w, u), t(w,v)。</li><li>若更新前 w 是 non-core，则需要更新 t(w,u), t(w, v)，其他邻接点 x 满足 t(w,x) &#x3D; 0 决定 w 是一个 core 更新后。</li></ul></li><li><strong>对于顶点 u，v：</strong><ul><li>考虑 u，由于 sd(u) &lt; $\mu$ 并且 邻接点 x 满足 t(u, x) &#x3D; 0，即在更新后（删除边 x,u）u 可能成为 core，则计算|N[u] ∩ N[v]|，更新 t(u, x) 和 sd(u)。</li><li>对于其他 邻接点 y 满足 t(u, y) $\neq$ 0，t(u, y)已经被更新过，在插入边 (u,x) 时候。</li><li>对于 v，做法一样。</li></ul></li></ul><p><strong>MaintainCoreVertices</strong>: </p><ul><li>对应上面四种处理方法</li></ul><img src="https://cdn.jsdelivr.net/gh/gejoyy/Pictures@main/image-20230627160221009.png" alt="pscan-algorithm-9" style="zoom:80%;" /><ul><li>行 2-10，w ∈ N(v)\N(u)；</li><li>行 12-22，w ∈ N(u)∩N(v)；</li><li>行 23-26，处理 u，v。</li><li>三角形 t(u, v) &#x3D; |N[u] ∩ N[v]|，若（u，v）确定不相似（可以没有边），则 t(u, v) &#x3D; - t(u, v)，变成负数。</li><li>行 27-29，若 |t(x, y)| ≤ 1，则重新计算 |N[x] ∩ N[y]|，否则更新 t(x,y) &#x3D; |t(x,y)| + 三角形。</li><li>行 30，判断 x，y 是否相似，赋值 t(x, y) 正负号。</li></ul><h4 id="6-2-2-Edge-Deletion"><a href="#6-2-2-Edge-Deletion" class="headerlink" title="6.2.2 Edge Deletion"></a>6.2.2 Edge Deletion</h4><ul><li>对 w ∈ N[u,v]，维护 sd(w)，与 insert edge 做法相似。</li><li>w ∈ N[u] \ N[v]，有 $\sigma’$(w, u) &gt; $\sigma$(w, u)。</li><li>w ∈ N[u] ∩ N[v]，有 $\sigma’$(w, u) &lt; $\sigma$(w, u)。</li></ul><h3 id="6-3-Maintaining-Structral-Similarities"><a href="#6-3-Maintaining-Structral-Similarities" class="headerlink" title="6.3 Maintaining Structral Similarities"></a>6.3 Maintaining Structral Similarities</h3><ul><li>考虑 t (x, y) 不在 N[u, v]：<ul><li>t(x,y)可能为 0 ，对（x,y）∈ E，在运行 pSCAN，维护聚类时候，例如删除边(x,y)，则 t()&#x3D;0。</li><li>聚类 C 可能分成两部分，由于里面一些边从相似 <strong>变为</strong> 不相似。</li><li>存在一个边在 C 中，满足 t(x,y)&#x3D;0 且 $\sigma$(x, y) ≥ $\epsilon$，把两个集合连接成一个聚类。</li></ul></li><li>因此要考虑 t(x,y)&#x3D;0，但不是对所有 edge（x,y）满足 t(x,y)&#x3D;0 ，都要更新，会延迟更新信息时间，因此关键在于如何选取哪些边 t&#x3D;0。</li><li>若聚类 C 中所有边满足 t&gt;0，聚类能够获得通过 BFS，基于 sd()，t()。</li><li>对于聚类 C，如果满足以下条件，不需要探索聚类 C 中顶点去更新 t()：<ul><li>不存在边 从 t&gt;0 变成 t&lt;0；</li><li>不存在核心顶点的邻接边，满足 t() &#x3D; 0；</li></ul></li><li>因此对每一个 core，提出一个平衡值 AllCh，<code>AllCh(x) = true</code> 当且仅当聚类 C 中不存在核心顶点邻接边 t &#x3D; 0。</li></ul><img src="https://cdn.jsdelivr.net/gh/gejoyy/Pictures@main/image-20230627160648438.png" alt="pscan-algorithm-10" style="zoom:80%" align="center" /><ul><li>edge(x,y) 从 t(x,y)&gt;0 变成 t(x,y)&lt;0：<ul><li>若更新前 x 是 core，则对所有与 x 结构可达的 core 满足 <code>AllCh() = true</code>，计算所有未知的 t(·,·)（即 t&#x3D;0）。</li><li>对 y 做法同上。</li><li>若更新后 x 或 y，从 non-core 变成 core，则必定存在另一个邻接边从 t ≤ 0 变成 t ≥ 0。</li></ul></li><li>edge(x,y) 从 t(x,y)≤0 变成 t(x,y)&gt;0：<ul><li>若 x 从 non-core 变成 core，则计算未知 t(·,·)，对所有临界边。</li><li>对 y 做法同上。</li><li>若更新后 x 和 y 都是 core 且 AllCh(x) $\neq$ AllCh(y)，则计算未知的 t( , )，即 t 值为 0。</li></ul></li><li>AllCh(x) 初始化每个点为 <code>false</code>。</li><li>若 x 是 core，UpdateReachable(x)计算未知 t() 值，对所有聚类中的 core 且满足 <code>AllCh() = true</code>；否则 UpdateReachable(x) 等价于 UpdateReachable(y)，对每一个 y 的 core 邻接点。</li><li>注意如果 <code>AllCh(x) = true</code>，调用 UpdateReachable(x) 将什么都不做。</li></ul>]]></content>
    
    
    <categories>
      
      <category>论文笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>SCAN</tag>
      
      <tag>graph</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Java 面向对象</title>
    <link href="/java%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1.html"/>
    <url>/java%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1.html</url>
    
    <content type="html"><![CDATA[<p>Java面向对象具有以下三个主要特征：一、封装（Encapsulation）；二、继承（Inheritance）；三、多态（Polymorphism）。封装使得对象的内部状态和行为对外部不可见，这不仅提高了代码的可维护性和复用性，还可以保护数据的安全性。</p><span id="more"></span><h2 id="面向对象"><a href="#面向对象" class="headerlink" title="面向对象"></a>面向对象</h2><p>每种编程语言，都有自己的操纵内存中元素的方式。Java 中提供了基本数据类型，但这还不能满足编写程序时，需要抽象更加复杂数据类型的需要。因此，Java 中，允许开发者通过类创建自定义类型。</p><p>Java 世界有一句名言：一切皆为对象。这句话，你可能第一天学 Java 时，就听过了。这不仅仅是一句口号，也体现在 Java 的设计上。</p><ul><li>首先，所有 Java 类都继承自 <code>Object</code> 类（从这个名字，就可见一斑）。</li><li>几乎所有 Java 对象初始化时，都要使用 <code>new</code> 创建对象（基本数据类型、String、枚举特殊处理），对象存储在堆中。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">String</span> <span class="hljs-variable">s</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;abc&quot;</span>;<br><span class="hljs-type">String</span> <span class="hljs-variable">s</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>(<span class="hljs-string">&quot;abc&quot;</span>);<br></code></pre></td></tr></table></figure><p>其中，<code>String s</code> 定义了一个名为 s 的引用，它指向一个 <code>String</code> 类型的对象，而实际的对象是 <code>“abc”</code> 字符串。</p><p><strong>与 C&#x2F;C++ 这类语言不同，程序员只需要通过 <code>new</code> 创建一个对象，但不必负责销毁或结束一个对象。</strong>负责运行 Java 程序的 Java 虚拟机有一个垃圾回收器，它会监视 <code>new</code> 创建的对象，一旦发现对象不再被引用，则会释放对象的内存空间。</p><h3 id="封装"><a href="#封装" class="headerlink" title="封装"></a>封装</h3><p><strong>封装（Encapsulation）是指一种将抽象性函式接口的实现细节部份包装、隐藏起来的方法。</strong></p><p>封装最主要的作用在于我们能修改自己的实现代码，而不用修改那些调用我们代码的程序片段。</p><p>封装的优点：</p><ul><li>良好的封装能够减少耦合。</li><li>类内部的结构可以自由修改。</li><li>可以对成员变量进行更精确的控制。</li><li>隐藏信息，实现细节。</li></ul><p>实现封装的步骤：</p><ol><li>修改属性的可见性来限制对属性的访问（一般限制为 private）。</li><li>对每个值属性提供对外的公共方法访问，也就是创建一对赋取值方法，用于对私有属性的访问。</li></ol><h3 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h3><p><strong>继承（Inheritance）是子类继承父类的特征和行为，使得子类对象（实例）具有父类的实例域和方法，或子类从父类继承方法，使得子类具有父类相同的行为。</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 子类继承父类</span><br>class 父类 &#123;&#125;<br>class 子类 extends 父类 &#123;&#125;<br></code></pre></td></tr></table></figure><h4 id="继承的特性"><a href="#继承的特性" class="headerlink" title="继承的特性"></a>继承的特性</h4><ul><li>子类可以继承父类的属性和方法。需要注意的是，<strong>构造方法除外，构造方法只能被调用，而不能被继承。</strong></li><li>子类可以拥有自己的属性和方法，即子类可以对父类进行<strong>扩展</strong>。</li><li>子类可以用自己的方式实现父类的方法。</li><li>Java 的继承是<strong>单继承</strong>，但是可以多重继承，单继承就是一个子类只能继承一个父类，<strong>多重继承就是，例如 A 类继承 B 类，B 类继承 C 类</strong>（传递性质），所以按照关系就是 C 类是 B 类的父类，B 类是 A 类的父类，这是 Java 继承区别于 C++ 继承的一个特性。</li><li>提高了类之间的<strong>耦合性</strong>（继承的缺点，耦合度高就会造成代码之间的联系越紧密，代码独立性越差）。</li></ul><h4 id="继承关键字"><a href="#继承关键字" class="headerlink" title="继承关键字"></a>继承关键字</h4><p>继承可以使用 <code>extends</code> 和 <code>implements</code> 这两个关键字来实现继承，而且所有的类都是继承于 <code>java.lang.Object</code>，当一个类没有继承的两个关键字，则默认继承 <code>Object</code>（这个类在 <strong><code>java.lang</code></strong> 包中，所以不需要 **<code>import</code>**）祖先类。</p><h3 id="多态"><a href="#多态" class="headerlink" title="多态"></a>多态</h3><p><strong>多态(Polymorphism）是指在面向对象编程中，同一个类的对象在不同情况下表现出不同的行为和状态</strong>。 子类可以继承父类的属性和方法，子类对象可以直接使用父类中的方法和变量。 子类可以对从父类继承的方法进行<strong>重新实现</strong>，使得子类对象调用这个方法时表现出不同的行为。</p><h2 id="类"><a href="#类" class="headerlink" title="类"></a>类</h2><p>与大多数面向对象编程语言一样，Java 使用 <code>class</code>（类）关键字来表示自定义类型。自定义类型是为了更容易抽象现实事物。</p><p>在一个类中，可以设置一静一动两种元素：属性（静）和方法（动）。</p><ul><li><strong>属性（成员、字段）</strong> - 属性抽象的是事物的状态。</li><li><strong>方法（为函数）</strong> - 方法抽象的是事物的行为。</li></ul><h2 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h2><h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java">修饰符 返回值类型 方法名(参数类型 参数名)&#123;<br>    ...<br>    方法体<br>    ...<br>    <span class="hljs-keyword">return</span> 返回值;<br>&#125;<br></code></pre></td></tr></table></figure><p>方法包含一个方法头和一个方法体。下面是一个方法的所有部分：</p><ul><li><strong>修饰符：</strong>修饰符，这是可选的，告诉编译器如何调用该方法。定义了该方法的访问类型。</li><li><strong>返回值类型 ：</strong>方法可能有返回值。如果没有返回值，这种情况下，返回值类型应设为 void。</li><li><strong>方法名：</strong>是方法的实际名称。方法名和参数表共同构成方法签名。</li><li><strong>参数类型：</strong>参数像是一个占位符。当方法被调用时，传递值给参数。这个值被称为实参或变量。参数列表是指方法的参数类型、顺序和参数的个数。参数是可选的，方法可以不包含任何参数。</li><li><strong>方法体：</strong>方法体包含具体的语句，定义该方法的功能。</li></ul><h3 id="构造方法"><a href="#构造方法" class="headerlink" title="构造方法"></a>构造方法</h3><p>每个类都有构造方法。如果没有显式地为类定义任何构造方法，Java 编译器将会为该类提供一个默认构造方法。</p><p>在创建一个对象的时候，至少要调用一个构造方法。构造方法的名称必须与类同名，一个类可以有多个构造方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Puppy</span>&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">Puppy</span><span class="hljs-params">()</span>&#123;<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">Puppy</span><span class="hljs-params">(String name)</span>&#123;<br>        <span class="hljs-comment">// 这个构造器仅有一个参数：name</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h2><p>Java 支持的变量类型有：</p><ul><li><code>局部变量</code> - 类方法中的变量。</li><li><code>实例变量（也叫成员变量）</code> - 类方法外的变量，不过没有 <code>static</code> 修饰。</li><li><code>类变量（也叫静态变量）</code> - 类方法外的变量，用 <code>static</code> 修饰。</li></ul><h3 id="变量修饰符"><a href="#变量修饰符" class="headerlink" title="变量修饰符"></a>变量修饰符</h3><ul><li>访问级别修饰符 - 如果变量是实例变量或类变量，可以添加访问级别修饰符（public&#x2F;protected&#x2F;private）</li><li>静态修饰符 - 如果变量是类变量，需要添加 static 修饰</li><li>final - 如果变量使用 final 修饰符，就表示这是一个<strong>常量</strong>，<strong>不能被修改</strong>。</li></ul><h3 id="创建对象"><a href="#创建对象" class="headerlink" title="创建对象"></a>创建对象</h3><p>对象是根据类创建的。在 Java 中，使用关键字 new 来创建一个新的对象。创建对象需要以下三步：</p><ul><li><strong>声明</strong>：声明一个对象，包括对象名称和对象类型。</li><li><strong>实例化</strong>：使用关键字 new 来创建一个对象。</li><li><strong>初始化</strong>：使用 new 创建对象时，会调用构造方法初始化对象。</li></ul><h2 id="访问权限控制"><a href="#访问权限控制" class="headerlink" title="访问权限控制"></a>访问权限控制</h2><h3 id="代码组织"><a href="#代码组织" class="headerlink" title="代码组织"></a>代码组织</h3><p><strong>当编译一个 .java 文件时，在 .java 文件中的每个类都会输出一个与类同名的 .class 文件。</strong></p><p>MultiClassDemo.java 示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">MultiClass1</span> &#123;&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">MultiClass2</span> &#123;&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">MultiClass3</span> &#123;&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MultiClassDemo</span> &#123;&#125;<br></code></pre></td></tr></table></figure><p>执行 <code>javac MultiClassDemo.java</code> 命令，本地会生成 MultiClass1.class、MultiClass2.class、MultiClass3.class、MultiClassDemo.class 四个文件。</p><p><strong>Java 可运行程序是由一组 .class 文件打包并压缩成的一个 .jar 文件</strong>。Java 解释器负责这些文件的查找、装载和解释。<strong>Java 类库实际上是一组类文件（.java 文件）。</strong></p><ul><li><strong>其中每个文件允许有一个 public 类，以及任意数量的非 public 类</strong>。</li><li><strong>public 类名必须和 .java 文件名完全相同，包括大小写。</strong></li></ul><p>程序一般不止一个人编写，会调用系统提供的代码、第三方库中的代码、项目中其他人写的代码等，不同的人因为不同的目的可能定义同样的类名&#x2F;接口名，这就是命名冲突。</p><p>Java 中为了解决命名冲突问题，提供了包（<code>package</code>）和导入（<code>import</code>）机制。</p><h4 id="package"><a href="#package" class="headerlink" title="package"></a>package</h4><p>包（<code>package</code>）的原则：</p><ul><li>包类似于文件夹，文件放在文件夹中，类和接口则放在包中。为了便于组织，文件夹一般是一个<strong>有层次的树形结构</strong>，包也类似。</li><li><strong>包名以逗号 <code>.</code> 分隔，表示层次结构。</strong></li><li>Java 中命名包名的一个惯例是<strong>使用域名作为前缀</strong>，因为域名是唯一的，一般按照<strong>域名的反序来定义包名</strong>，比如，域名是：apache.org，包名就以 org.apache 开头。</li><li><strong>包名和文件目录结构必须完全匹配。</strong>Java 解释器运行过程如下：<ul><li>找出环境变量 CLASSPATH，作为 .class 文件的根目录。</li><li>从根目录开始，获取包名称，并将逗号 <code>.</code> 替换为文件分隔符（反斜杠 <code>/</code>），通过这个路径名称去查找 Java 类。</li></ul></li></ul><h4 id="import"><a href="#import" class="headerlink" title="import"></a>import</h4><p>同一个包下的类之间互相引用是不需要包名的，可以直接使用。但如果类不在同一个包内，则必须要知道其所在的包，使用有两种方式：</p><ul><li><p>通过类的完全限定名</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">PackageDemo</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span> <span class="hljs-params">(String[]args)</span>&#123;<br>        System.out.println(<span class="hljs-keyword">new</span> <span class="hljs-title class_">java</span>.util.Date());<br>        System.out.println(<span class="hljs-keyword">new</span> <span class="hljs-title class_">java</span>.util.Date());<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>通过 import 将用到的类引入到当前类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.util.Date;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">PackageDemo2</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        System.out.println(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Date</span>());<br>        System.out.println(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Date</span>());<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li></ul><p>显然是 <code>import</code> 方式，代码更加整洁。</p><h3 id="访问权限修饰关键字"><a href="#访问权限修饰关键字" class="headerlink" title="访问权限修饰关键字"></a>访问权限修饰关键字</h3><p>访问权限控制的等级，从最大权限到最小权限依次为：</p><figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs actionscript"><span class="hljs-keyword">public</span> &gt; <span class="hljs-keyword">protected</span> &gt; 包访问权限（没有任何关键字）&gt; <span class="hljs-keyword">private</span><br></code></pre></td></tr></table></figure><ul><li><code>public</code> - 表示任何类都可以访问；</li><li><code>包访问权限</code> - 包访问权限，没有任何关键字。它表示当前包中的所有其他类都可以访问，但是其它包的类无法访问。</li><li><code>protected</code> - 表示子类可以访问，此外，<strong>同一个包内的其他类也可以访问</strong>，即使这些类不是子类。</li><li><code>private</code> - 表示其它任何类都无法访问。</li></ul><h2 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h2><p>接口是对行为的抽象，它是抽象方法的集合，利用接口可以达到 API 定义和实现分离的目的。</p><p>接口，不能实例化；不能包含任何非常量成员，任何 field 都是隐含着 <code>public static final</code> 的意义；同时，没有非静态方法实现，<strong>也就是说要么是抽象方法，要么是静态方法</strong>。</p><p>Java 标准类库中，定义了非常多的接口，比如 <code>java.util.List</code>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">Comparable</span>&lt;T&gt; &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">compareTo</span><span class="hljs-params">(T o)</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="抽象类"><a href="#抽象类" class="headerlink" title="抽象类"></a>抽象类</h2><p>抽象类是不能实例化的类，用 <code>abstract</code> 关键字修饰 <code>class</code>，其目的主要是代码重用。除了不能实例化，形式上和一般的 Java 类并没有太大区别，可以有一个或者多个抽象方法，也可以没有抽象方法。抽象类大多用于抽取相关 Java 类的共用方法实现或者是共同成员变量，然后通过继承的方式达到代码复用的目的。</p><ol><li>抽象类不能被实例化(初学者很容易犯的错)，如果被实例化，就会报错，编译无法通过。只有抽象类的非抽象子类可以创建对象。</li><li>抽象类中不一定包含抽象方法，但是有抽象方法的类必定是抽象类。</li><li>抽象类中的抽象方法只是声明，不包含方法体，就是不给出方法的具体实现也就是方法的具体功能。</li><li>构造方法，类方法（用 static 修饰的方法）不能声明为抽象方法。</li><li>抽象类的子类必须给出抽象类中的抽象方法的具体实现，除非该子类也是抽象类。</li></ol><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul><li><a href="https://book.douban.com/subject/2130190/">Java 编程思想</a></li><li><a href="https://www.zhihu.com/question/20275578/answer/26577791">面向对象编程的弊端是什么？</a></li><li><a href="https://tobebetterjavaer.com/">Java程序员进阶之路</a></li></ul>]]></content>
    
    
    <categories>
      
      <category>Java 基础</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java</tag>
      
      <tag>oop</tag>
      
      <tag>类</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Java 数据类型</title>
    <link href="/java%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B.html"/>
    <url>/java%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B.html</url>
    
    <content type="html"><![CDATA[<p>Java 中的数据类型有两类：值类型（又叫内置数据类型，基本数据类型），引用类型（除值类型以外，都是引用类型，包括字符串、数组等）。</p><span id="more"></span><h2 id="数据类型分类"><a href="#数据类型分类" class="headerlink" title="数据类型分类"></a>数据类型分类</h2><p>Java 数据类型分为值类型和引用类型：</p><ul><li>值类型包括：boolean、char、byte、short、int、long、float 、double。</li><li>引用类型包括：数组、类、接口、枚举。</li></ul><h3 id="值类型"><a href="#值类型" class="headerlink" title="值类型"></a>值类型</h3><p>Java 语言提供了 <strong>8</strong> 种基本类型，大致分为 <strong>4</strong> 类。</p><table><thead><tr><th>基本数据类型</th><th>分类</th><th>比特数</th><th>默认值</th><th>取值范围</th></tr></thead><tbody><tr><td><code>boolean</code></td><td><strong>布尔型</strong></td><td>8 位</td><td><code>false</code></td><td>{false, true}</td></tr><tr><td><code>char</code></td><td><strong>字符型</strong></td><td>16 位</td><td><code>&#39;\u0000&#39;</code></td><td>[0, $2^{16} - 1$]</td></tr><tr><td><code>byte</code></td><td><strong>整数型</strong></td><td>8 位</td><td><code>0</code></td><td>[-$2^7$, $2^7 - 1$]</td></tr><tr><td><code>short</code></td><td><strong>整数型</strong></td><td>16 位</td><td><code>0</code></td><td>[-$2^{15}$, $2^{15} - 1$]</td></tr><tr><td><code>int</code></td><td><strong>整数型</strong></td><td>32 位</td><td><code>0</code></td><td>[-$2^{31}$, $2^{31} - 1$]</td></tr><tr><td><code>long</code></td><td><strong>整数型</strong></td><td>64 位</td><td><code>0L</code></td><td>[-$2^{63}$, $2^{63} - 1$]</td></tr><tr><td><code>float</code></td><td><strong>浮点型</strong></td><td>32 位</td><td><code>+0.0F</code></td><td>[$2^{-149}$, $2^{128} - 1$]</td></tr><tr><td><code>double</code></td><td><strong>浮点型</strong></td><td>64 位</td><td><code>+0.0D</code></td><td>[$2^{-1074}$, $2^{1024} - 1$]</td></tr></tbody></table><p>尽管各种数据类型的默认值看起来不一样，但在内存中都是零。</p><p>在这些基本类型中，<code>boolean</code> 和 <code>char</code> 是唯二的无符号类型。</p><h3 id="值类型和引用类型的区别"><a href="#值类型和引用类型的区别" class="headerlink" title="值类型和引用类型的区别"></a>值类型和引用类型的区别</h3><ul><li>从概念方面来说<ul><li>基本类型：变量名指向具体的数值。</li><li>引用类型：变量名指向存数据对象的内存地址。</li></ul></li><li>从内存方面来说<ul><li>基本类型：变量在声明之后，Java 就会立刻分配给他内存空间。</li><li>引用类型：它以特殊的方式（类似 C 指针）向对象实体（具体的值），这类变量声明时不会分配内存，只是存储了一个内存地址。</li></ul></li><li>从使用方面来说<ul><li>基本类型：使用时需要赋具体值,判断时使用 <code>==</code> 号。</li><li>引用类型：使用时可以赋 null，判断时使用 <code>equals</code> 方法。</li></ul></li></ul><h2 id="数据转换"><a href="#数据转换" class="headerlink" title="数据转换"></a>数据转换</h2><p>Java 中，数据类型转换有两种方式：</p><ul><li>自动转换</li><li>强制转换</li></ul><h3 id="自动转换"><a href="#自动转换" class="headerlink" title="自动转换"></a>自动转换</h3><p>一般情况下，定义了某数据类型的变量，就不能再随意转换。但是 JAVA 允许用户对基本类型做<strong>有限度</strong>的类型转换。</p><p>如果符合以下条件，则 JAVA 将会自动做类型转换：</p><ul><li><p><strong>由小数据转换为大数据</strong>，显而易见的是，“小”数据类型的数值表示范围小于“大”数据类型的数值表示范围，即精度小于“大”数据类型。这些类型由“小”到“大”分别为：(byte，short，char) &lt; int &lt; long &lt; float &lt; double。</p></li><li><p><strong>转换前后的数据类型要兼容</strong>，由于 boolean 类型只能存放 true 或 false，这与整数或字符是不兼容的，因此不可以做类型转换。</p></li><li><p><strong>整型类型和浮点型进行计算后，结果会转为浮点类型</strong></p></li></ul><p>例如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">long</span> <span class="hljs-variable">x</span> <span class="hljs-operator">=</span> <span class="hljs-number">30</span>;<br><span class="hljs-type">float</span> <span class="hljs-variable">y</span> <span class="hljs-operator">=</span> <span class="hljs-number">14.3f</span>;<br>System.out.println(<span class="hljs-string">&quot;x/y = &quot;</span> + x/y);<br></code></pre></td></tr></table></figure><p>输出：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">x/y = <span class="hljs-number">1.9607843</span><br></code></pre></td></tr></table></figure><p>可见 long 虽然精度大于 float 类型，但是结果为浮点数类型。</p><h3 id="强制转换"><a href="#强制转换" class="headerlink" title="强制转换"></a>强制转换</h3><p>在不符合自动转换条件时或者根据用户的需要，可以对数据类型做强制的转换。</p><p><strong>强制转换使用括号 <code>()</code> 。</strong></p><p>引用类型也可以使用强制转换。</p><p>例如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">float</span> <span class="hljs-variable">f</span> <span class="hljs-operator">=</span> <span class="hljs-number">25.5f</span>;<br><span class="hljs-type">int</span> <span class="hljs-variable">x</span> <span class="hljs-operator">=</span> (<span class="hljs-type">int</span>)f;<br>System.out.println(<span class="hljs-string">&quot;x = &quot;</span> + x);<br></code></pre></td></tr></table></figure><h2 id="装箱和拆箱"><a href="#装箱和拆箱" class="headerlink" title="装箱和拆箱"></a>装箱和拆箱</h2><p><strong>引入包装类的目的</strong>就是：提供一种机制，使得<strong>基本数据类型可以与引用类型互相转换</strong>。</p><p>基本数据类型与包装类的转换被称为<code>装箱</code>和<code>拆箱</code>。</p><ul><li><strong><code>装箱</code>（boxing）是将值类型转换为引用类型</strong>。例如：<code>int</code> 转 <code>Integer</code><ul><li>装箱过程是通过调用包装类的 <code>valueOf</code> 方法实现的。</li></ul></li><li><strong><code>拆箱</code>（unboxing）是将引用类型转换为值类型</strong>。例如：<code>Integer</code> 转 <code>int</code><ul><li>拆箱过程是通过调用包装类的 <code>xxxValue</code> 方法实现的。（xxx 代表对应的基本数据类型）。</li></ul></li></ul><h3 id="包装器类型"><a href="#包装器类型" class="headerlink" title="包装器类型"></a>包装器类型</h3><ul><li>Byte（对应 byte）</li><li>Short（对应 short）</li><li>Integer（对应 int）</li><li>Long（对应 long）</li><li>Float（对应 float）</li><li>Double（对应 double）</li><li>Character（对应 char）</li><li>Boolean（对应 boolean）</li></ul><h3 id="自动装箱"><a href="#自动装箱" class="headerlink" title="自动装箱"></a><strong>自动装箱</strong></h3><p>隐式地创建对象</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">Integer</span> <span class="hljs-variable">i1</span> <span class="hljs-operator">=</span> <span class="hljs-number">10</span>; <span class="hljs-comment">// 自动装箱</span><br><span class="hljs-type">Integer</span> <span class="hljs-variable">i2</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Integer</span>(<span class="hljs-number">10</span>); <span class="hljs-comment">// 非自动装箱</span><br><span class="hljs-type">Integer</span> <span class="hljs-variable">i3</span> <span class="hljs-operator">=</span> Integer.valueOf(<span class="hljs-number">10</span>); <span class="hljs-comment">// 非自动装箱</span><br><span class="hljs-type">int</span> <span class="hljs-variable">i4</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Integer</span>(<span class="hljs-number">10</span>); <span class="hljs-comment">// 自动拆箱</span><br><span class="hljs-type">int</span> <span class="hljs-variable">i5</span> <span class="hljs-operator">=</span> i2.intValue(); <span class="hljs-comment">// 非自动拆箱</span><br></code></pre></td></tr></table></figure><p>注意：</p><ul><li>对于 <code>i1 == i2</code> 输出为 <code>false</code>，因为 i1 和 i2 都是包装类，java 将它们当作两个<strong>对象</strong>，自然不相等。</li><li>对于 <code>i1 == i4</code> 输出为 <code>true</code>，因为 i4 为值，java 自动将 i1 这个包装类<strong>自动拆箱</strong>为一个 <code>int</code> 值。</li></ul><h3 id="装箱、拆箱注意点"><a href="#装箱、拆箱注意点" class="headerlink" title="装箱、拆箱注意点"></a>装箱、拆箱注意点</h3><ol><li>装箱操作会创建对象，频繁的装箱操作会造成不必要的内存消耗，影响性能。所以<strong>应该尽量避免装箱。</strong></li><li>基础数据类型的比较操作使用 <code>==</code>，包装类的比较操作使用 <code>equals</code> 方法。</li></ol><h2 id="判等问题"><a href="#判等问题" class="headerlink" title="判等问题"></a>判等问题</h2><p>Java 中，通常使用 <code>equals</code> 或 <code>==</code> 进行判等操作。<code>equals</code> 是方法而 <code>==</code> 是操作符。此外，二者使用也是有区别的：</p><ul><li>对<strong>基本类型</strong>，比如 <code>int</code>、<code>long</code>，进行判等，<strong>只能使用 <code>==</code>，比较的是字面值</strong>。因为基本类型的值就是其数值。</li><li>对<strong>引用类型</strong>，比如 <code>Integer</code>、<code>Long</code> 和 <code>String</code>，进行判等，<strong>需要使用 <code>equals</code> 进行内容判等</strong>。因为引用类型的直接值是指针，使用 <code>==</code> 的话，比较的是指针，也就是两个对象在内存中的地址，即比较它们是不是同一个对象，而不是比较对象的内容。</li></ul><h3 id="包装类的判等"><a href="#包装类的判等" class="headerlink" title="包装类的判等"></a>包装类的判等</h3><p>【示例】包装类的判等</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">Integer</span> <span class="hljs-variable">a</span> <span class="hljs-operator">=</span> <span class="hljs-number">127</span>; <span class="hljs-comment">//Integer.valueOf(127)</span><br><span class="hljs-type">Integer</span> <span class="hljs-variable">b</span> <span class="hljs-operator">=</span> <span class="hljs-number">127</span>; <span class="hljs-comment">//Integer.valueOf(127)</span><br><span class="hljs-comment">// a == b ? true</span><br><br><span class="hljs-type">Integer</span> <span class="hljs-variable">c</span> <span class="hljs-operator">=</span> <span class="hljs-number">128</span>; <span class="hljs-comment">//Integer.valueOf(128)</span><br><span class="hljs-type">Integer</span> <span class="hljs-variable">d</span> <span class="hljs-operator">=</span> <span class="hljs-number">128</span>; <span class="hljs-comment">//Integer.valueOf(128)</span><br><span class="hljs-comment">// c == d ? alse</span><br><span class="hljs-comment">//设置-XX:AutoBoxCacheMax=1000再试试</span><br><br><span class="hljs-type">Integer</span> <span class="hljs-variable">e</span> <span class="hljs-operator">=</span> <span class="hljs-number">127</span>; <span class="hljs-comment">//Integer.valueOf(127)</span><br><span class="hljs-type">Integer</span> <span class="hljs-variable">f</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Integer</span>(<span class="hljs-number">127</span>); <span class="hljs-comment">//new instance</span><br><span class="hljs-comment">// e == f ? false</span><br><br><span class="hljs-type">Integer</span> <span class="hljs-variable">g</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Integer</span>(<span class="hljs-number">127</span>); <span class="hljs-comment">//new instance</span><br><span class="hljs-type">Integer</span> <span class="hljs-variable">h</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Integer</span>(<span class="hljs-number">127</span>); <span class="hljs-comment">//new instance</span><br><span class="hljs-comment">// g == h ? false</span><br><br><span class="hljs-type">Integer</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">128</span>; <span class="hljs-comment">//unbox</span><br><span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">128</span>;<br><span class="hljs-comment">// i == j ? true</span><br></code></pre></td></tr></table></figure><ul><li><p>第一个案例中，编译器会把 <code>Integer a = 127</code> 转换为 <code>Integer.valueOf(127)</code>。查看源码可以发现，这个转换在内部其实做了缓存，<strong>使得两个 Integer 指向同一个对象</strong>，所以 &#x3D;&#x3D; 返回 true。</p></li><li><p>第二个案例中，之所以同样的代码 128 就返回 false 的原因是，默认情况下会缓存[-128,127]的数值，而 128 处于这个区间之外。设置 JVM 参数加上 -XX:AutoBoxCacheMax&#x3D;1000 再试试，是不是就返回 true 了呢？</p></li><li><p>第三和第四个案例中，New 出来的 Integer 始终是<strong>不走缓存的新对象</strong>。比较两个新对象，或者比较一个新对象和一个来自缓存的对象，结果肯定不是相同的对象，因此返回 false。</p></li><li><p>第五个案例中，我们把装箱的 Integer 和基本类型 int 比较，前者会先拆箱再比较，比较的肯定是<strong>数值</strong>而不是引用，因此返回 true。</p></li></ul><blockquote><p>【总结】综上，我们可以得出结论：包装类需要使用 <code>equals</code> 进行内容判等，而不能使用 <code>==</code>。</p></blockquote><h3 id="String-的判等"><a href="#String-的判等" class="headerlink" title="String 的判等"></a>String 的判等</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">String</span> <span class="hljs-variable">a</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;1&quot;</span>;<br><span class="hljs-type">String</span> <span class="hljs-variable">b</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;1&quot;</span>;<br><span class="hljs-comment">// a == b ? true</span><br><br><span class="hljs-type">String</span> <span class="hljs-variable">c</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>(<span class="hljs-string">&quot;2&quot;</span>);<br><span class="hljs-type">String</span> <span class="hljs-variable">d</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>(<span class="hljs-string">&quot;2&quot;</span>);<br><span class="hljs-comment">// c == d ? false</span><br><br><span class="hljs-type">String</span> <span class="hljs-variable">e</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>(<span class="hljs-string">&quot;3&quot;</span>).intern(); <span class="hljs-comment">// 走常量池机制</span><br><span class="hljs-type">String</span> <span class="hljs-variable">f</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>(<span class="hljs-string">&quot;3&quot;</span>).intern();<br><span class="hljs-comment">// e == f ? true</span><br><br><span class="hljs-type">String</span> <span class="hljs-variable">g</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>(<span class="hljs-string">&quot;4&quot;</span>);<br><span class="hljs-type">String</span> <span class="hljs-variable">h</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>(<span class="hljs-string">&quot;4&quot;</span>);<br><span class="hljs-comment">// g.equals(h)) ? true</span><br></code></pre></td></tr></table></figure><blockquote><p>在 JVM 中，当代码中出现双引号形式创建<strong>字符串对象</strong>时，JVM 会先对这个字符串进行检查，如果字符串常量池中存在相同内容的字符串对象的引用，则将这个引用返回；否则，创建新的字符串对象，然后将这个引用放入字符串常量池，并返回该引用。这种机制，就是<strong>字符串驻留或池化</strong>。</p></blockquote><ul><li><p>第一个案例返回 true，因为 Java 的字符串<strong>驻留机制</strong>，直接使用双引号声明出来的两个 String 对象指向<strong>常量池</strong>中的相同字符串。</p></li><li><p>第二个案例，new 出来的两个 String 是不同对象，引用当然不同，所以得到 false 的结果。</p></li><li><p>第三个案例，使用 String 提供的 intern 方法也会<strong>走常量池机制</strong>，所以同样能得到 true。</p></li><li><p>第四个案例，通过 equals 对值内容判等，是正确的处理方式，当然会得到 true。</p></li></ul><p><em>虽然使用 new 声明的字符串调用 intern 方法，也可以让字符串进行驻留，但在业务代码中滥用 intern，可能会产生性能问题。</em></p><p><strong>原因</strong>在于：字符串常量池是一个固定容量的 <strong>Map</strong>。如果容量太小（Number of buckets&#x3D;60013）、字符串太多（1000 万个字符串），那么每一个桶中的字符串数量会非常多，所以搜索起来就很慢。</p><p><strong>解决方法</strong>是：设置 JVM 参数 -XX:StringTableSize&#x3D;10000000，指定更多的桶。</p><h3 id="实现-equals"><a href="#实现-equals" class="headerlink" title="实现 equals"></a>实现 equals</h3><p>Object 类源码里 equals 的实现其实是比较对象引用</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">equals</span><span class="hljs-params">(Object obj)</span> &#123;<br>    <span class="hljs-keyword">return</span> (<span class="hljs-built_in">this</span> == obj);<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>对于自定义类型，如果不覆写 equals 的话，默认就是使用 Object 基类的按引用的比较方式。</strong></p><p>实现一个更好的 equals 应该注意的点：</p><ul><li>考虑到性能，可以先进行指针判等，如果对象是同一个那么直接返回 true；</li><li>需要对另一方进行判空，空对象和自身进行比较，结果一定是 fasle；</li><li>需要判断两个对象的类型，如果类型都不同，那么直接返回 false；</li><li>确保类型相同的情况下再进行类型强制转换，然后逐一判断所有字段。</li></ul><p>自定义 equals 示例</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 自定义类</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Point</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> x;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> y;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> String desc;<br>&#125;<br><br><span class="hljs-comment">// 自定义equals：</span><br><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">equals</span><span class="hljs-params">(Object o)</span> &#123;<br>    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">this</span> == o) <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    <span class="hljs-keyword">if</span> (o == <span class="hljs-literal">null</span> || getClass() != o.getClass()) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    <span class="hljs-type">Point</span> <span class="hljs-variable">that</span> <span class="hljs-operator">=</span> (Point) o;<br>    <span class="hljs-keyword">return</span> x == that.x &amp;&amp; y == that.y;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="数值计算"><a href="#数值计算" class="headerlink" title="数值计算"></a>数值计算</h2><h3 id="浮点数计算问题"><a href="#浮点数计算问题" class="headerlink" title="浮点数计算问题"></a>浮点数计算问题</h3><p>计算机是把数值保存在了变量中，不同类型的数值变量能保存的数值范围不同，当数值超过类型能表达的数值上限则会发生溢出问题。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java">System.out.println(<span class="hljs-number">0.1</span> + <span class="hljs-number">0.2</span>); <span class="hljs-comment">// 0.30000000000000004</span><br>System.out.println(<span class="hljs-number">1.0</span> - <span class="hljs-number">0.8</span>); <span class="hljs-comment">// 0.19999999999999996</span><br>System.out.println(<span class="hljs-number">4.015</span> * <span class="hljs-number">100</span>); <span class="hljs-comment">// 401.49999999999994</span><br>System.out.println(<span class="hljs-number">123.3</span> / <span class="hljs-number">100</span>); <span class="hljs-comment">// 1.2329999999999999</span><br><span class="hljs-type">double</span> <span class="hljs-variable">amount1</span> <span class="hljs-operator">=</span> <span class="hljs-number">2.15</span>;<br><span class="hljs-type">double</span> <span class="hljs-variable">amount2</span> <span class="hljs-operator">=</span> <span class="hljs-number">1.10</span>;<br>System.out.println(amount1 - amount2); <span class="hljs-comment">// 1.0499999999999998</span><br></code></pre></td></tr></table></figure><p>出现上述结果的原因是，计算机以<strong>二进制</strong>存储数值，，浮点数也不例外。比如，0.1 的二进制表示为 0.0 0011 0011 0011… （0011 无限循环)，再转换为十进制就是0.1000000000000000055511151231257827021181583404541015625。对于计算机而言，0.1 无法精确表达，这是浮点数计算造成精度损失的根源。</p><h3 id="使用-BigDecimal"><a href="#使用-BigDecimal" class="headerlink" title="使用 BigDecimal"></a>使用 BigDecimal</h3><p>BigDecimal 是不可变的，可以用来表示任意精度的带符号十进制数。double的问题是从小数点转换到二进制丢失精度，二进制丢失精度。BigDecimal在处理的时候把十进制小数扩大N倍让它在整数上进行计算，并保留相应的精度信息。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">BigDecimal</span> <span class="hljs-variable">bigDecimal</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">BigDecimal</span>(<span class="hljs-number">0.1</span>);<br>System.out.println(<span class="hljs-string">&quot;bigDecimal值为: &quot;</span> + bigDecimal);<br><span class="hljs-comment">//输出  0.1000000000000000055511151231257827021181583404541015625</span><br><br>System.out.println(String.format(<span class="hljs-string">&quot;%.1f&quot;</span>, bigDecimal)); <span class="hljs-comment">// 0.1</span><br></code></pre></td></tr></table></figure><p>参数类型为double的构造方法的结果有一定的<strong>不可预知性</strong>，需要通过格式化输出！</p><p><u><strong>推荐使用字符串为形参传入构造函数</strong></u></p><ul><li><p>String 类型参的构造方法是<strong>完全可预知的</strong>。比如 new BigDecimal(“0.1”) 将创建一个 BigDecimal对象，它正好等于预期的 0.1。因此优先使用String构造方法。</p></li><li><p>当是形参为浮点数时，推荐先将<strong>浮点数转换为字符串类型</strong>然后放入构造函数中。例如:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">BigDecimal</span> <span class="hljs-variable">bigDecimal</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">BigDecimal</span>(Double.toString(<span class="hljs-number">2.1</span>));<br><span class="hljs-comment">/* 或者 */</span><br><span class="hljs-type">BigDecimal</span> <span class="hljs-variable">bigDecimal1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">BigDecimal</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Double</span>(<span class="hljs-number">2.1</span>).toString());<br></code></pre></td></tr></table></figure></li></ul><h3 id="BigDecimal-判等问题"><a href="#BigDecimal-判等问题" class="headerlink" title="BigDecimal 判等问题"></a>BigDecimal 判等问题</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">wrong</span><span class="hljs-params">()</span> &#123;<br>    System.out.println(<span class="hljs-keyword">new</span> <span class="hljs-title class_">BigDecimal</span>(<span class="hljs-string">&quot;1.0&quot;</span>).equals(<span class="hljs-keyword">new</span> <span class="hljs-title class_">BigDecimal</span>(<span class="hljs-string">&quot;1&quot;</span>))); <span class="hljs-comment">//false</span><br>&#125;<br><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">right</span><span class="hljs-params">()</span> &#123;<br>    System.out.println(<span class="hljs-keyword">new</span> <span class="hljs-title class_">BigDecimal</span>(<span class="hljs-string">&quot;1.0&quot;</span>).compareTo(<span class="hljs-keyword">new</span> <span class="hljs-title class_">BigDecimal</span>(<span class="hljs-string">&quot;1&quot;</span>)) == <span class="hljs-number">0</span>); <span class="hljs-comment">//true</span><br>&#125;<br></code></pre></td></tr></table></figure><p>BigDecimal 的 equals 方法的注释中说明了原因，equals 比较的是 BigDecimal 的 value 和 scale，1.0 的 scale 是 1，1 的 scale 是 0，所以结果一定是 false。</p><p><strong>如果只比较 BigDecimal 的 value，可以使用 compareTo 方法</strong>。</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul><li><p><a href="https://tobebetterjavaer.com/basic-grammar/basic-data-type.html">Java数据类型</a></p></li><li><p><a href="https://book.douban.com/subject/2130190/">《Java 编程思想（Thinking in java）》</a></p></li><li><p><a href="https://juejin.im/post/59cd71835188255d3448faf6">Java 基本数据类型和引用类型</a></p></li><li><p><a href="https://www.cnblogs.com/dolphin0520/p/3780005.html">深入剖析 Java 中的装箱和拆箱</a></p></li></ul>]]></content>
    
    
    <categories>
      
      <category>Java 基础</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java</tag>
      
      <tag>数据类型</tag>
      
      <tag>值类型</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>cpp 笔记</title>
    <link href="/cpp-note.html"/>
    <url>/cpp-note.html</url>
    
    <content type="html"><![CDATA[<p>刷代码随想录过程中记得笔记。</p><span id="more"></span><h3 id="常用函数"><a href="#常用函数" class="headerlink" title="常用函数"></a>常用函数</h3><ul><li><p>在<code>sort</code>中使用 lambda 表示式：<code>sort(arr.begin(), arr.end(), [](int a, int b)-&gt;bool &#123;return a &gt; b; &#125;);</code>。</p></li><li><p><code>s = s1.substr(pos, len)</code>从 pos 位置开始，长度为 len 的子串。</p></li><li><p><code>str[i] = tolower(str[i]);</code>大写字母转小写，<code>str[i] = toupper(str[i]);</code>小写字母转大写。</p></li><li><p><code>bool binary_search(arr.begin(), arrr.end(), 3)</code>返回 <strong>bool</strong>。</p></li><li><p>getline 按逗号分割字符串：</p></li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs cpp">vector&lt;string&gt; strs;<br><span class="hljs-function">stringstream <span class="hljs-title">ss</span><span class="hljs-params">(line)</span></span>;<br>string str;<br><span class="hljs-keyword">while</span> (<span class="hljs-built_in">getline</span>(ss, str, <span class="hljs-string">&#x27;,&#x27;</span>)) &#123;<br>     strs.<span class="hljs-built_in">push_back</span>(str);<br>&#125;<br></code></pre></td></tr></table></figure><ul><li><p>把 “ab” 换成 “####”：<code>str=str.replace(str.find(&quot;a&quot;),2,&quot;####&quot;);</code></p></li><li><p>有序列表中二分查找 <code>lower_bound (begin, last, val, compare)</code> 找到<mark>大于等于 val</mark>的位置，<code>upper_bound (begin, last, val, compare)</code>找到<mark>大于 val</mark>的位置。</p></li><li><p><code>uique (begin,last)</code> 左闭右开区间。</p></li><li><p><code>string.erase(pos)</code> <code>string.erase(first, last)</code>通过迭代器删除元素。</p></li><li><p><strong>remove 和 rease 搭配删除所有指定值，remove 将元素移到末尾，没有改变 size</strong>：</p></li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs cpp">vector&lt;<span class="hljs-type">int</span>&gt; vec = &#123; <span class="hljs-number">1</span>,<span class="hljs-number">1</span>,<span class="hljs-number">1</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>,<span class="hljs-number">6</span>,<span class="hljs-number">7</span>,<span class="hljs-number">8</span>&#125;;<br>vec.<span class="hljs-built_in">erase</span>(<span class="hljs-built_in">remove</span>(vec.<span class="hljs-built_in">begin</span>(), vec.<span class="hljs-built_in">end</span>(), <span class="hljs-number">1</span>), vec.<span class="hljs-built_in">end</span>());<br><span class="hljs-comment">// vec = &#123;3,4,5,6,7,8&#125;</span><br></code></pre></td></tr></table></figure><ul><li><p><code>nth_element(begin, last, nth, comp)</code>默认升序排列，找到第 nth 大的元素，移到第 nth 的位置。</p></li><li><p>利用 bitset 进行任意进制转二进制：</p></li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// stol() 第二个参数默认为 NULL，第三个默认 10 进制，可 8/16 进制</span><br><span class="hljs-function">bitset&lt;16&gt; <span class="hljs-title">bin</span><span class="hljs-params">(stol(t, <span class="hljs-literal">nullptr</span>, <span class="hljs-number">16</span>))</span></span>;   先转为 <span class="hljs-type">long</span>，通过 bitset 转为二进制 <span class="hljs-number">16</span> 位<br>string s = bin.<span class="hljs-built_in">to_string</span>();<br></code></pre></td></tr></table></figure><h3 id="ACM-模式输入输出"><a href="#ACM-模式输入输出" class="headerlink" title="ACM 模式输入输出"></a>ACM 模式输入输出</h3><ul><li><p>用 while 循环读取字符串时，输入<code>Ctrl+X</code>标志终止输入。</p></li><li><p><code>#include &lt;bits/stdc++.h&gt;</code>，万能头文件。</p></li><li><p><code>using namespace std;</code>，定义域名空间。</p></li><li><p><code>while (getchar() != &#39;\n&#39;) &#123; 判断换行符号&#125;</code>，<strong>读取一行内任意个数元素</strong>。</p></li><li><p><code>getchar()</code>，从缓冲区取一个字符，缓冲区少一个字符。</p></li></ul><h3 id="List"><a href="#List" class="headerlink" title="List"></a>List</h3><ul><li><p>list 的成员函数 remove, erase, pop_front, pop_back, clear 自动释放元素内存空间，同时元素迭代器失效。</p></li><li><p>删除某个元素，仅仅会删除元素的迭代器失效。插入、删除元素不会对其他元素造成影响。</p></li></ul><h3 id="二分法"><a href="#二分法" class="headerlink" title="二分法"></a>二分法</h3><p>注意<code>while (left &lt;= right)</code>取<strong>等号</strong>，查找值是否存在。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">search</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums, <span class="hljs-type">int</span> target)</span> </span>&#123;<br>    <span class="hljs-type">int</span> left = <span class="hljs-number">0</span>;<br>    <span class="hljs-type">int</span> right = nums.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>; <span class="hljs-comment">// 定义 target 在左闭右闭的间里，[left, right]</span><br>    <span class="hljs-keyword">while</span> (left &lt;= right) &#123; <span class="hljs-comment">// 当 left==right，区间 [left, right] 依然有效，所以用 &lt;=</span><br>        <span class="hljs-type">int</span> mid = left + ((right - left) / <span class="hljs-number">2</span>); <span class="hljs-comment">// 防止溢出 等同于 (left + right)/2</span><br>        <span class="hljs-keyword">if</span> (nums[mid] &gt; target) right = middle - <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (nums[mid] &lt; target) left = middle + <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">return</span> mid;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h3><p>注意<code>while (left &lt; right)</code>，交换左右元素，至少有<strong>两个</strong>元素，才能交换，因此不能取等号。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">partition</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums, <span class="hljs-type">int</span> left, <span class="hljs-type">int</span> right)</span> </span>&#123;<br>        <span class="hljs-type">int</span> pivot = nums[left];<br>        <span class="hljs-keyword">while</span> (left &lt; right) &#123;<br>            <span class="hljs-keyword">while</span> (left &lt; right &amp;&amp; pivot &lt;= nums[right])    right--;<br>            nums[left] = nums[right];<br>            <span class="hljs-keyword">while</span> (left &lt; right &amp;&amp; pivot &gt;= nums[left])     left++;<br>            nums[right] = nums[left];<br>        &#125;<br>        nums[left] = pivot;<br>        <span class="hljs-keyword">return</span> left;<br>    &#125;<br><span class="hljs-comment">// 递归</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">quicksort</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums, <span class="hljs-type">int</span> left, <span class="hljs-type">int</span> right)</span> </span>&#123;<br>    <span class="hljs-type">int</span> pivot;<br>    <span class="hljs-keyword">if</span> (left &lt; right) &#123;<br>        pivot = <span class="hljs-built_in">partition</span>(nums, left, right);<br>        <span class="hljs-built_in">quicksort</span>(nums, left, pivot - <span class="hljs-number">1</span>);<br>        <span class="hljs-built_in">quicksort</span>(nums, pivot + <span class="hljs-number">1</span>, right);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>有重复元素时多加 ‘&#x3D;‘ ，<strong>多加不会出错</strong>。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">while</span> (left &lt; right &amp;&amp; pivot &lt;= nums[right])    right--;<br><span class="hljs-keyword">while</span> (left &lt; right &amp;&amp; pivot &gt;= nums[left])     left++;<br></code></pre></td></tr></table></figure><h3 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h3><ul><li><p><code>for (int i = 0; i &lt;= arr.size() - k; i += k)</code>，每次遍历 k 个元素，注意 <code>i&lt;=arr.size()-k</code>。</p></li><li><p><code>priority_queue&lt;int,vector&lt;int&gt;，less&lt;int&gt;&gt;</code>，第二个参数是存储容器，第三个是比较函数，默认<code>less&lt;int&gt;</code>大顶堆，自顶向下变小，<code>greater&lt;int&gt;</code>小顶堆，自顶向下变大。</p></li><li><p>求数组中三数之和（固定第一个，再用双指针），四数之和，<strong>先排序</strong>，方便后面剪枝。</p></li></ul><h3 id="链表"><a href="#链表" class="headerlink" title="链表"></a>链表</h3><ul><li>自定义链表结构：</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">ListNode</span> &#123;<br>    <span class="hljs-type">int</span> val;<br>    ListNode* next;<br>    <span class="hljs-built_in">ListNode</span>(<span class="hljs-type">int</span> val):<span class="hljs-built_in">val</span>(val), <span class="hljs-built_in">next</span>(<span class="hljs-literal">nullptr</span>)&#123;&#125;<br>&#125;;<br>ListNode* node = <span class="hljs-keyword">new</span> <span class="hljs-built_in">ListNode</span>(val);<br><br><span class="hljs-comment">//使用虚拟头节点</span><br>ListNode* dummyHead = <span class="hljs-keyword">new</span> <span class="hljs-built_in">ListNode</span>(<span class="hljs-number">0</span>);<br>dummyHead-&gt;next = head;<br>ListNode* cur = dummyHead;<br></code></pre></td></tr></table></figure><ul><li>定义指针数组（哈希）：</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs cpp">vector&lt;ListNode*&gt; vec;<br>ListNode* cur=head;<br><span class="hljs-keyword">while</span>(cur)&#123;<br>    vec.<span class="hljs-built_in">push_back</span>(cur);<br>    cur=cur-&gt;next;<br>&#125;<br></code></pre></td></tr></table></figure><p>应用：对链表每 K 个结点翻转，定义一个指针数组，对数组翻转，变相对链表操作。</p><h3 id="String"><a href="#String" class="headerlink" title="String"></a>String</h3><ul><li>双指针法判断<strong>回文</strong>：</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">countSubstrings</span><span class="hljs-params">(string s)</span> </span>&#123;<br>    <span class="hljs-type">int</span> result = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; s.<span class="hljs-built_in">size</span>(); i++) &#123;<br>        result += <span class="hljs-built_in">extend</span>(s, i, i); <span class="hljs-comment">// 以 i 为中心</span><br>        result += <span class="hljs-built_in">extend</span>(s, i, i + <span class="hljs-number">1</span>); <span class="hljs-comment">// 以 i 和 i+1 为中心</span><br>    &#125;<br>    <span class="hljs-keyword">return</span> result;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">extend</span><span class="hljs-params">(<span class="hljs-type">const</span> string&amp; s, <span class="hljs-type">int</span> i, <span class="hljs-type">int</span> j)</span> </span>&#123;<br>    <span class="hljs-type">int</span> res = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">while</span> (i &gt;= <span class="hljs-number">0</span> &amp;&amp; j &lt; s.<span class="hljs-built_in">size</span>() &amp;&amp; s[i] == s[j]) &#123;<br>        i--;<br>        j++;<br>        res++;<br>    &#125;<br>    <span class="hljs-keyword">return</span> res;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li><p><code>if(str.find(&quot;a&quot;) != -1)</code>返回结果是 <strong>-1</strong> 不是 end()。</p></li><li><p><code>s.substr(start,len)</code>，从 start 位置取长度为 len 的子串。</p></li><li><p>查找字符串 S 是否包含子串 sub，S+S 拼接破环头尾，判断<code>S.find(sub)</code>存在。</p></li><li><p><strong>stoll</strong>：string 型变量转换为 long long 型变量（常用），兼容 int long；<br><strong>stod</strong>：string 型变量转换为 double 型变量（常用），兼容 float。</p></li></ul><h3 id="优先队列（堆）"><a href="#优先队列（堆）" class="headerlink" title="优先队列（堆）"></a>优先队列（堆）</h3><ul><li><code>priority_queue&lt;int, vector&lt;int&gt;, cmp&gt; p_queue</code>默认底层容器 vector，默认大顶堆 less。</li><li>自定义比较函数 class：</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">cmp</span>&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">operator</span><span class="hljs-params">()</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp;a,vector&lt;<span class="hljs-type">int</span>&gt;&amp;b)</span></span>&#123;<br>        <span class="hljs-keyword">return</span> a[<span class="hljs-number">0</span>]&gt;b[<span class="hljs-number">0</span>];   小顶堆<br>    &#125;<br>&#125;;<br>priority_queue&lt;vector&lt;<span class="hljs-type">int</span>&gt;,vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt;,cmp&gt; q;<br></code></pre></td></tr></table></figure><ul><li>自定义比较结构体 struct:</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">cmp</span> &#123;<br>     <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">operator</span><span class="hljs-params">()</span><span class="hljs-params">(pair&lt;<span class="hljs-type">int</span>,<span class="hljs-type">int</span>&gt;&amp; a,pair&lt;<span class="hljs-type">int</span>,<span class="hljs-type">int</span>&gt;&amp; b)</span></span>&#123;<br>         <span class="hljs-keyword">return</span> a.second &gt; b.second;<br>    &#125;<br>&#125;;<br>priority_queue&lt;pair&lt;<span class="hljs-type">int</span>,<span class="hljs-type">int</span>&gt;, vector&lt;pair&lt;<span class="hljs-type">int</span>,<span class="hljs-type">int</span>&gt;&gt;, cmp&gt; q;<br></code></pre></td></tr></table></figure><ul><li>两种自定义比较函数，小顶堆，注意符号（默认大顶堆），第二个参数设置底层容器，必填，否则第三个参数不起作用。</li></ul><h3 id="二叉树"><a href="#二叉树" class="headerlink" title="二叉树"></a>二叉树</h3><ul><li>数据结构模板：</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">TreeNode</span> &#123;<br>    <span class="hljs-type">int</span> val;<br>    TreeNode *left;<br>    TreeNode *right;<br>    <span class="hljs-built_in">TreeNode</span>(<span class="hljs-type">int</span> x) : <span class="hljs-built_in">val</span>(x), <span class="hljs-built_in">left</span>(<span class="hljs-literal">nullptr</span>), <span class="hljs-built_in">right</span>(<span class="hljs-literal">nullptr</span>) &#123;&#125;<br>&#125;;<br></code></pre></td></tr></table></figure><ul><li>二叉树递归参数传值 val，切忌不要用引用 &amp;val，不能改变 val 值，<strong>方便回溯</strong>。</li><li>递归遍历函数是否需要返回值？<ul><li>若只要找到一条路径，不用全部遍历，则要返回值 bool。</li><li>若找到所有满足条件路径，要求全部遍历，则不需要返回值。</li></ul></li><li>递归返回<code>TreeNode*</code>，可以<code>return nullptr</code>。</li><li><strong>删除</strong>二叉树节点，<strong>增加</strong>二叉树节点，都是用<strong>递归函数的返回值</strong>来完成。</li><li>根据有序数组创建<strong>二叉搜索树</strong>，同时也是平衡树：</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function">TreeNode* <span class="hljs-title">createTree</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; vec,<span class="hljs-type">int</span> left,<span class="hljs-type">int</span> right)</span></span>&#123;<br>    <span class="hljs-keyword">if</span>(left &gt; right) <span class="hljs-keyword">return</span> <span class="hljs-literal">nullptr</span>;<br>    <span class="hljs-type">int</span> mid = (left+right)/<span class="hljs-number">2</span>;<br>    TreeNode* node = <span class="hljs-keyword">new</span> <span class="hljs-built_in">TreeNode</span>(vec[mid]);<br>    node-&gt;left = <span class="hljs-built_in">createTree</span>(vec,left,mid<span class="hljs-number">-1</span>);<br>    node-&gt;right = <span class="hljs-built_in">createTree</span>(vec,mid+<span class="hljs-number">1</span>,right);<br>    <span class="hljs-keyword">return</span> node;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>求公共最近公共邻居 leetcode.236：</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">TreeNode* <span class="hljs-title">lowestCommonAncestor</span><span class="hljs-params">(TreeNode* root, TreeNode* p, TreeNode* q)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (root == q || root == p || root == <span class="hljs-literal">NULL</span>) <span class="hljs-keyword">return</span> root;<br>        TreeNode* left = <span class="hljs-built_in">lowestCommonAncestor</span>(root-&gt;left, p, q);<br>        TreeNode* right = <span class="hljs-built_in">lowestCommonAncestor</span>(root-&gt;right, p, q);<br>        <span class="hljs-keyword">if</span> (left != <span class="hljs-literal">NULL</span> &amp;&amp; right != <span class="hljs-literal">NULL</span>) <span class="hljs-keyword">return</span> root;<br><br>        <span class="hljs-keyword">if</span> (left == <span class="hljs-literal">NULL</span> &amp;&amp; right != <span class="hljs-literal">NULL</span>) <span class="hljs-keyword">return</span> right;<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (left != <span class="hljs-literal">NULL</span> &amp;&amp; right == <span class="hljs-literal">NULL</span>) <span class="hljs-keyword">return</span> left;<br>        <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;<br>        &#125;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><ul><li><p>考虑设置 全局变量<code>public: TreeNode* pre</code>递归过程更新全局指针变量。</p></li><li><p><strong>递归一定看函数返回什么，指针？整数？，利用起来<code>root-&gt;left = deleteNode(root-&gt;left,key);</code>。</strong></p></li></ul><h3 id="回溯法"><a href="#回溯法" class="headerlink" title="回溯法"></a>回溯法</h3><ul><li><p><strong>关键词：返回所有可能方案。</strong></p></li><li><p><strong>回溯是递归的副产品，只要有递归就会有回溯。</strong></p></li><li><p>回溯法就是暴力搜索，并不是什么高效的算法，最多在剪枝一下（解决多层 for 循环）。</p></li><li><p>通用模板：</p></li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-type">void</span> backtracking（参数） &#123;<br>    <span class="hljs-keyword">if</span> （终止条件） &#123;<br>        存放结果；<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br>    <span class="hljs-keyword">for</span> （选择：本层集合中元素（树中节点孩子的数量就是集合的大小）) &#123;<br>        处理节点；<br>        backtracking（路径，选择列表）; <span class="hljs-comment">// 递归</span><br>        回溯，撤销处理结果！!!<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>在终止条件前加入剪枝，即进入递归后提前<code>return</code>：</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">private</span>:<br>    vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; result; <span class="hljs-comment">// 存放符合条件结果的集合</span><br>    vector&lt;<span class="hljs-type">int</span>&gt; path; <span class="hljs-comment">// 用来存放符合条件结果</span><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">backtracking</span><span class="hljs-params">(<span class="hljs-type">int</span> n, <span class="hljs-type">int</span> k, <span class="hljs-type">int</span> startIndex)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (path.<span class="hljs-built_in">size</span>() == k) &#123;<br>            result.<span class="hljs-built_in">push_back</span>(path);<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = startIndex; i &lt;= n; i++) &#123;<br>            path.<span class="hljs-built_in">push_back</span>(i); <span class="hljs-comment">// 处理节点</span><br>            <span class="hljs-built_in">backtracking</span>(n, k, i + <span class="hljs-number">1</span>);   <span class="hljs-comment">//注意 传 i+1, 不是 startIndex</span><br>            path.<span class="hljs-built_in">pop_back</span>(); <span class="hljs-comment">// 回溯，撤销处理的节点</span><br>        &#125;<br>    &#125;<br><span class="hljs-keyword">public</span>:<br>    vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">combine</span>(<span class="hljs-type">int</span> n, <span class="hljs-type">int</span> k) &#123;<br>        result.<span class="hljs-built_in">clear</span>();<br>        path.<span class="hljs-built_in">clear</span>();<br>        <span class="hljs-built_in">backtracking</span>(n, k, <span class="hljs-number">1</span>);<br>        <span class="hljs-keyword">return</span> result;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><ul><li><p>经典组合题，注意<code>backtracking(n, k, i + 1)</code>; 传 <strong>i+1</strong>, 回溯部分<code>path.pop_back()</code>以及相应处理。</p></li><li><p>善用<code>used[]</code>，标记已访问的元素。</p></li><li><p>全组合用<code>startIndex</code>（无顺序且组合不能重复）;</p><p>全排列<strong>不需要</strong><code>startIndex</code>，而是用<code>used[ ]</code>（有顺序且同一元素不能重复选取）。</p></li><li><p><strong>对于结果有重复子集，需去重，则先排序，通过判断相邻结点是否重复使用过。</strong></p></li><li><p><code>if (i &gt; 0 &amp;&amp; nums[i] == nums[i - 1] &amp;&amp; used[i - 1] == false) continue;</code>, 先排序，对于{1, 1, 2}, <code>used[0]=false</code>表示同一数层上 n[0] 已被用过，而 n[0]&#x3D;&#x3D;n[1]，所以跳过；对于<code>used[0]=true</code>，表示 n[0] 在<strong>上一层</strong>，同一条树枝上，不在同一层，可重复使用。</p></li><li><p>经典排列题，含去重：</p></li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">private</span>:<br>    vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; result;<br>    vector&lt;<span class="hljs-type">int</span>&gt; path;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">backtracking</span> <span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums, vector&lt;<span class="hljs-type">bool</span>&gt;&amp; used)</span> </span>&#123;<br>        <span class="hljs-comment">// 此时说明找到了一组</span><br>        <span class="hljs-keyword">if</span> (path.<span class="hljs-built_in">size</span>() == nums.<span class="hljs-built_in">size</span>()) &#123;<br>            result.<span class="hljs-built_in">push_back</span>(path);<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; nums.<span class="hljs-built_in">size</span>(); i++) &#123;<br>            <span class="hljs-comment">// used[i - 1] == true，说明同一树枝 nums[i - 1] 使用过</span><br>            <span class="hljs-comment">// used[i - 1] == false，说明同一树层 nums[i - 1] 使用过</span><br>            <span class="hljs-comment">// 如果同一树层 nums[i - 1] 使用过则直接跳过</span><br>            <span class="hljs-keyword">if</span> (i &gt; <span class="hljs-number">0</span> &amp;&amp; nums[i] == nums[i - <span class="hljs-number">1</span>] &amp;&amp; used[i - <span class="hljs-number">1</span>] == <span class="hljs-literal">false</span>) &#123;<br>                <span class="hljs-keyword">continue</span>;<br>            &#125;<br>            <span class="hljs-comment">//if ( used[i] == true ) continue;</span><br>            <span class="hljs-keyword">if</span> (used[i] == <span class="hljs-literal">false</span>) &#123;<br>                used[i] = <span class="hljs-literal">true</span>;<br>                path.<span class="hljs-built_in">push_back</span>(nums[i]);<br>                <span class="hljs-built_in">backtracking</span>(nums, used);<br>                path.<span class="hljs-built_in">pop_back</span>();<br>                used[i] = <span class="hljs-literal">false</span>;<br>            &#125;<br>        &#125;<br>    &#125;<br><span class="hljs-keyword">public</span>:<br>    vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">permuteUnique</span>(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums) &#123;<br>        result.<span class="hljs-built_in">clear</span>();<br>        path.<span class="hljs-built_in">clear</span>();<br>        <span class="hljs-built_in">sort</span>(nums.<span class="hljs-built_in">begin</span>(), nums.<span class="hljs-built_in">end</span>()); <span class="hljs-comment">// 排序</span><br>        <span class="hljs-function">vector&lt;<span class="hljs-type">bool</span>&gt; <span class="hljs-title">used</span><span class="hljs-params">(nums.size(), <span class="hljs-literal">false</span>)</span></span>;<br>        <span class="hljs-built_in">backtracking</span>(nums, used);<br>        <span class="hljs-keyword">return</span> result;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><ul><li><p><code>if (used[i] == false) &#123; ... &#125;</code>，记住前提条件，<strong>上一层已选过，就不考虑啦</strong>，或者改为<code>if (used[i] == true) continue;</code>。</p></li><li><p>递归和回溯：<br>1）要遍历所有元素找全部结果，函数 void 无返回值。<br>2）只要找到一条路径&#x2F;结果，函数有返回值 bool（同二叉树）。</p></li></ul><h3 id="贪心算法"><a href="#贪心算法" class="headerlink" title="贪心算法"></a>贪心算法</h3><ul><li><p>贪心的本质是选择每一阶段的局部最优，从而达到全局最优。</p></li><li><p><strong>提前排序给定数组！降低难度！</strong></p></li><li><p>加关键词 static 才能在 sort 使用 cmp 函数，sort 要求 cmp 函数为 static，或者声明类外作为全局函数。</p></li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">static</span> <span class="hljs-type">bool</span> <span class="hljs-title">cmp</span><span class="hljs-params">(<span class="hljs-type">int</span> a,<span class="hljs-type">int</span> b)</span></span>&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">abs</span>(a) &gt; <span class="hljs-built_in">abs</span>(b);<br>&#125;<br><span class="hljs-built_in">sort</span>(nums.<span class="hljs-built_in">begin</span>(),nums.<span class="hljs-built_in">end</span>(),cmp);<br></code></pre></td></tr></table></figure><ul><li><strong>左右排序两次问题，区间问题，或数组中当前元素与左右元素比较时</strong>，先顺序遍历，在逆序遍历，两次遍历不能同时兼顾左右（lc.135），换句话说，遇到两个维度权衡的时候，一定要先确定一个维度，再确定另一个维度。</li></ul><h3 id="动态规划"><a href="#动态规划" class="headerlink" title="动态规划"></a>动态规划</h3><blockquote><ol><li><p>确定 dp 数组以及下标的含义</p></li><li><p>确定递推公式</p></li><li><p>dp 数组如何初始化</p></li><li><p>确定遍历顺序</p></li><li><p>举例推导 dp 数组</p></li></ol></blockquote><p><strong>debug 最好方式就是把 dp 数组打印出来，看看究竟是不是按照自己思路推导的！</strong></p><p>dp 初始化后，遍历数组考虑初始值，避免越界。</p><h3 id="经典01背包问题"><a href="#经典01背包问题" class="headerlink" title="经典01背包问题"></a>经典01背包问题</h3><ul><li><p>每个物品只能放入一次。</p></li><li><p>外层遍历物品，<strong>内层遍历容量</strong>。</p></li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// 二维数组</span><br>vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">dp</span>(weight.<span class="hljs-built_in">size</span>(), <span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">int</span>&gt;(bagweight + <span class="hljs-number">1</span>, <span class="hljs-number">0</span>));<br><span class="hljs-comment">// 初始化</span><br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = weight[<span class="hljs-number">0</span>]; j &lt;= bagweight; j++) &#123;<br>    dp[<span class="hljs-number">0</span>][j] = value[<span class="hljs-number">0</span>];<br>&#125;<br><span class="hljs-comment">// weight 数组的大小 就是物品个数</span><br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt; weight.<span class="hljs-built_in">size</span>(); i++) &#123; <span class="hljs-comment">// 遍历物品</span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt;= bagweight; j++) &#123; <span class="hljs-comment">// 遍历背包容量</span><br>        放不下 i 重量<br>        <span class="hljs-keyword">if</span> (j &lt; weight[i]) dp[i][j] = dp[i - <span class="hljs-number">1</span>][j];<br>        <span class="hljs-keyword">else</span> dp[i][j] = <span class="hljs-built_in">max</span>(dp[i - <span class="hljs-number">1</span>][j], dp[i - <span class="hljs-number">1</span>][j - weight[i]] + value[i]);<br>    &#125;<br>&#125;<br>cout &lt;&lt; dp[weight.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>][bagweight] &lt;&lt; endl;<br></code></pre></td></tr></table></figure><ul><li><strong>滚动数组</strong>：降低空间复杂度。先正序遍历物品，在倒序遍历背包容量，dp[j] 表示：容量维 j 的背包，所背的物品价值最大为 dp[j]，<strong>倒序遍历是为了保证物品 i 只被放入一次！</strong></li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// 初始化</span><br><span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">dp</span><span class="hljs-params">(bagWeight + <span class="hljs-number">1</span>, <span class="hljs-number">0</span>)</span></span>;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; weight.<span class="hljs-built_in">size</span>(); i++) &#123; <span class="hljs-comment">// 遍历物品</span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = bagWeight; j &gt;= weight[i]; j--) &#123; <span class="hljs-comment">// 遍历背包容量</span><br>        dp[j] = <span class="hljs-built_in">max</span>(dp[j], dp[j - weight[i]] + value[i]);<br>    &#125;<br>&#125;<br>cout &lt;&lt; dp[bagWeight] &lt;&lt; endl;<br></code></pre></td></tr></table></figure><ul><li><p><code>dp[i]</code>表示不放物体，相当于<code>dp[i-1][j]</code>，不放物体 i，<code>dp[j - weight[i]] + value[i]</code>表示放物体 i，为放物体前容量的最大价值 + 物体 i 的价值。</p></li><li><p>为什么第二次循环<code>j&gt;=weight[i]</code>，因为<code>dp[j - weight[i]]</code>表示放物体前的容量，不能为负数，考虑能放下的情况，放还是不放；对于不能放下就默认等于上一次值，不考虑。</p></li><li><p>注意第二重<strong>循环 j 初始值</strong>，为 dp 容量最大值。</p></li></ul><h3 id="完全背包问题"><a href="#完全背包问题" class="headerlink" title="完全背包问题"></a>完全背包问题</h3><ul><li>每件物品无限件，可重复放入背包。</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// 先遍历物品，再遍历背包</span><br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; weight.<span class="hljs-built_in">size</span>(); i++) &#123; <span class="hljs-comment">// 遍历物品</span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = weight[i]; j &lt;= bagWeight ; j++) &#123; <span class="hljs-comment">// 遍历背包容量</span><br>        dp[j] = <span class="hljs-built_in">max</span>(dp[j], dp[j - weight[i]] + value[i]);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li><p><strong>内循环 从小到大遍历，因为每件物品添加多次</strong>。</p></li><li><p><strong>理解 内循环 dp[j]：每次容量为 j 的时候，所以后面内容都是考虑当前容量为 j</strong>。</p></li><li><p><strong>如果求<mark>组合数</mark>就是外层 for 循环遍历物品，内层 for 遍历背包</strong>。</p><p><strong>如果求<mark>排列数</mark>就是外层 for 遍历背包，内层 for 循环遍历物品</strong>。</p></li><li><p>滚动数组为了取代二维数组，但<strong>内循环一般是倒序</strong>的，防止重复选取。</p></li></ul><h3 id="求连续公共子序列"><a href="#求连续公共子序列" class="headerlink" title="求连续公共子序列"></a>求连续公共子序列</h3><ul><li><p><code>dp[i][j]</code>：以下标 <strong>i-1</strong> 为结尾的 A，和以下标 <strong>j-1</strong> 为结尾的 B，最长重复子数组<strong>长度</strong>为<code>dp[i][j]</code>。</p></li><li><p>求<strong>连续</strong>最长重复子数组：</p></li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">findLength</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums1, vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums2)</span> </span>&#123;<br>        vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">dp</span>(nums1.<span class="hljs-built_in">size</span>()+<span class="hljs-number">1</span>,<span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">int</span>&gt;(nums2.<span class="hljs-built_in">size</span>()+<span class="hljs-number">1</span>,<span class="hljs-number">0</span>));<br>        <span class="hljs-type">int</span> res = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i &lt;=nums1.<span class="hljs-built_in">size</span>();i++)&#123;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">1</span>;j&lt;=nums2.<span class="hljs-built_in">size</span>();j++)&#123;<br>                <span class="hljs-keyword">if</span>(nums1[i<span class="hljs-number">-1</span>] == nums2[j<span class="hljs-number">-1</span>])&#123;<br>                    dp[i][j] = dp[i<span class="hljs-number">-1</span>][j<span class="hljs-number">-1</span>]+<span class="hljs-number">1</span>;<br>                &#125;<br>                <span class="hljs-keyword">if</span>(dp[i][j] &gt; res) res = dp[i][j];<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><ul><li>求<strong>不连续</strong>公共子数组：</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">longestCommonSubsequence</span><span class="hljs-params">(string text1, string text2)</span> </span>&#123;<br>        vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">dp</span>(text1.<span class="hljs-built_in">size</span>()+<span class="hljs-number">1</span>,<span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">int</span>&gt;(text2.<span class="hljs-built_in">size</span>()+<span class="hljs-number">1</span>,<span class="hljs-number">0</span>));<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=text1.<span class="hljs-built_in">size</span>();i++)&#123;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">1</span>;j&lt;=text2.<span class="hljs-built_in">size</span>();j++)&#123;<br>                <span class="hljs-keyword">if</span>(text1[i<span class="hljs-number">-1</span>] == text2[j<span class="hljs-number">-1</span>])&#123;<br>                    dp[i][j] = dp[i<span class="hljs-number">-1</span>][j<span class="hljs-number">-1</span>] + <span class="hljs-number">1</span>;<br>                &#125;<span class="hljs-keyword">else</span>&#123;<br>                    dp[i][j] = <span class="hljs-built_in">max</span>(dp[i<span class="hljs-number">-1</span>][j],dp[i][j<span class="hljs-number">-1</span>]);<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> dp[text1.<span class="hljs-built_in">size</span>()][text2.<span class="hljs-built_in">size</span>()];<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><ul><li>思考<code>d[i][j]</code>是一个数，表示什么意思？公共长度？最多重复数量？最少删除次数？视情况而定。</li></ul><h3 id="单调栈"><a href="#单调栈" class="headerlink" title="单调栈"></a>单调栈</h3><ul><li><p><strong>要寻找任一个元素的右边或者左边第一个比自己大或者小的元素的位置。</strong></p></li><li><p>栈里只存递增或递减的 index，遇到逆序就弹出栈内元素，从而得到第一个大于或小于元素的 index。</p></li><li><p>设置两个数组，顺序和逆序遍历，得到左边&#x2F;右边最大数字：</p></li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// 记录每个柱子左边柱子最大高度</span><br>maxLeft[<span class="hljs-number">0</span>] = height[<span class="hljs-number">0</span>];<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt; size; i++) &#123;<br>    maxLeft[i] = <span class="hljs-built_in">max</span>(height[i], maxLeft[i - <span class="hljs-number">1</span>]);<br>&#125;<br><span class="hljs-comment">// 记录每个柱子右边柱子最大高度</span><br>maxRight[size - <span class="hljs-number">1</span>] = height[size - <span class="hljs-number">1</span>];<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = size - <span class="hljs-number">2</span>; i &gt;= <span class="hljs-number">0</span>; i--) &#123;<br>    maxRight[i] = <span class="hljs-built_in">max</span>(height[i], maxRight[i + <span class="hljs-number">1</span>]);<br>&#125;<br></code></pre></td></tr></table></figure><p>待续……</p>]]></content>
    
    
    <categories>
      
      <category>刷题笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>cpp</tag>
      
      <tag>note</tag>
      
      <tag>algorithm</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
