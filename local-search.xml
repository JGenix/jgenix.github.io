<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>Java 刷题笔记</title>
    <link href="/java%E5%88%B7%E9%A2%98%E7%AC%94%E8%AE%B0.html"/>
    <url>/java%E5%88%B7%E9%A2%98%E7%AC%94%E8%AE%B0.html</url>
    
    <content type="html"><![CDATA[<p>刷题常用的知识点汇总。</p><span id="more"></span><img src="https://cdn.jsdelivr.net/gh/gejoyy/Pictures@main/java%E6%8E%A5%E5%8F%A3%E7%BB%A7%E6%89%BF%E5%85%B3%E7%B3%BB%E5%9B%BE.png" alt="Java 接口继承关系图" style="zoom: 80%;" /><h3 id="Character"><a href="#Character" class="headerlink" title="Character"></a>Character</h3><p>判断是否为字母或数字：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">boolean</span> <span class="hljs-variable">res</span> <span class="hljs-operator">=</span> Character.isLetterOrDigit(<span class="hljs-type">char</span>);<br></code></pre></td></tr></table></figure><p>转小写：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">char</span> <span class="hljs-variable">res</span> <span class="hljs-operator">=</span> Character.toLowerCase(<span class="hljs-type">char</span>);<br></code></pre></td></tr></table></figure><p>下一个字符：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-string">&#x27;b&#x27;</span> == (<span class="hljs-type">char</span>) (<span class="hljs-string">&#x27;a&#x27;</span> + <span class="hljs-number">1</span>);<br></code></pre></td></tr></table></figure><h3 id="Integer"><a href="#Integer" class="headerlink" title="Integer"></a>Integer</h3><p>最大值最小值：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">int</span> <span class="hljs-variable">max</span> <span class="hljs-operator">=</span> Integer.MAX_VALUE;<br><span class="hljs-type">int</span> <span class="hljs-variable">min</span> <span class="hljs-operator">=</span> Integer.MIN_VALUE;<br></code></pre></td></tr></table></figure><p>比较相等：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">Integer</span> <span class="hljs-variable">a</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>;<br><span class="hljs-type">Integer</span> <span class="hljs-variable">b</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>;<br>a == b;<span class="hljs-comment">// true</span><br><span class="hljs-type">Integer</span> <span class="hljs-variable">c</span> <span class="hljs-operator">=</span> <span class="hljs-number">200</span>;<br><span class="hljs-type">Integer</span> <span class="hljs-variable">d</span> <span class="hljs-operator">=</span> <span class="hljs-number">200</span>;<br>c == d;<span class="hljs-comment">// false</span><br>Objects.equals(c, d);  <span class="hljs-comment">// true</span><br></code></pre></td></tr></table></figure><p>Integer 默认缓存 [-128,127]，故 a，b 指向同一对象，而非重新创建对象。</p><h3 id="Array"><a href="#Array" class="headerlink" title="Array"></a>Array</h3><p>创建数组：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">int</span>[] array = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[<span class="hljs-number">5</span>];<br><span class="hljs-type">int</span>[] array = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[]&#123;<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>&#125;;<br><span class="hljs-type">int</span>[] array = &#123;<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>&#125;;<br></code></pre></td></tr></table></figure><p>引用：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">array[<span class="hljs-number">3</span>];<br></code></pre></td></tr></table></figure><p>获取长度：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">array.length;<br></code></pre></td></tr></table></figure><p>排序：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java">Arrays.sort(array);<br><span class="hljs-comment">// int[] 不能直接做降序排列</span><br><span class="hljs-comment">// 想做降序排列只能用Integer[]</span><br>Integer[] array = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Integer</span>[<span class="hljs-number">2</span>];<br>Arrays.sort(array, Comparitor.naturalOrder());<span class="hljs-comment">// 升序排列</span><br>Arrays.sort(array, Comparator.reverseOrder());<span class="hljs-comment">// 降序排列</span><br></code></pre></td></tr></table></figure><p>二维数组排序：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">int</span>[][] array = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[][]&#123;&#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>&#125;, &#123;<span class="hljs-number">2</span>, <span class="hljs-number">3</span>&#125;&#125;;<br>Arrays.sort(array, (o1, o2) -&gt; o1[<span class="hljs-number">0</span>] - o2[<span class="hljs-number">0</span>]);<span class="hljs-comment">// 按照二维数组的第一个元素从小到大排序</span><br>Arrays.sort(array, (o1, o2) -&gt; o1[<span class="hljs-number">1</span>] - o2[<span class="hljs-number">1</span>]);<span class="hljs-comment">// 按照二维数组的第二个元素从小到大排序</span><br></code></pre></td></tr></table></figure><p>打印：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">System.out.println(Arrays.toString(array));<br></code></pre></td></tr></table></figure><p>填满：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">int</span>[] array = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[];<br><span class="hljs-type">int</span> num;<br>Arrays.fill(array, num);<span class="hljs-comment">// array全部元素等于num</span><br></code></pre></td></tr></table></figure><h3 id="String"><a href="#String" class="headerlink" title="String"></a>String</h3><p>创建字符串：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">String</span> <span class="hljs-variable">string</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;java&quot;</span>;<br></code></pre></td></tr></table></figure><p>指定位置的字符</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">char</span> <span class="hljs-variable">charAt3</span> <span class="hljs-operator">=</span> string.charAt(<span class="hljs-number">3</span>);<span class="hljs-comment">// charAt3 = &#x27;a&#x27;</span><br></code></pre></td></tr></table></figure><p>字符串相等：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">String</span> <span class="hljs-variable">string1</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;abc&quot;</span>;<br><span class="hljs-type">String</span> <span class="hljs-variable">string2</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;abc&quot;</span>;<br>string1.equals(string2);<br></code></pre></td></tr></table></figure><p>字符串转整数：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">String</span> <span class="hljs-variable">string</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;123&quot;</span>;<br><span class="hljs-type">int</span> <span class="hljs-variable">integer</span> <span class="hljs-operator">=</span> Integer.parseInt(string);<br></code></pre></td></tr></table></figure><p>字符串长度：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">int</span> <span class="hljs-variable">length</span> <span class="hljs-operator">=</span> string.length();<br></code></pre></td></tr></table></figure><p>截取字符串：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">String</span> <span class="hljs-variable">sb</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;abc&quot;</span>;<br><span class="hljs-type">String</span> <span class="hljs-variable">str</span> <span class="hljs-operator">=</span> sb.substring(<span class="hljs-number">0</span>, <span class="hljs-number">1</span>);<span class="hljs-comment">// str = &quot;a&quot;;</span><br></code></pre></td></tr></table></figure><p>字符的位置：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">String</span> <span class="hljs-variable">str</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;abc&quot;</span>;<br><span class="hljs-type">int</span> <span class="hljs-variable">index</span> <span class="hljs-operator">=</span> str.indexOf(b);<span class="hljs-comment">// index = 1</span><br></code></pre></td></tr></table></figure><p>字符串转字符数组：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java">String str;<br><span class="hljs-type">char</span>[] temp = str.toCharArray();<br></code></pre></td></tr></table></figure><p>字符串分割：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">String</span> <span class="hljs-variable">str</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;hello world&quot;</span>;<br>String[] word = str.split(<span class="hljs-string">&quot; &quot;</span>);<span class="hljs-comment">// word = [&quot;hello&quot;, &quot;world&quot;]</span><br><span class="hljs-comment">// 这里必须是字符串</span><br><span class="hljs-comment">// 如果有两个空格连在一起，会在数组中加入一个&quot;&quot;（空字符串）</span><br></code></pre></td></tr></table></figure><p>将字符串数组合并为长字符串（中间插入）：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java">String[] words = <span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>[]&#123;<span class="hljs-string">&quot;hello&quot;</span>, <span class="hljs-string">&quot;world&quot;</span>&#125;;<br><span class="hljs-type">String</span> <span class="hljs-variable">str</span> <span class="hljs-operator">=</span> String.join(<span class="hljs-string">&quot; &quot;</span>, words);<br><span class="hljs-comment">// str = &quot;hello world&quot;;</span><br></code></pre></td></tr></table></figure><p>字符串替换：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">String</span> <span class="hljs-variable">str</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;a! b&quot;</span>;<br>str = str.replace(<span class="hljs-string">&quot;!&quot;</span>, <span class="hljs-string">&quot; &quot;</span>);<span class="hljs-comment">// str = &quot;a  b&quot;;</span><br><span class="hljs-comment">// 字符或者字符串都可以替换</span><br></code></pre></td></tr></table></figure><p>删除字符串头尾的空格：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">String</span> <span class="hljs-variable">str</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;  abc  &quot;</span>;<br>str.trim();<span class="hljs-comment">// str = &quot;abc&quot;</span><br></code></pre></td></tr></table></figure><h3 id="Stack"><a href="#Stack" class="headerlink" title="Stack"></a>Stack</h3><blockquote><p><a href="https://cloud.tencent.com/developer/article/1815753">Java 中用 Deque 接口代替 Stack 接口完成栈功能</a></p></blockquote><p>创建 stack：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">Deque&lt;Integer&gt; stack = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayDeque</span>&lt;Integer&gt;();<br></code></pre></td></tr></table></figure><p>栈顶：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">stack.peek()<br></code></pre></td></tr></table></figure><p>入栈：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">stack.push();<br></code></pre></td></tr></table></figure><p>出栈：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">stack.pop();<br></code></pre></td></tr></table></figure><p>栈是否为空：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">stack.isEmpty();<br></code></pre></td></tr></table></figure><p>栈的长度：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">stack.size();<br></code></pre></td></tr></table></figure><h3 id="ArrayList"><a href="#ArrayList" class="headerlink" title="ArrayList"></a>ArrayList</h3><p>创建列表：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java">List&lt;Integer&gt; array = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;Integer&gt;();<br>List&lt;Integer&gt; array = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;Integer&gt;(Arrays.asList(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>));<span class="hljs-comment">// 初始化值</span><br></code></pre></td></tr></table></figure><p>添加元素：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">array.add(<span class="hljs-number">1</span>);<br></code></pre></td></tr></table></figure><p>指定位置的元素：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">array.get(<span class="hljs-number">0</span>);<br></code></pre></td></tr></table></figure><p>列表中是否存在某元素：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">array.contains(<span class="hljs-number">0</span>);<br></code></pre></td></tr></table></figure><p>删除列表元素：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java">array.remove(<span class="hljs-number">0</span>);<span class="hljs-comment">// 删除array[0]</span><br>array.remove(Integer.valueOf(<span class="hljs-number">0</span>));<span class="hljs-comment">// 删除元素0</span><br></code></pre></td></tr></table></figure><p>列表大小：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">array.size();<br></code></pre></td></tr></table></figure><p>判断列表是否为空：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">array.isEmpty();<br></code></pre></td></tr></table></figure><p>清空列表：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">array.clear();<br></code></pre></td></tr></table></figure><p>升序排列：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">array.sort(Comparator.naturalOrder());<br></code></pre></td></tr></table></figure><p>降序排列：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">array.sort(Comparator.reverseOrder());<br></code></pre></td></tr></table></figure><p>修改值：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">array.set(<span class="hljs-type">int</span> index, <span class="hljs-type">int</span> value);<br></code></pre></td></tr></table></figure><p>反转：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">Collections.reverse(array);<br></code></pre></td></tr></table></figure><h3 id="HashMap"><a href="#HashMap" class="headerlink" title="HashMap"></a>HashMap</h3><p>创建一个哈希映射：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">Map&lt;Integer, Integer&gt; map = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;Integer, Integer&gt;();<br></code></pre></td></tr></table></figure><p>存储键值对（修改键值对）：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">map.put(key, value);<br></code></pre></td></tr></table></figure><p>获取 key 的内容：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">map.get(key);<br></code></pre></td></tr></table></figure><p>如果不知道有没有内容：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java">map.getOrDefault(key, <span class="hljs-keyword">default</span>);<br><span class="hljs-comment">// 如果存在key，返回key的值</span><br><span class="hljs-comment">// 如果不存在key，返回default</span><br>map.put(key, map.getOrDefault(key, <span class="hljs-number">0</span>) + <span class="hljs-number">1</span>);<br></code></pre></td></tr></table></figure><p>查询是否存在 key：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">map.containsKey(key);<br></code></pre></td></tr></table></figure><p>遍历键值对：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 遍历key</span><br><span class="hljs-keyword">for</span> (Integer key : map.keySet()) &#123;<br>&#125;<br><span class="hljs-comment">// 遍历value</span><br><span class="hljs-keyword">for</span> (Integer value : map.values()) &#123;<br>&#125;<br></code></pre></td></tr></table></figure><p>是否为空：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">map.isEmpty();<br></code></pre></td></tr></table></figure><p>删除 Key：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">map.remove(key);<br></code></pre></td></tr></table></figure><p>排序：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java">Map&lt;Integer, Integer&gt; map = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;Integer, Integer&gt;();<span class="hljs-comment">// 创建一个哈希映射</span><br>List&lt;Map.Entry&lt;Integer, Integer&gt;&gt; mapList = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;Map.Entry&lt;Integer, Integer&gt;&gt;(map.entrySet());<span class="hljs-comment">// 我们无法对HashMap排序，需要把HashMap转换为ArrayList再排序</span><br>Collections.sort(mapList, <span class="hljs-keyword">new</span> <span class="hljs-title class_">Comparator</span>&lt;Map.Entry&lt;Integer, Integer&gt;&gt;() &#123;<br>            <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">compare</span><span class="hljs-params">(Map.Entry&lt;Integer, Integer&gt; o1, Map.Entry&lt;Integer, Integer&gt; o2)</span> &#123;<br>                <span class="hljs-keyword">return</span> (o2.getValue() - o1.getValue());<span class="hljs-comment">// 按照值的大小，从大到小排序</span><br>            &#125;<br>        &#125;);<br>mapList.get(i).getKey();<span class="hljs-comment">// 排序后第i个的键</span><br>mapList.get(i).getValue();<span class="hljs-comment">// 排序后第i个的值</span><br></code></pre></td></tr></table></figure><h3 id="HashSet"><a href="#HashSet" class="headerlink" title="HashSet"></a>HashSet</h3><p>创建哈希表：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">Set&lt;Integer&gt; set = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashSet</span>&lt;Integer&gt;();<br></code></pre></td></tr></table></figure><p>添加元素：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">set.add();<br></code></pre></td></tr></table></figure><p>判断元素是否存在：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">set.contains();<span class="hljs-comment">// HashSet查找元素要优于ArrayList</span><br></code></pre></td></tr></table></figure><p>删除元素：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">set.remove();<br></code></pre></td></tr></table></figure><p>清空：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">set.clear();<br></code></pre></td></tr></table></figure><p>遍历：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> temp : set) &#123;<br>    ...<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="StringBuilder"><a href="#StringBuilder" class="headerlink" title="StringBuilder"></a>StringBuilder</h3><p>创建 StringBuilder：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">StringBuilder</span> <span class="hljs-variable">sb</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">StringBuilder</span>();<br></code></pre></td></tr></table></figure><p>在末尾添加字符或字符串：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">sb.append(<span class="hljs-type">char</span>);<br></code></pre></td></tr></table></figure><p>在末尾删除字符：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">sb.deleteCharAt(sb.length() - <span class="hljs-number">1</span>);<br></code></pre></td></tr></table></figure><p>长度：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">sb.length();<br></code></pre></td></tr></table></figure><p>转化为 String：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">sb.toString();<br></code></pre></td></tr></table></figure><p>取反：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">sb.reverse();<br></code></pre></td></tr></table></figure><p>插入：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">sb.insert(<span class="hljs-number">0</span>, <span class="hljs-string">&quot;abcd&quot;</span>);<span class="hljs-comment">// 在第0个元素插入&quot;abcd&quot;</span><br></code></pre></td></tr></table></figure><p>清空：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">sb.setLength(<span class="hljs-number">0</span>);<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">sb.delete(<span class="hljs-number">0</span>, sb.length());<br></code></pre></td></tr></table></figure><p>取字符：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">sb.charAt(i);<br></code></pre></td></tr></table></figure><p>修改位置的字符：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">sb.setCharAt(i);<br></code></pre></td></tr></table></figure><h3 id="Queue"><a href="#Queue" class="headerlink" title="Queue"></a>Queue</h3><p>创建 queue:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">Queue&lt;Integer&gt; queue = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedList</span>&lt;Integer&gt;();<br></code></pre></td></tr></table></figure><p>加入元素：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">queue.offer(<span class="hljs-number">1</span>);<br></code></pre></td></tr></table></figure><p>删除元素（先进先出）：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">queue.poll();<br></code></pre></td></tr></table></figure><p>队首元素：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">queue.peek();<br></code></pre></td></tr></table></figure><p>队列大小：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">queue.size();<br></code></pre></td></tr></table></figure><p>是否为空：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">queue.isEmpty();<br></code></pre></td></tr></table></figure><p>队列清空：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">queue.clear();<br></code></pre></td></tr></table></figure><h3 id="Deque"><a href="#Deque" class="headerlink" title="Deque"></a>Deque</h3><p>创建 Deque：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">Deque&lt;Integer&gt; deque = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayDeque</span>&lt;Integer&gt;();<br></code></pre></td></tr></table></figure><p>队尾添加元素：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">deque.offerLast();<span class="hljs-comment">// queue的用法</span><br></code></pre></td></tr></table></figure><p>队首弹出元素：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">deque.pollFirst();<span class="hljs-comment">// queue的用法</span><br></code></pre></td></tr></table></figure><p>取队首元素：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">deque.peekFirst();<span class="hljs-comment">// queue的用法</span><br></code></pre></td></tr></table></figure><p>队首添加元素：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">deque.offerFirst();<br></code></pre></td></tr></table></figure><p>队尾弹出元素：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">deque.pollLast();<br></code></pre></td></tr></table></figure><p>取队尾元素：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">deque.peekLast();<br></code></pre></td></tr></table></figure><h3 id="LinkedList"><a href="#LinkedList" class="headerlink" title="LinkedList"></a>LinkedList</h3><p>新建链表：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">LinkedList&lt;Integer&gt; link = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedList</span>&lt;Integer&gt;();<br></code></pre></td></tr></table></figure><p>末尾插入：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java">link.add();<br><span class="hljs-comment">// 注意这个函数返回boolean，因此不要重复赋值</span><br>link.addLast();<br><span class="hljs-comment">// 返回void</span><br></code></pre></td></tr></table></figure><p>指定位置插入：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">link.add(<span class="hljs-type">int</span> index, <span class="hljs-type">int</span> Ele);<br></code></pre></td></tr></table></figure><p>头部插入：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">link.addFirst();<br></code></pre></td></tr></table></figure><p>清空：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">link.clear();<br></code></pre></td></tr></table></figure><p>删除并返回第一个：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">link.removeFirst();<br></code></pre></td></tr></table></figure><p>删除并返回最后一个：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">link.removeLast();<br></code></pre></td></tr></table></figure><p>删除特定位置：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">link.remove(<span class="hljs-type">int</span> index)<br></code></pre></td></tr></table></figure><p>重设：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">link.set();<br></code></pre></td></tr></table></figure><p>头部取值：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">link.getFirst();<br></code></pre></td></tr></table></figure><p>尾部取值：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">link.getLast();<br></code></pre></td></tr></table></figure><p>特定位置取值：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">link.get(<span class="hljs-type">int</span> index);<br></code></pre></td></tr></table></figure><p>是否存在：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">link.contains(<span class="hljs-type">int</span> key);<br></code></pre></td></tr></table></figure><h3 id="PriorityQueue"><a href="#PriorityQueue" class="headerlink" title="PriorityQueue:"></a>PriorityQueue:</h3><p>创建优先队列：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java">PriorityQueue&lt;Integer&gt; heap = <span class="hljs-keyword">new</span> <span class="hljs-title class_">PriorityQueue</span>&lt;Integer&gt;();<br><span class="hljs-comment">// 如果不加Comparator默认为小根堆</span><br><span class="hljs-comment">// 即只有第一个元素是最小元素</span><br></code></pre></td></tr></table></figure><p>插入元素：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">heap.offer();<br></code></pre></td></tr></table></figure><p>取堆顶：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">heap.peek();<br></code></pre></td></tr></table></figure><p>弹出堆顶：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">heap.poll();<br></code></pre></td></tr></table></figure><p>删除特定元素：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">heap.remove();<br></code></pre></td></tr></table></figure><p>堆大小：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">heap.size();<br></code></pre></td></tr></table></figure><h3 id="互相转换"><a href="#互相转换" class="headerlink" title="互相转换"></a>互相转换</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// int转String</span><br><span class="hljs-type">int</span> i;<br><span class="hljs-type">String</span> <span class="hljs-variable">str</span> <span class="hljs-operator">=</span> String.valueOf(i);<br><br><span class="hljs-comment">// String转int</span><br>String str;<br><span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> Integer.parseInt(str);<br><br><span class="hljs-comment">// char转int</span><br><span class="hljs-type">char</span> ch;<br><span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> ch - <span class="hljs-string">&#x27;0&#x27;</span>;<br><br><span class="hljs-comment">// int转char</span><br><span class="hljs-type">int</span> i;<br><span class="hljs-type">char</span> <span class="hljs-variable">ch</span> <span class="hljs-operator">=</span> (<span class="hljs-type">char</span>) (i + <span class="hljs-string">&#x27;0&#x27;</span>);<br><br><span class="hljs-comment">// String转char[]</span><br>String str;<br><span class="hljs-type">char</span>[] ch = str.toCharArray();<br><br><span class="hljs-comment">// char[]转String</span><br><span class="hljs-type">char</span>[] ch;<br><span class="hljs-type">String</span> <span class="hljs-variable">str</span> <span class="hljs-operator">=</span> String.valueOf(ch);<br><br><span class="hljs-comment">// char转String</span><br><span class="hljs-type">char</span> <span class="hljs-variable">ch</span> <span class="hljs-operator">=</span> <span class="hljs-string">&#x27;a&#x27;</span>;<br><span class="hljs-type">String</span> <span class="hljs-variable">str</span> <span class="hljs-operator">=</span> ch + <span class="hljs-string">&quot;&quot;</span>;<br><br><span class="hljs-comment">// ArrayList转Integer[]</span><br>List&lt;Integer&gt; list;<br>Integer[] array = list.toArray(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Integer</span>[list.size()]);<br><br><span class="hljs-comment">// Integer[]转ArrayList</span><br>Integer[] array;<br>List&lt;Integer&gt; list = Arrays.asList(array);<br></code></pre></td></tr></table></figure><h3 id="坑"><a href="#坑" class="headerlink" title="坑"></a>坑</h3><p>Math.ceil：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">double</span> Math.ceil(<span class="hljs-type">double</span> a);<span class="hljs-comment">// 原函数</span><br>Math.ceil(<span class="hljs-number">24</span> / <span class="hljs-number">23</span>);<span class="hljs-comment">// 1.0</span><br>Math.ceil(<span class="hljs-number">22</span> / <span class="hljs-number">23</span>);<span class="hljs-comment">// 0.0</span><br>Math.ceil((<span class="hljs-type">double</span>) <span class="hljs-number">24</span> / <span class="hljs-number">23</span>);<span class="hljs-comment">// 2.0</span><br>(<span class="hljs-type">int</span>) Math.ceil((<span class="hljs-type">double</span>) <span class="hljs-number">24</span> / <span class="hljs-number">23</span>);<span class="hljs-comment">// 2</span><br></code></pre></td></tr></table></figure><p>Math.pow:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java">Math.pow(<span class="hljs-number">10</span>, <span class="hljs-number">9</span>);<span class="hljs-comment">// 如果想求次方必须要用pow函数，返回double</span><br><span class="hljs-number">10</span> ^ <span class="hljs-number">9</span>;<span class="hljs-comment">// 这里表示的是亦或而不是次方</span><br></code></pre></td></tr></table></figure><p>二维数组：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">int</span>[][] a = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[][] &#123;&#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>&#125;, &#123;<span class="hljs-number">3</span>, <span class="hljs-number">4</span>&#125;&#125;;<br><span class="hljs-type">int</span>[] b = a[<span class="hljs-number">1</span>];<span class="hljs-comment">// b = [3, 4]</span><br>b[<span class="hljs-number">1</span>] = <span class="hljs-number">100</span>;<br><span class="hljs-comment">// a = [[1, 2], [3, 100]]</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>leetcode</category>
      
    </categories>
    
    
    <tags>
      
      <tag>基础类型</tag>
      
      <tag>集合</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Java String 类型</title>
    <link href="/java-string%E7%B1%BB%E5%9E%8B.html"/>
    <url>/java-string%E7%B1%BB%E5%9E%8B.html</url>
    
    <content type="html"><![CDATA[<p>String 类型可能是 Java 中应用最频繁的引用类型，但它的性能问题却常常被忽略。高效的使用字符串，可以提升系统的整体性能。当然，要做到高效使用字符串，需要深入了解其特性。</p><span id="more"></span><blockquote><p>转载：<a href="https://dunwu.github.io/javacore/pages/bc583c/">深入理解 Java String 类型</a>（有改动）</p></blockquote><h2 id="String-的不可变性"><a href="#String-的不可变性" class="headerlink" title="String 的不可变性"></a>String 的不可变性</h2><p><code>String</code> 的定义：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">String</span><br>    <span class="hljs-keyword">implements</span> <span class="hljs-title class_">java</span>.io.Serializable, Comparable&lt;String&gt;, CharSequence &#123;<br>    <span class="hljs-comment">/** The value is used for character storage. */</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-type">char</span> value[];<br></code></pre></td></tr></table></figure><p><code>String</code> 类被 <code>final</code> 关键字修饰，表示<strong>不可继承 <code>String</code> 类</strong>。</p><p><code>String</code> 类的数据存储于 <code>char[]</code> 数组，这个数组被 <code>final</code> 关键字修饰，表示 <strong><code>String</code> 对象不可被更改</strong>。</p><p>为什么 Java 要这样设计？</p><p>（1）<strong>保证 String 对象安全性</strong>。避免 String 被篡改。</p><p>（2）<strong>保证 hash 值不会频繁变更</strong>。</p><p>（3）<strong>可以实现字符串常量池</strong>。通常有两种创建字符串对象的方式：一种是通过字符串常量的方式创建，如 <code>String str=&quot;abc&quot;;</code> 另一种是字符串变量通过 new 形式的创建，如 <code>String str = new String(&quot;abc&quot;)</code>。</p><p>使用第一种方式创建字符串对象时，JVM 首先会检查该对象是否在字符串常量池中，如果在，就返回该对象引用，否则新的字符串将在常量池中被创建。这种方式可以减少同一个值的字符串对象的重复创建，节约内存。</p><p><code>String str = new String(&quot;abc&quot;)</code> 这种方式，首先在编译类文件时，<code>&quot;abc&quot;</code> 常量字符串将会放入到常量结构中，在类加载时，<code>&quot;abc&quot;</code> 将会在常量池中创建；其次，在调用 new 时，JVM 命令将会调用 <code>String</code> 的构造函数，同时引用常量池中的 <code>&quot;abc&quot;</code> 字符串，在堆内存中创建一个 <code>String</code> 对象；最后，str 将引用 <code>String</code> 对象。</p><h2 id="String-的性能考量"><a href="#String-的性能考量" class="headerlink" title="String 的性能考量"></a>String 的性能考量</h2><h3 id="字符串拼接"><a href="#字符串拼接" class="headerlink" title="字符串拼接"></a>字符串拼接</h3><p><strong>字符串常量的拼接，编译器会将其优化为一个常量字符串</strong>。</p><p>【示例】字符串常量拼接</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>    <span class="hljs-comment">// 本行代码在 class 文件中，会被编译器直接优化为：</span><br>    <span class="hljs-comment">// String str = &quot;abc&quot;;</span><br>    <span class="hljs-type">String</span> <span class="hljs-variable">str</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;a&quot;</span> + <span class="hljs-string">&quot;b&quot;</span> + <span class="hljs-string">&quot;c&quot;</span>;<br>    System.out.println(<span class="hljs-string">&quot;str = &quot;</span> + str);<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>字符串变量的拼接，编译器会优化成 <code>StringBuilder</code> 的方式</strong>。</p><p>【示例】字符串变量的拼接</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>    <span class="hljs-type">String</span> <span class="hljs-variable">str</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;&quot;</span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>; i&lt;<span class="hljs-number">1000</span>; i++) &#123;<br>        <span class="hljs-comment">// 本行代码会被编译器优化为：</span><br>        <span class="hljs-comment">// str = (new StringBuilder(String.valueOf(str))).append(i).toString();</span><br>        str = str + i;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>但是，每次循环都会生成一个新的 <code>StringBuilder</code> 实例，同样也会降低系统的性能。</p><p>字符串拼接的正确方案：</p><ul><li>如果需要使用<strong>字符串拼接，应该优先考虑 <code>StringBuilder</code> 的 <code>append</code> 方法替代使用 <code>+</code> 号</strong>。</li><li>如果在并发编程中，<code>String</code> 对象的拼接涉及到线程安全，可以使用 <code>StringBuffer</code>。但是要注意，由于 <code>StringBuffer</code> 是线程安全的，涉及到锁竞争，所以从性能上来说，要比 <code>StringBuilder</code> 差一些。</li></ul><h3 id="字符串分割"><a href="#字符串分割" class="headerlink" title="字符串分割"></a>字符串分割</h3><p><strong><code>String</code> 的 <code>split()</code> 方法使用正则表达式实现其强大的分割功能</strong>。而正则表达式的性能是非常不稳定的，使用不恰当会引起回溯问题，很可能导致 CPU 居高不下。</p><p>所以，应该慎重使用 <code>split()</code> 方法，<strong>可以考虑用 <code>String.indexOf()</code> 方法代替 <code>split()</code> 方法完成字符串的分割</strong>。如果实在无法满足需求，你就在使用 Split() 方法时，对回溯问题加以重视就可以了。</p><h3 id="String-intern"><a href="#String-intern" class="headerlink" title="String.intern"></a>String.intern</h3><p><strong>在每次赋值的时候使用 <code>String</code> 的 <code>intern</code> 方法，如果常量池中有相同值，就会重复使用该对象，返回对象引用，这样一开始的对象就可以被回收掉</strong>。</p><p>在字符串常量中，默认会将对象放入常量池；在字符串变量中，对象是会创建在堆内存中，同时也会在常量池中创建一个字符串对象，复制到堆内存对象中，并返回堆内存对象引用。</p><p>如果调用 <code>intern</code> 方法，会去查看字符串常量池中是否有等于该对象的字符串，如果没有，就在常量池中新增该对象，并返回该对象引用；如果有，就返回常量池中的字符串引用。堆内存中原有的对象由于没有引用指向它，将会通过垃圾回收器回收。</p><h2 id="String、StringBuffer、StringBuilder-区别"><a href="#String、StringBuffer、StringBuilder-区别" class="headerlink" title="String、StringBuffer、StringBuilder 区别"></a>String、StringBuffer、StringBuilder 区别</h2><p><code>String</code> 是 Java 语言非常基础和重要的类，提供了构造和管理字符串的各种基本逻辑。它是典型的 <code>Immutable</code> 类，被声明成为 <code>final class</code>，所有属性也都是 <code>final</code> 的。也由于它的不可变性，类似拼接、裁剪字符串等动作，都会产生新的 <code>String</code> 对象。由于字符串操作的普遍性，所以相关操作的效率往往对应用性能有明显影响。</p><p><code>StringBuffer</code> 是为解决上面提到拼接产生太多中间对象的问题而提供的一个类，我们可以用 <code>append</code> 或者 <code>add</code> 方法，把字符串添加到已有序列的末尾或者指定位置。<code>StringBuffer</code> 是一个<strong>线程安全的</strong>可修改字符序列。<code>StringBuffer</code> 的线程安全是通过在各种修改数据的方法上用 <code>synchronized</code> 关键字修饰实现的。</p><p><code>StringBuilder</code> 是 Java 1.5 中新增的，在能力上和 StringBuffer 没有本质区别，但是它去掉了线程安全的部分，有效减小了开销，是绝大部分情况下进行字符串拼接的首选。</p><p><code>StringBuffer</code> 和 <code>StringBuilder</code> 底层都是利用可修改的（char，JDK 9 以后是 byte）数组，二者都继承了 <code>AbstractStringBuilder</code>，里面包含了基本操作，区别仅在于最终的方法是否加了 <code>synchronized</code>。构建时初始字符串长度加 16（这意味着，如果没有构建对象时输入最初的字符串，那么初始值就是 16）。我们如果确定拼接会发生非常多次，而且大概是可预计的，那么就可以指定合适的大小，避免很多次扩容的开销。扩容会产生多重开销，因为要抛弃原有数组，创建新的（可以简单认为是倍数）数组，还要进行 <code>arraycopy</code>。</p><p>**除非有线程安全的需要，不然一般都使用 <code>StringBuilder</code>**。</p>]]></content>
    
    
    <categories>
      
      <category>JavaSE</category>
      
    </categories>
    
    
    <tags>
      
      <tag>string</tag>
      
      <tag>基础</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Java 注解</title>
    <link href="/java%E6%B3%A8%E8%A7%A3.html"/>
    <url>/java%E6%B3%A8%E8%A7%A3.html</url>
    
    <content type="html"><![CDATA[<p>Java 注解（Annotation）又称 Java 标注，是 JDK5.0 引入的一种注释机制。Java 语言中的类、方法、变量、参数和包等都可以被标注。和 Javadoc 不同，Java 标注可以通过反射获取标注内容。在编译器生成类文件时，标注可以被嵌入到字节码中。Java 虚拟机可以保留标注内容，在运行时可以获取到标注内容。当然它也支持自定义 Java 标注。</p><span id="more"></span><blockquote><p>转载：<a href="https://dunwu.github.io/javacore/pages/ecc011/#%E7%AE%80%E4%BB%8B">深入理解 Java 注解</a>（有改动）</p></blockquote><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><h3 id="注解的形式"><a href="#注解的形式" class="headerlink" title="注解的形式"></a>注解的形式</h3><p>Java 中，注解是以 <code>@</code> 字符开始的修饰符。如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">void</span> <span class="hljs-title function_">mySuperMethod</span><span class="hljs-params">()</span> &#123; ... &#125;<br></code></pre></td></tr></table></figure><p>注解可以包含命名或未命名的属性，并且这些属性有值。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Author(</span><br><span class="hljs-meta">   name = &quot;Benjamin Franklin&quot;,</span><br><span class="hljs-meta">   date = &quot;3/27/2003&quot;</span><br><span class="hljs-meta">)</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyClass</span>() &#123; ... &#125;<br></code></pre></td></tr></table></figure><p>如果只有一个名为 value 的属性，那么名称可以省略，如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@SuppressWarnings(&quot;unchecked&quot;)</span><br><span class="hljs-keyword">void</span> <span class="hljs-title function_">myMethod</span><span class="hljs-params">()</span> &#123; ... &#125;<br></code></pre></td></tr></table></figure><p>如果注解没有属性，则称为<code>标记注解</code>。如：<code>@Override</code>。</p><h3 id="什么是注解"><a href="#什么是注解" class="headerlink" title="什么是注解"></a>什么是注解</h3><p>从本质上来说，<strong>注解是一种标签，其实质上可以视为一种特殊的注释，如果没有解析它的代码，它并不比普通注释强。</strong></p><p>解析一个注解往往有两种形式：</p><ul><li><strong>编译期直接的扫描</strong> - 编译器的扫描指的是编译器在对 java 代码编译字节码的过程中会检测到某个类或者方法被一些注解修饰，这时它就会对于这些注解进行某些处理。这种情况只适用于 JDK 内置的注解类。</li><li><strong>运行期的反射</strong> - 如果要自定义注解，Java 编译器无法识别并处理这个注解，它只能根据该注解的作用范围来选择是否编译进字节码文件。如果要处理注解，必须利用反射技术，识别该注解以及它所携带的信息，然后做相应的处理。</li></ul><h3 id="注解的作用"><a href="#注解的作用" class="headerlink" title="注解的作用"></a>注解的作用</h3><p>注解有许多用途：</p><ul><li>编译器信息 - 编译器可以使用注解来检测错误或抑制警告。</li><li>编译时和部署时的处理 - 程序可以处理注解信息以生成代码，XML 文件等。</li><li>运行时处理 - 可以在运行时检查某些注解并处理。</li></ul><p>作为 Java 程序员，多多少少都曾经历过被各种配置文件（xml、properties）支配的恐惧。过多的配置文件会使得项目难以维护。使用注解以减少配置文件或代码，是注解最大的用处。</p><h3 id="注解的代价"><a href="#注解的代价" class="headerlink" title="注解的代价"></a>注解的代价</h3><p>凡事有得必有失，注解技术同样如此。使用注解也有一定的代价：</p><ul><li>显然，它是一种侵入式编程，那么，自然就存在着增加程序耦合度的问题。</li><li>自定义注解的处理需要在运行时，通过反射技术来获取属性。如果注解所修饰的元素是类的非 public 成员，也可以通过反射获取。这就违背了面向对象的封装性。</li><li>注解所产生的问题，相对而言，更难以 debug 或定位。</li></ul><p>但是，正所谓瑕不掩瑜，注解所付出的代价，相较于它提供的功能而言，还是可以接受的。</p><h3 id="注解的应用范围"><a href="#注解的应用范围" class="headerlink" title="注解的应用范围"></a>注解的应用范围</h3><p>注解可以应用于类、字段、方法和其他程序元素的声明。</p><p>JDK8 开始，注解的应用范围进一步扩大，以下是新的应用范围：</p><p>类实例初始化表达式：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">new</span> <span class="hljs-meta">@Interned</span> MyObject();<br></code></pre></td></tr></table></figure><p>类型转换：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">myString = (<span class="hljs-meta">@NonNull</span> String) str;<br></code></pre></td></tr></table></figure><p>实现接口的声明：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">UnmodifiableList</span>&lt;T&gt; implements<br>    <span class="hljs-meta">@Readonly</span> List&lt;<span class="hljs-meta">@Readonly</span> T&gt; &#123;&#125;<br></code></pre></td></tr></table></figure><p>抛出异常声明：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">void</span> <span class="hljs-title function_">monitorTemperature</span><span class="hljs-params">()</span><br>    <span class="hljs-keyword">throws</span> <span class="hljs-meta">@Critical</span> TemperatureException &#123;&#125;<br></code></pre></td></tr></table></figure><h2 id="内置注解"><a href="#内置注解" class="headerlink" title="内置注解"></a>内置注解</h2><p>JDK 中内置了以下注解：</p><ul><li><code>@Override</code></li><li><code>@Deprecated</code></li><li><code>@SuppressWarnnings</code></li><li><code>@SafeVarargs</code>（JDK7 引入）</li><li><code>@FunctionalInterface</code>（JDK8 引入）</li></ul><h3 id="Override"><a href="#Override" class="headerlink" title="@Override"></a>@Override</h3><p><strong><a href="https://docs.oracle.com/javase/8/docs/api/java/lang/Override.html"><code>@Override</code></a> 用于表明被修饰方法覆写了父类的方法。</strong></p><p>如果试图使用 <code>@Override</code> 标记一个实际上并没有覆写父类的方法时，java 编译器会告警。</p><p><code>@Override</code> 示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">OverrideAnnotationDemo</span> &#123;<br><br>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Person</span> &#123;<br>        <span class="hljs-keyword">public</span> String <span class="hljs-title function_">getName</span><span class="hljs-params">()</span> &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;getName&quot;</span>;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Man</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Person</span> &#123;<br>        <span class="hljs-meta">@Override</span><br>        <span class="hljs-keyword">public</span> String <span class="hljs-title function_">getName</span><span class="hljs-params">()</span> &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;override getName&quot;</span>;<br>        &#125;<br><br>        <span class="hljs-comment">/**</span><br><span class="hljs-comment">         *  放开下面的注释，编译时会告警</span><br><span class="hljs-comment">         */</span><br>       <span class="hljs-comment">/*</span><br><span class="hljs-comment">        @Override</span><br><span class="hljs-comment">        public String getName2() &#123;</span><br><span class="hljs-comment">            return &quot;override getName2&quot;;</span><br><span class="hljs-comment">        &#125;</span><br><span class="hljs-comment">        */</span><br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">Person</span> <span class="hljs-variable">per</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Man</span>();<br>        System.out.println(per.getName());<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="Deprecated"><a href="#Deprecated" class="headerlink" title="@Deprecated"></a>@Deprecated</h3><p><strong><code>@Deprecated</code> 用于标明被修饰的类或类成员、类方法已经废弃、过时，不建议使用。</strong></p><p><code>@Deprecated</code> 有一定的<strong>延续性</strong>：如果我们在代码中通过继承或者覆盖的方式使用了过时的类或类成员，即使子类或子方法没有标记为 <code>@Deprecated</code>，但编译器仍然会告警。</p><p>示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">DeprecatedAnnotationDemo</span> &#123;<br>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">DeprecatedField</span> &#123;<br>        <span class="hljs-meta">@Deprecated</span><br>        <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">String</span> <span class="hljs-variable">DEPRECATED_FIELD</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;DeprecatedField&quot;</span>;<br>    &#125;<br><br><br>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">DeprecatedMethod</span> &#123;<br>        <span class="hljs-meta">@Deprecated</span><br>        <span class="hljs-keyword">public</span> String <span class="hljs-title function_">print</span><span class="hljs-params">()</span> &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;DeprecatedMethod&quot;</span>;<br>        &#125;<br>    &#125;<br><br><br>    <span class="hljs-meta">@Deprecated</span><br>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">DeprecatedClass</span> &#123;<br>        <span class="hljs-keyword">public</span> String <span class="hljs-title function_">print</span><span class="hljs-params">()</span> &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;DeprecatedClass&quot;</span>;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        System.out.println(DeprecatedField.DEPRECATED_FIELD);<br><br>        <span class="hljs-type">DeprecatedMethod</span> <span class="hljs-variable">dm</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">DeprecatedMethod</span>();<br>        System.out.println(dm.print());<br><br><br>        <span class="hljs-type">DeprecatedClass</span> <span class="hljs-variable">dc</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">DeprecatedClass</span>();<br>        System.out.println(dc.print());<br>    &#125;<br>&#125;<br><span class="hljs-comment">//Output:</span><br><span class="hljs-comment">//DeprecatedField</span><br><span class="hljs-comment">//DeprecatedMethod</span><br><span class="hljs-comment">//DeprecatedClass</span><br></code></pre></td></tr></table></figure><h3 id="SuppressWarnnings"><a href="#SuppressWarnnings" class="headerlink" title="@SuppressWarnnings"></a>@SuppressWarnnings</h3><p><strong><a href="https://docs.oracle.com/javase/8/docs/api/java/lang/SuppressWarnings.html"><code>@SuppressWarnings</code></a> 用于关闭对类、方法、成员编译时产生的特定警告。</strong></p><p><code>@SuppressWarning</code> 不是一个标记注解。它有一个类型为 <code>String[]</code> 的数组成员，这个数组中存储的是要关闭的告警类型。对于 javac 编译器来讲，对 <code>-Xlint</code> 选项有效的警告名也同样对 <code>@SuppressWarings</code> 有效，同时编译器会忽略掉无法识别的警告名。</p><p><code>@SuppressWarning</code> 示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@SuppressWarnings(&#123;&quot;rawtypes&quot;, &quot;unchecked&quot;&#125;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">SuppressWarningsAnnotationDemo</span> &#123;<br>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">SuppressDemo</span>&lt;T&gt; &#123;<br>        <span class="hljs-keyword">private</span> T value;<br><br>        <span class="hljs-keyword">public</span> T <span class="hljs-title function_">getValue</span><span class="hljs-params">()</span> &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>.value;<br>        &#125;<br><br>        <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setValue</span><span class="hljs-params">(T <span class="hljs-keyword">var</span>)</span> &#123;<br>            <span class="hljs-built_in">this</span>.value = <span class="hljs-keyword">var</span>;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-meta">@SuppressWarnings(&#123;&quot;deprecation&quot;&#125;)</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">SuppressDemo</span> <span class="hljs-variable">d</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">SuppressDemo</span>();<br>        d.setValue(<span class="hljs-string">&quot;南京&quot;</span>);<br>        System.out.println(<span class="hljs-string">&quot;地名：&quot;</span> + d.getValue());<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><code>@SuppressWarnings</code> 注解的常见参数值的简单说明：</p><ul><li><code>deprecation</code> - 使用了不赞成使用的类或方法时的警告；</li><li><code>unchecked</code> - 执行了未检查的转换时的警告，例如当使用集合时没有用泛型 (Generics) 来指定集合保存的类型;</li><li><code>fallthrough</code> - 当 Switch 程序块直接通往下一种情况而没有 Break 时的警告;</li><li><code>path</code> - 在类路径、源文件路径等中有不存在的路径时的警告;</li><li><code>serial</code> - 当在可序列化的类上缺少 serialVersionUID 定义时的警告;</li><li><code>finally</code> - 任何 finally 子句不能正常完成时的警告;</li><li><code>all</code> - 所有的警告。</li></ul><h3 id="SafeVarargs"><a href="#SafeVarargs" class="headerlink" title="@SafeVarargs"></a>@SafeVarargs</h3><p><code>@SafeVarargs</code> 在 JDK7 中引入。</p><p><strong><a href="https://docs.oracle.com/javase/8/docs/api/java/lang/SafeVarargs.html"><code>@SafeVarargs</code></a> 的作用是：告诉编译器，在可变长参数中的泛型是类型安全的。可变长参数是使用数组存储的，而数组和泛型不能很好的混合使用。</strong></p><p>简单的说，数组元素的数据类型在编译和运行时都是确定的，而泛型的数据类型只有在运行时才能确定下来。因此，当把一个泛型存储到数组中时，编译器在编译阶段无法确认数据类型是否匹配，因此会给出警告信息；即如果泛型的真实数据类型无法和参数数组的类型匹配，会导致 <code>ClassCastException</code> 异常。</p><p><code>@SafeVarargs</code> 注解使用范围：</p><ul><li><code>@SafeVarargs</code> 注解可以用于构造方法。</li><li><code>@SafeVarargs</code> 注解可以用于 <code>static</code> 或 <code>final</code> 方法。</li></ul><p><code>@SafeVarargs</code> 示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">SafeVarargsAnnotationDemo</span> &#123;<br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 此方法实际上并不安全，不使用此注解，编译时会告警</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-meta">@SafeVarargs</span><br>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">wrongMethod</span><span class="hljs-params">(List&lt;String&gt;... stringLists)</span> &#123;<br>        Object[] array = stringLists;<br>        List&lt;Integer&gt; tmpList = Arrays.asList(<span class="hljs-number">42</span>);<br>        array[<span class="hljs-number">0</span>] = tmpList; <span class="hljs-comment">// 语法错误，但是编译不告警</span><br>        <span class="hljs-type">String</span> <span class="hljs-variable">s</span> <span class="hljs-operator">=</span> stringLists[<span class="hljs-number">0</span>].get(<span class="hljs-number">0</span>); <span class="hljs-comment">// 运行时报 ClassCastException</span><br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        List&lt;String&gt; list = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>        list.add(<span class="hljs-string">&quot;A&quot;</span>);<br>        list.add(<span class="hljs-string">&quot;B&quot;</span>);<br><br>        List&lt;String&gt; list2 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>        list.add(<span class="hljs-string">&quot;1&quot;</span>);<br>        list.add(<span class="hljs-string">&quot;2&quot;</span>);<br><br>        wrongMethod(list, list2);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>以上代码，如果不使用 <code>@SafeVarargs</code> ，编译时会告警</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java">[WARNING] /D:/Codes/ZP/Java/javacore/codes/basics/src/main/java/io/github/dunwu/javacore/annotation/SafeVarargsAnnotationDemo.java: 某些输入文件使用了未经检查或不安全的操作。<br>[WARNING] /D:/Codes/ZP/Java/javacore/codes/basics/src/main/java/io/github/dunwu/javacore/annotation/SafeVarargsAnnotationDemo.java: 有关详细信息, 请使用 -Xlint:unchecked 重新编译。<br></code></pre></td></tr></table></figure><h3 id="FunctionalInterface"><a href="#FunctionalInterface" class="headerlink" title="@FunctionalInterface"></a>@FunctionalInterface</h3><p><code>@FunctionalInterface</code> 在 JDK8 引入。</p><p><strong><a href="https://docs.oracle.com/javase/8/docs/api/java/lang/FunctionalInterface.html"><code>@FunctionalInterface</code></a> 用于指示被修饰的接口是函数式接口。</strong></p><p>需要注意的是，如果一个接口符合”函数式接口”定义，不加 <code>@FunctionalInterface</code> 也没关系；但如果编写的不是函数式接口，却使用 <code>@FunctionInterface</code>，那么编译器会报错。</p><p>什么是函数式接口？</p><p><strong>函数式接口(Functional Interface)就是一个有且仅有一个抽象方法，但是可以有多个非抽象方法的接口</strong>。函数式接口可以被隐式转换为 lambda 表达式。</p><p>函数式接口的特点：</p><ul><li>接口有且只能有个一个抽象方法（抽象方法只有方法定义，没有方法体）。</li><li>不能在接口中覆写 Object 类中的 public 方法（写了编译器也会报错）。</li><li>允许有 default 实现方法。</li></ul><p>示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">FunctionalInterfaceAnnotationDemo</span> &#123;<br><br>    <span class="hljs-meta">@FunctionalInterface</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">Func1</span>&lt;T&gt; &#123;<br>        <span class="hljs-keyword">void</span> <span class="hljs-title function_">printMessage</span><span class="hljs-params">(T message)</span>;<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@FunctionalInterface</span> 修饰的接口中定义两个抽象方法，编译时会报错</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> &lt;T&gt;</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-comment">/*@FunctionalInterface</span><br><span class="hljs-comment">    public interface Func2&lt;T&gt; &#123;</span><br><span class="hljs-comment">        void printMessage(T message);</span><br><span class="hljs-comment">        void printMessage2(T message);</span><br><span class="hljs-comment">    &#125;*/</span><br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">Func1</span> <span class="hljs-variable">func1</span> <span class="hljs-operator">=</span> message -&gt; System.out.println(message);<br>        func1.printMessage(<span class="hljs-string">&quot;Hello&quot;</span>);<br>        func1.printMessage(<span class="hljs-number">100</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="元注解"><a href="#元注解" class="headerlink" title="元注解"></a>元注解</h2><p>JDK 中虽然内置了几个注解，但这远远不能满足开发过程中遇到的千变万化的需求。所以我们需要自定义注解，而这就需要用到元注解。</p><p><strong>元注解的作用就是用于定义其它的注解</strong>。</p><p>Java 中提供了以下元注解类型：</p><ul><li><code>@Retention</code></li><li><code>@Target</code></li><li><code>@Documented</code></li><li><code>@Inherited</code>（JDK8 引入）</li><li><code>@Repeatable</code>（JDK8 引入）</li></ul><p>这些类型和它们所支持的类在 <code>java.lang.annotation</code> 包中可以找到。下面我们看一下每个元注解的作用和相应分参数的使用说明。</p><h3 id="Retention"><a href="#Retention" class="headerlink" title="@Retention"></a>@Retention</h3><p><strong><a href="https://docs.oracle.com/javase/8/docs/api/java/lang/annotation/Retention.html"><code>@Retention</code></a> 指明了注解的保留级别。</strong></p><p><code>@Retention</code> 源码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Documented</span><br><span class="hljs-meta">@Retention(RetentionPolicy.RUNTIME)</span><br><span class="hljs-meta">@Target(ElementType.ANNOTATION_TYPE)</span><br><span class="hljs-keyword">public</span> <span class="hljs-meta">@interface</span> Retention &#123;<br>    RetentionPolicy <span class="hljs-title function_">value</span><span class="hljs-params">()</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p><code>RetentionPolicy</code> 是一个枚举类型，它定义了被 <code>@Retention</code> 修饰的注解所支持的保留级别：</p><ul><li><code>RetentionPolicy.SOURCE</code> - 标记的注解仅在源文件中有效，编译器会忽略。</li><li><code>RetentionPolicy.CLASS</code> - 标记的注解在 class 文件中有效，JVM 会忽略。</li><li><code>RetentionPolicy.RUNTIME</code> - 标记的注解在运行时有效。</li></ul><p><code>@Retention</code> 示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Target(ElementType.FIELD)</span><br><span class="hljs-meta">@Retention(RetentionPolicy.RUNTIME)</span><br><span class="hljs-keyword">public</span> <span class="hljs-meta">@interface</span> Column &#123;<br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">name</span><span class="hljs-params">()</span> <span class="hljs-keyword">default</span> <span class="hljs-string">&quot;fieldName&quot;</span>;<br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">setFuncName</span><span class="hljs-params">()</span> <span class="hljs-keyword">default</span> <span class="hljs-string">&quot;setField&quot;</span>;<br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">getFuncName</span><span class="hljs-params">()</span> <span class="hljs-keyword">default</span> <span class="hljs-string">&quot;getField&quot;</span>;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">defaultDBValue</span><span class="hljs-params">()</span> <span class="hljs-keyword">default</span> <span class="hljs-literal">false</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="Documented"><a href="#Documented" class="headerlink" title="@Documented"></a>@Documented</h3><p><a href="https://docs.oracle.com/javase/8/docs/api/java/lang/annotation/Documented.html"><code>@Documented</code></a> 表示无论何时使用指定的注解，都应使用 Javadoc（默认情况下，注释不包含在 Javadoc 中）。</p><p><code>@Documented</code> 示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Target(ElementType.FIELD)</span><br><span class="hljs-meta">@Retention(RetentionPolicy.RUNTIME)</span><br><span class="hljs-meta">@Documented</span><br><span class="hljs-keyword">public</span> <span class="hljs-meta">@interface</span> Column &#123;<br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">name</span><span class="hljs-params">()</span> <span class="hljs-keyword">default</span> <span class="hljs-string">&quot;fieldName&quot;</span>;<br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">setFuncName</span><span class="hljs-params">()</span> <span class="hljs-keyword">default</span> <span class="hljs-string">&quot;setField&quot;</span>;<br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">getFuncName</span><span class="hljs-params">()</span> <span class="hljs-keyword">default</span> <span class="hljs-string">&quot;getField&quot;</span>;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">defaultDBValue</span><span class="hljs-params">()</span> <span class="hljs-keyword">default</span> <span class="hljs-literal">false</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="Target"><a href="#Target" class="headerlink" title="@Target"></a>@Target</h3><p><strong><a href="https://docs.oracle.com/javase/8/docs/api/java/lang/annotation/Target.html"><code>@Target</code></a> 指定注解可以修饰的元素类型。</strong></p><p><code>@Target</code> 源码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Documented</span><br><span class="hljs-meta">@Retention(RetentionPolicy.RUNTIME)</span><br><span class="hljs-meta">@Target(ElementType.ANNOTATION_TYPE)</span><br><span class="hljs-keyword">public</span> <span class="hljs-meta">@interface</span> Target &#123;<br>    ElementType[] value();<br>&#125;<br></code></pre></td></tr></table></figure><p><code>ElementType</code> 是一个枚举类型，它定义了被 <code>@Target</code> 修饰的注解可以应用的范围：</p><ul><li><code>ElementType.ANNOTATION_TYPE</code> - 标记的注解可以应用于注解类型。</li><li><code>ElementType.CONSTRUCTOR</code> - 标记的注解可以应用于构造函数。</li><li><code>ElementType.FIELD</code> - 标记的注解可以应用于字段或属性。</li><li><code>ElementType.LOCAL_VARIABLE</code> - 标记的注解可以应用于局部变量。</li><li><code>ElementType.METHOD</code> - 标记的注解可以应用于方法。</li><li><code>ElementType.PACKAGE</code> - 标记的注解可以应用于包声明。</li><li><code>ElementType.PARAMETER</code> - 标记的注解可以应用于方法的参数。</li><li><code>ElementType.TYPE</code> - 标记的注解可以应用于类的任何元素。</li></ul><p><code>@Target</code> 示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Target(ElementType.TYPE)</span><br><span class="hljs-keyword">public</span> <span class="hljs-meta">@interface</span> Table &#123;<br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 数据表名称注解，默认值为类名称</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span></span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">tableName</span><span class="hljs-params">()</span> <span class="hljs-keyword">default</span> <span class="hljs-string">&quot;className&quot;</span>;<br>&#125;<br><br><span class="hljs-meta">@Target(ElementType.FIELD)</span><br><span class="hljs-keyword">public</span> <span class="hljs-meta">@interface</span> NoDBColumn &#123;&#125;<br></code></pre></td></tr></table></figure><h3 id="Inherited"><a href="#Inherited" class="headerlink" title="@Inherited"></a>@Inherited</h3><p><strong><a href="https://docs.oracle.com/javase/8/docs/api/java/lang/annotation/Inherited.html"><code>@Inherited</code></a> 表示注解类型可以被继承（默认情况下不是这样）</strong>。</p><p>表示自动继承注解类型。 如果注解类型声明中存在 <code>@Inherited</code> 元注解，则注解所修饰类的所有子类都将会继承此注解。</p><blockquote><p>注意：<code>@Inherited</code> 注解类型是被标注过的类的子类所继承。类并不从它所实现的接口继承注解，方法并不从它所覆写的方法继承注解。</p><p>此外，当 <code>@Inherited</code> 类型标注的注解的 <code>@Retention</code> 是 <code>RetentionPolicy.RUNTIME</code>，则反射 API 增强了这种继承性。如果我们使用 <code>java.lang.reflect</code> 去查询一个 <code>@Inherited</code> 类型的注解时，反射代码检查将展开工作：检查类和其父类，直到发现指定的注解类型被发现，或者到达类继承结构的顶层。</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Inherited</span><br><span class="hljs-keyword">public</span> <span class="hljs-meta">@interface</span> Greeting &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">enum</span> <span class="hljs-title class_">FontColor</span>&#123; BULE,RED,GREEN&#125;;<br>    String <span class="hljs-title function_">name</span><span class="hljs-params">()</span>;<br>    FontColor <span class="hljs-title function_">fontColor</span><span class="hljs-params">()</span> <span class="hljs-keyword">default</span> FontColor.GREEN;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="Repeatable"><a href="#Repeatable" class="headerlink" title="@Repeatable"></a>@Repeatable</h3><p><strong><a href="https://docs.oracle.com/javase/8/docs/api/java/lang/annotation/Repeatable.html"><code>@Repeatable</code></a> 表示注解可以重复使用。</strong></p><p>以 Spring <code>@Scheduled</code> 为例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Target(&#123;ElementType.METHOD, ElementType.ANNOTATION_TYPE&#125;)</span><br><span class="hljs-meta">@Retention(RetentionPolicy.RUNTIME)</span><br><span class="hljs-meta">@Documented</span><br><span class="hljs-keyword">public</span> <span class="hljs-meta">@interface</span> Schedules &#123;<br>Scheduled[] value();<br>&#125;<br><br><span class="hljs-meta">@Target(&#123;ElementType.METHOD, ElementType.ANNOTATION_TYPE&#125;)</span><br><span class="hljs-meta">@Retention(RetentionPolicy.RUNTIME)</span><br><span class="hljs-meta">@Documented</span><br><span class="hljs-meta">@Repeatable(Schedules.class)</span><br><span class="hljs-keyword">public</span> <span class="hljs-meta">@interface</span> Scheduled &#123;<br>  <span class="hljs-comment">// ...</span><br>&#125;<br></code></pre></td></tr></table></figure><p>应用示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">TaskRunner</span> &#123;<br><br>    <span class="hljs-meta">@Scheduled(&quot;0 0/15 * * * ?&quot;)</span><br>    <span class="hljs-meta">@Scheduled(&quot;0 0 12 * ?&quot;)</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">task1</span><span class="hljs-params">()</span> &#123;&#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="自定义注解"><a href="#自定义注解" class="headerlink" title="自定义注解"></a>自定义注解</h2><p>使用 <code>@interface</code> 自定义注解时，自动继承了 <code>java.lang.annotation.Annotation</code> 接口，由编译程序自动完成其他细节。在定义注解时，不能继承其他的注解或接口。<code>@interface</code> 用来声明一个注解，其中的每一个方法实际上是声明了一个配置参数。方法的名称就是参数的名称，返回值类型就是参数的类型（返回值类型只能是基本类型、Class、String、enum）。可以通过 <code>default</code> 来声明参数的默认值。</p><p>这里通过实现一个名为 <code>RegexValid</code> 的正则校验注解工具来展示自定义注解的全步骤。</p><h3 id="注解的定义"><a href="#注解的定义" class="headerlink" title="注解的定义"></a>注解的定义</h3><p>注解的语法格式如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-meta">@interface</span> 注解名 &#123;定义体&#125;<br></code></pre></td></tr></table></figure><p>我们来定义一个注解：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Documented</span><br><span class="hljs-meta">@Target(&#123;ElementType.FIELD, ElementType.PARAMETER&#125;)</span><br><span class="hljs-meta">@Retention(RetentionPolicy.RUNTIME)</span><br><span class="hljs-keyword">public</span> <span class="hljs-meta">@interface</span> RegexValid &#123;&#125;<br></code></pre></td></tr></table></figure><blockquote><p>说明：</p><p>通过上一节对于元注解 <a href="https://github.com/dunwu/javacore/blob/master/docs/01.Java/01.JavaSE/01.%E5%9F%BA%E7%A1%80%E7%89%B9%E6%80%A7/11.Java%E6%B3%A8%E8%A7%A3.md#target"><code>@Target</code></a>、<a href="https://github.com/dunwu/javacore/blob/master/docs/01.Java/01.JavaSE/01.%E5%9F%BA%E7%A1%80%E7%89%B9%E6%80%A7/11.Java%E6%B3%A8%E8%A7%A3.md#retention"><code>@Retention</code></a>、<a href="https://github.com/dunwu/javacore/blob/master/docs/01.Java/01.JavaSE/01.%E5%9F%BA%E7%A1%80%E7%89%B9%E6%80%A7/11.Java%E6%B3%A8%E8%A7%A3.md#documented"><code>@Documented</code></a> 的说明，这里就很容易理解了。</p><ul><li>上面的代码中定义了一个名为 <code>@RegexValid</code> 的注解。</li><li><code>@Documented</code> 表示 <code>@RegexValid</code> 应该使用 javadoc。</li><li><code>@Target(&#123;ElementType.FIELD, ElementType.PARAMETER&#125;)</code> 表示 <code>@RegexValid</code> 可以在类成员或方法参数上修饰。</li><li>@Retention(RetentionPolicy.RUNTIME) 表示 <code>@RegexValid</code> 在运行时有效。</li></ul></blockquote><p>此时，我们已经定义了一个没有任何属性的注解，如果到此为止，它仅仅是一个标记注解。作为正则工具，没有属性可什么也做不了。接下来，我们将为它添加注解属性。</p><h3 id="注解属性"><a href="#注解属性" class="headerlink" title="注解属性"></a>注解属性</h3><p>注解属性的语法形式如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">[访问级别修饰符] [数据类型] 名称() <span class="hljs-keyword">default</span> 默认值;<br></code></pre></td></tr></table></figure><p>例如，我们要定义在注解中定义一个名为 value 的字符串属性，其默认值为空字符串，访问级别为默认级别，那么应该定义如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">String <span class="hljs-title function_">value</span><span class="hljs-params">()</span> <span class="hljs-keyword">default</span> <span class="hljs-string">&quot;&quot;</span>;<br></code></pre></td></tr></table></figure><blockquote><p>🔔 注意：**在注解中，我们定义属性时，属性名后面需要加 <code>()</code>**。</p></blockquote><p>定义注解属性有以下要点：</p><ul><li><p><strong>注解属性只能使用 <code>public</code> 或默认访问级别（即不指定访问级别修饰符）修饰</strong>。</p></li><li><p><strong>注解属性的数据类型有限制要求</strong>。支持的数据类型如下：</p><ul><li>所有基本数据类型（byte、char、short、int、long、float、double、boolean）</li><li>String 类型</li><li>Class 类</li><li>enum 类型</li><li>Annotation 类型</li><li>以上所有类型的数组</li></ul></li><li><p><strong>注解属性必须有确定的值，建议指定默认值</strong>。注解属性只能通过指定默认值或使用注解时指定属性值，相较之下，指定默认值的方式更为可靠。注解属性如果是引用类型，不可以为 null。这个约束使得注解处理器很难判断注解属性是默认值，或是使用注解时所指定的属性值。为此，我们设置默认值时，一般会定义一些特殊的值，例如空字符串或者负数。</p></li><li><p>如果注解中只有一个属性值，最好将其命名为 value。因为，指定属性名为 value，在使用注解时，指定 value 的值可以不指定属性名称。</p></li></ul><p>示例：</p><p>了解了注解属性的定义要点，让我们来为 <code>@RegexValid</code> 注解定义几个属性。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Documented</span><br><span class="hljs-meta">@Target(&#123;ElementType.FIELD, ElementType.PARAMETER&#125;)</span><br><span class="hljs-meta">@Retention(RetentionPolicy.RUNTIME)</span><br><span class="hljs-keyword">public</span> <span class="hljs-meta">@interface</span> RegexValid &#123;<br>    <span class="hljs-keyword">enum</span> <span class="hljs-title class_">Policy</span> &#123;<br>        <span class="hljs-comment">// @formatter:off</span><br>        EMPTY(<span class="hljs-literal">null</span>),<br>        DATE(<span class="hljs-string">&quot;^(?:(?!0000)[0-9]&#123;4&#125;([-/.]?)(?:(?:0?[1-9]|1[0-2])\\1(?:0?[1-9]|1[0-9]|2[0-8])|(?:0?[13-9]|1[0-2])\\1&quot;</span><br>            + <span class="hljs-string">&quot;(?:29|30)|(?:0?[13578]|1[02])\\1(?:31))|(?:[0-9]&#123;2&#125;(?:0[48]|[2468][048]|[13579][26])|&quot;</span><br>            + <span class="hljs-string">&quot;(?:0[48]|[2468][048]|[13579][26])00)([-/.]?)0?2\\2(?:29))$&quot;</span>),<br>        MAIL(<span class="hljs-string">&quot;^[A-Za-z0-9](([_\\.\\-]?[a-zA-Z0-9]+)*)@([A-Za-z0-9]+)(([\\.\\-]?[a-zA-Z0-9]+)*)\\.([A-Za-z]&#123;2,&#125;)$&quot;</span>);<br>        <span class="hljs-comment">// @formatter:on</span><br><br>        <span class="hljs-keyword">private</span> String policy;<br><br>        Policy(String policy) &#123;<br>            <span class="hljs-built_in">this</span>.policy = policy;<br>        &#125;<br><br>        <span class="hljs-keyword">public</span> String <span class="hljs-title function_">getPolicy</span><span class="hljs-params">()</span> &#123;<br>            <span class="hljs-keyword">return</span> policy;<br>        &#125;<br>    &#125;<br><br>    String <span class="hljs-title function_">value</span><span class="hljs-params">()</span> <span class="hljs-keyword">default</span> <span class="hljs-string">&quot;&quot;</span>;<br>    Policy <span class="hljs-title function_">policy</span><span class="hljs-params">()</span> <span class="hljs-keyword">default</span> Policy.EMPTY;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>说明：</p><p>在上面的示例代码中，我们定义了两个注解属性：<code>String</code> 类型的 value 属性和 <code>Policy</code> 枚举类型的 policy 属性。<code>Policy</code> 枚举中定义了几个默认的正则表达式，这是为了直接使用这几个常用表达式去正则校验。考虑到，我们可能需要自己传入一些自定义正则表达式去校验其他场景，所以定义了 value 属性，允许使用者传入正则表达式。</p></blockquote><p>至此，<code>@RegexValid</code> 的声明已经结束。但是，程序仍不知道如何处理 <code>@RegexValid</code> 这个注解。我们还需要定义注解处理器。</p><h3 id="注解处理器"><a href="#注解处理器" class="headerlink" title="注解处理器"></a>注解处理器</h3><p>如果没有用来读取注解的方法和工作，那么注解也就不会比注释更有用处了。使用注解的过程中，很重要的一部分就是创建于使用注解处理器。JDK5 扩展了反射机制的 API，以帮助程序员快速的构造自定义注解处理器。</p><p><strong><code>java.lang.annotation.Annotation</code> 是一个接口，程序可以通过反射来获取指定程序元素的注解对象，然后通过注解对象来获取注解里面的元数据</strong>。</p><p><code>Annotation</code> 接口源码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">Annotation</span> &#123;<br>    <span class="hljs-type">boolean</span> <span class="hljs-title function_">equals</span><span class="hljs-params">(Object obj)</span>;<br><br>    <span class="hljs-type">int</span> <span class="hljs-title function_">hashCode</span><span class="hljs-params">()</span>;<br><br>    String <span class="hljs-title function_">toString</span><span class="hljs-params">()</span>;<br><br>    Class&lt;? <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Annotation</span>&gt; annotationType();<br>&#125;<br></code></pre></td></tr></table></figure><p>除此之外，Java 中支持<strong>注解处理器接口 <code>java.lang.reflect.AnnotatedElement</code></strong> ，该接口代表程序中可以接受注解的程序元素，该接口主要有如下几个实现类：</p><ul><li><code>Class</code> - 类定义</li><li><code>Constructor</code> - 构造器定义</li><li><code>Field</code> - 类的成员变量定义</li><li><code>Method</code> - 类的方法定义</li><li><code>Package</code> - 类的包定义</li></ul><p><code>java.lang.reflect</code> 包下主要包含一些实现反射功能的工具类。实际上，<code>java.lang.reflect</code> 包所有提供的反射 API 扩充了读取运行时注解信息的能力。当一个注解类型被定义为运行时的注解后，该注解才能是运行时可见，当 class 文件被装载时被保存在 class 文件中的注解才会被虚拟机读取。 <code>AnnotatedElement</code> 接口是所有程序元素（Class、Method 和 Constructor）的父接口，所以程序通过反射获取了某个类的<code>AnnotatedElement</code> 对象之后，程序就可以调用该对象的如下四个个方法来访问注解信息：</p><ul><li><code>getAnnotation</code> - 返回该程序元素上存在的、指定类型的注解，如果该类型注解不存在，则返回 null。</li><li><code>getAnnotations</code> - 返回该程序元素上存在的所有注解。</li><li><code>isAnnotationPresent</code> - 判断该程序元素上是否包含指定类型的注解，存在则返回 true，否则返回 false。</li><li><code>getDeclaredAnnotations</code> - 返回直接存在于此元素上的所有注释。与此接口中的其他方法不同，该方法将忽略继承的注释。（如果没有注释直接存在于此元素上，则返回长度为零的一个数组。）该方法的调用者可以随意修改返回的数组；这不会对其他调用者返回的数组产生任何影响。</li></ul><p>了解了以上内容，让我们来实现 <code>@RegexValid</code> 的注解处理器：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.lang.reflect.Field;<br><span class="hljs-keyword">import</span> java.util.regex.Matcher;<br><span class="hljs-keyword">import</span> java.util.regex.Pattern;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">RegexValidUtil</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">check</span><span class="hljs-params">(Object obj)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>        <span class="hljs-type">boolean</span> <span class="hljs-variable">result</span> <span class="hljs-operator">=</span> <span class="hljs-literal">true</span>;<br>        <span class="hljs-type">StringBuilder</span> <span class="hljs-variable">sb</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">StringBuilder</span>();<br>        Field[] fields = obj.getClass().getDeclaredFields();<br>        <span class="hljs-keyword">for</span> (Field field : fields) &#123;<br>            <span class="hljs-comment">// 判断成员是否被 @RegexValid 注解所修饰</span><br>            <span class="hljs-keyword">if</span> (field.isAnnotationPresent(RegexValid.class)) &#123;<br>                <span class="hljs-type">RegexValid</span> <span class="hljs-variable">valid</span> <span class="hljs-operator">=</span> field.getAnnotation(RegexValid.class);<br><br>                <span class="hljs-comment">// 如果 value 为空字符串，说明没有注入自定义正则表达式，改用 policy 属性</span><br>                <span class="hljs-type">String</span> <span class="hljs-variable">value</span> <span class="hljs-operator">=</span> valid.value();<br>                <span class="hljs-keyword">if</span> (<span class="hljs-string">&quot;&quot;</span>.equals(value)) &#123;<br>                    RegexValid.<span class="hljs-type">Policy</span> <span class="hljs-variable">policy</span> <span class="hljs-operator">=</span> valid.policy();<br>                    value = policy.getPolicy();<br>                &#125;<br><br>                <span class="hljs-comment">// 通过设置 setAccessible(true) 来访问私有成员</span><br>                field.setAccessible(<span class="hljs-literal">true</span>);<br>                <span class="hljs-type">Object</span> <span class="hljs-variable">fieldObj</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br>                <span class="hljs-keyword">try</span> &#123;<br>                    fieldObj = field.get(obj);<br>                &#125; <span class="hljs-keyword">catch</span> (IllegalAccessException e) &#123;<br>                    e.printStackTrace();<br>                &#125;<br>                <span class="hljs-keyword">if</span> (fieldObj == <span class="hljs-literal">null</span>) &#123;<br>                    sb.append(<span class="hljs-string">&quot;\n&quot;</span>)<br>                        .append(String.format(<span class="hljs-string">&quot;%s 类中的 %s 字段不能为空！&quot;</span>, obj.getClass().getName(), field.getName()));<br>                    result = <span class="hljs-literal">false</span>;<br>                &#125; <span class="hljs-keyword">else</span> &#123;<br>                    <span class="hljs-keyword">if</span> (fieldObj <span class="hljs-keyword">instanceof</span> String) &#123;<br>                        <span class="hljs-type">String</span> <span class="hljs-variable">text</span> <span class="hljs-operator">=</span> (String) fieldObj;<br>                        <span class="hljs-type">Pattern</span> <span class="hljs-variable">p</span> <span class="hljs-operator">=</span> Pattern.compile(value);<br>                        <span class="hljs-type">Matcher</span> <span class="hljs-variable">m</span> <span class="hljs-operator">=</span> p.matcher(text);<br>                        result = m.matches();<br>                        <span class="hljs-keyword">if</span> (!result) &#123;<br>                            sb.append(<span class="hljs-string">&quot;\n&quot;</span>).append(String.format(<span class="hljs-string">&quot;%s 不是合法的 %s ！&quot;</span>, text, field.getName()));<br>                        &#125;<br>                    &#125; <span class="hljs-keyword">else</span> &#123;<br>                        sb.append(<span class="hljs-string">&quot;\n&quot;</span>).append(<br>                            String.format(<span class="hljs-string">&quot;%s 类中的 %s 字段不是字符串类型，不能使用此注解校验！&quot;</span>, obj.getClass().getName(), field.getName()));<br>                        result = <span class="hljs-literal">false</span>;<br>                    &#125;<br>                &#125;<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-keyword">if</span> (sb.length() &gt; <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Exception</span>(sb.toString());<br>        &#125;<br>        <span class="hljs-keyword">return</span> result;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>说明：</p><p>以上示例中的注解处理器，执行步骤如下：</p><ol><li>通过 getDeclaredFields 反射方法获取传入对象的所有成员。</li><li>遍历成员，使用 isAnnotationPresent 判断成员是否被指定注解所修饰，如果不是，直接跳过。</li><li>如果成员被注解所修饰，通过 <code>RegexValid valid = field.getAnnotation(RegexValid.class);</code> 这样的形式获取，注解实例化对象，然后，就可以使用 <code>valid.value()</code> 或 <code>valid.policy()</code> 这样的形式获取注解中设定的属性值。</li><li>根据属性值，进行逻辑处理。</li></ol><h3 id="使用注解"><a href="#使用注解" class="headerlink" title="使用注解"></a>使用注解</h3><p>完成了以上工作，我们就可以使用自定义注解了，示例如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">RegexValidDemo</span> &#123;<br>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">User</span> &#123;<br>        <span class="hljs-keyword">private</span> String name;<br>        <span class="hljs-meta">@RegexValid(policy = RegexValid.Policy.DATE)</span><br>        <span class="hljs-keyword">private</span> String date;<br>        <span class="hljs-meta">@RegexValid(policy = RegexValid.Policy.MAIL)</span><br>        <span class="hljs-keyword">private</span> String mail;<br>        <span class="hljs-meta">@RegexValid(&quot;^((\\+)?86\\s*)?((13[0-9])|(15([0-3]|[5-9]))|(18[0,2,5-9]))\\d&#123;8&#125;$&quot;)</span><br>        <span class="hljs-keyword">private</span> String phone;<br><br>        <span class="hljs-keyword">public</span> <span class="hljs-title function_">User</span><span class="hljs-params">(String name, String date, String mail, String phone)</span> &#123;<br>            <span class="hljs-built_in">this</span>.name = name;<br>            <span class="hljs-built_in">this</span>.date = date;<br>            <span class="hljs-built_in">this</span>.mail = mail;<br>            <span class="hljs-built_in">this</span>.phone = phone;<br>        &#125;<br><br>        <span class="hljs-meta">@Override</span><br>        <span class="hljs-keyword">public</span> String <span class="hljs-title function_">toString</span><span class="hljs-params">()</span> &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;User&#123;&quot;</span> + <span class="hljs-string">&quot;name=&#x27;&quot;</span> + name + <span class="hljs-string">&#x27;\&#x27;&#x27;</span> + <span class="hljs-string">&quot;, date=&#x27;&quot;</span> + date + <span class="hljs-string">&#x27;\&#x27;&#x27;</span> + <span class="hljs-string">&quot;, mail=&#x27;&quot;</span> + mail + <span class="hljs-string">&#x27;\&#x27;&#x27;</span> + <span class="hljs-string">&quot;, phone=&#x27;&quot;</span><br>                + phone + <span class="hljs-string">&#x27;\&#x27;&#x27;</span> + <span class="hljs-string">&#x27;&#125;&#x27;</span>;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">printDate</span><span class="hljs-params">(<span class="hljs-meta">@RegexValid(policy = RegexValid.Policy.DATE)</span> String date)</span>&#123;<br>        System.out.println(date);<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>        <span class="hljs-type">User</span> <span class="hljs-variable">user</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">User</span>(<span class="hljs-string">&quot;Tom&quot;</span>, <span class="hljs-string">&quot;1990-01-31&quot;</span>, <span class="hljs-string">&quot;xxx@163.com&quot;</span>, <span class="hljs-string">&quot;18612341234&quot;</span>);<br>        <span class="hljs-type">User</span> <span class="hljs-variable">user2</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">User</span>(<span class="hljs-string">&quot;Jack&quot;</span>, <span class="hljs-string">&quot;2019-02-29&quot;</span>, <span class="hljs-string">&quot;sadhgs&quot;</span>, <span class="hljs-string">&quot;183xxxxxxxx&quot;</span>);<br>        <span class="hljs-keyword">if</span> (RegexValidUtil.check(user)) &#123;<br>            System.out.println(user + <span class="hljs-string">&quot;正则校验通过&quot;</span>);<br>        &#125;<br>        <span class="hljs-keyword">if</span> (RegexValidUtil.check(user2)) &#123;<br>            System.out.println(user2 + <span class="hljs-string">&quot;正则校验通过&quot;</span>);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>JavaSE</category>
      
    </categories>
    
    
    <tags>
      
      <tag>特性</tag>
      
      <tag>注解</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Java 反射和动态代理</title>
    <link href="/java%E5%8F%8D%E5%B0%84%E5%92%8C%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86.html"/>
    <url>/java%E5%8F%8D%E5%B0%84%E5%92%8C%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86.html</url>
    
    <content type="html"><![CDATA[<p>Java 反射机制是在运行状态中，对于任意一个类，都能够知道这个类的所有属性和方法；对于任意一个对象，都能够调用它的任意一个方法和属性，这种动态获取的信息以及动态调用对象的方法的功能称为 Java 语言的反射机制。</p><span id="more"></span><blockquote><p>转载：<a href="https://dunwu.github.io/javacore/pages/0d066a/">深入理解 Java 反射和动态代理</a>（有改动）</p></blockquote><h2 id="反射简介"><a href="#反射简介" class="headerlink" title="反射简介"></a>反射简介</h2><h3 id="什么是反射"><a href="#什么是反射" class="headerlink" title="什么是反射"></a>什么是反射</h3><p>反射(Reflection)是 Java 程序开发语言的特征之一，它允许运行中的 Java 程序获取自身的信息，并且可以操作类或对象的内部属性。</p><p><strong>通过反射机制，可以在运行时访问 Java 对象的属性，方法，构造方法等。</strong></p><h3 id="反射的应用场景"><a href="#反射的应用场景" class="headerlink" title="反射的应用场景"></a>反射的应用场景</h3><p>反射的主要应用场景有：</p><ul><li><strong>开发通用框架</strong> - 反射最重要的用途就是开发各种通用框架。很多框架（比如 Spring）都是配置化的（比如通过 XML 文件配置 JavaBean、Filter 等），为了保证框架的通用性，它们可能需要根据配置文件加载不同的对象或类，调用不同的方法，这个时候就必须用到反射——运行时动态加载需要加载的对象。</li><li><strong>动态代理</strong> - 在切面编程（AOP）中，需要拦截特定的方法，通常，会选择动态代理方式。这时，就需要反射技术来实现了。</li><li><strong>注解</strong> - 注解本身仅仅是起到标记作用，它需要利用反射机制，根据注解标记去调用注解解释器，执行行为。如果没有反射机制，注解并不比注释更有用。</li><li><strong>可扩展性功能</strong> - 应用程序可以通过使用完全限定名称创建可扩展性对象实例来使用外部的用户定义类。</li></ul><h3 id="反射的缺点"><a href="#反射的缺点" class="headerlink" title="反射的缺点"></a>反射的缺点</h3><ul><li><strong>性能开销</strong> - 由于反射涉及动态解析的类型，因此无法执行某些 Java 虚拟机优化。因此，反射操作的性能要比非反射操作的性能要差，应该在性能敏感的应用程序中频繁调用的代码段中避免。</li><li><strong>破坏封装性</strong> - 反射调用方法时可以忽略权限检查，因此可能会破坏封装性而导致安全问题。</li><li><strong>内部曝光</strong> - 由于反射允许代码执行在非反射代码中非法的操作，例如访问私有字段和方法，所以反射的使用可能会导致意想不到的副作用，这可能会导致代码功能失常并可能破坏可移植性。反射代码打破了抽象，因此可能会随着平台的升级而改变行为。</li></ul><h2 id="反射机制"><a href="#反射机制" class="headerlink" title="反射机制"></a>反射机制</h2><h3 id="类加载过程"><a href="#类加载过程" class="headerlink" title="类加载过程"></a>类加载过程</h3><img src="https://cdn.jsdelivr.net/gh/gejoyy/Pictures@main/java%E7%B1%BB%E5%8A%A0%E8%BD%BD%E8%BF%87%E7%A8%8B.png" alt="java类加载过程" style="zoom: 67%;" /><p>类加载的完整过程如下：</p><ol><li>在编译时，Java 编译器编译好 <code>.java</code> 文件之后，在磁盘中产生 <code>.class</code> 文件。<code>.class</code> 文件是二进制文件，内容是只有 JVM 能够识别的机器码。</li><li>JVM 中的类加载器读取字节码文件，取出二进制数据，加载到内存中，解析.class 文件内的信息。类加载器会根据类的全限定名来获取此类的二进制字节流；然后，将字节流所代表的静态存储结构转化为方法区的运行时数据结构；接着，在内存中生成代表这个类的 <code>java.lang.Class</code> 对象。</li><li>加载结束后，JVM 开始进行连接阶段（包含验证、准备、初始化）。经过这一系列操作，类的变量会被初始化。</li></ol><h3 id="Class-对象"><a href="#Class-对象" class="headerlink" title="Class 对象"></a>Class 对象</h3><p>要想使用反射，首先需要获得待操作的类所对应的 Class 对象。<strong>Java 中，无论生成某个类的多少个对象，这些对象都会对应于同一个 Class 对象。这个 Class 对象是由 JVM 生成的，通过它能够获悉整个类的结构</strong>。所以，<code>java.lang.Class</code> 可以视为所有反射 API 的入口点。</p><p><strong>反射的本质就是：在运行时，把 Java 类中的各种成分映射成一个个的 Java 对象。</strong></p><p>举例来说，假如定义了以下代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">User</span> <span class="hljs-variable">user</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">User</span>();<br></code></pre></td></tr></table></figure><p>步骤说明：</p><ol><li>JVM 加载方法的时候，遇到 <code>new User()</code>，JVM 会根据 <code>User</code> 的全限定名去加载 <code>User.class</code> 。</li><li>JVM 会去本地磁盘查找 <code>User.class</code> 文件并加载 JVM 内存中。</li><li>JVM 通过调用类加载器自动创建这个类对应的 <code>Class</code> 对象，并且存储在 JVM 的方法区。注意：<strong>一个类有且只有一个 <code>Class</code> 对象</strong>。</li></ol><h3 id="方法的反射调用"><a href="#方法的反射调用" class="headerlink" title="方法的反射调用"></a>方法的反射调用</h3><p>方法的反射调用，也就是 <code>Method.invoke</code> 方法。</p><p><code>Method.invoke</code> 方法源码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Method</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Executable</span> &#123;<br>  ...<br>  <span class="hljs-keyword">public</span> Object <span class="hljs-title function_">invoke</span><span class="hljs-params">(Object obj, Object... args)</span> <span class="hljs-keyword">throws</span> ... &#123;<br>    ... <span class="hljs-comment">// 权限检查</span><br>    <span class="hljs-type">MethodAccessor</span> <span class="hljs-variable">ma</span> <span class="hljs-operator">=</span> methodAccessor;<br>    <span class="hljs-keyword">if</span> (ma == <span class="hljs-literal">null</span>) &#123;<br>      ma = acquireMethodAccessor();<br>    &#125;<br>    <span class="hljs-keyword">return</span> ma.invoke(obj, args);<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="反射调用的开销"><a href="#反射调用的开销" class="headerlink" title="反射调用的开销"></a>反射调用的开销</h3><p>方法的反射调用会带来不少性能开销，原因主要有三个：</p><ul><li>变长参数方法导致的 Object 数组</li><li>基本类型的自动装箱、拆箱</li><li>还有最重要的方法内联</li></ul><p><code>Class.forName</code> 会调用本地方法，<code>Class.getMethod</code> 则会遍历该类的公有方法。如果没有匹配到，它还将遍历父类的公有方法。可想而知，这两个操作都非常费时。</p><blockquote><p>注意，以 <code>getMethod</code> 为代表的查找方法操作，会返回查找得到结果的一份拷贝。因此，我们应当避免在热点代码中使用返回 <code>Method</code> 数组的 <code>getMethods</code> 或者 <code>getDeclaredMethods</code> 方法，以减少不必要的堆空间消耗。在实践中，我们往往会在应用程序中缓存 <code>Class.forName</code> 和 <code>Class.getMethod</code> 的结果。</p></blockquote><p>下面只关注反射调用本身的性能开销。</p><p>第一，由于 Method.invoke 是一个变长参数方法，在字节码层面它的最后一个参数会是 Object 数组。Java 编译器会在方法调用处生成一个长度为传入参数数量的 Object 数组，并将传入参数一一存储进该数组中。</p><p>第二，由于 Object 数组不能存储基本类型，Java 编译器会对传入的基本类型参数进行自动装箱。</p><p>这两个操作除了带来性能开销外，还可能占用堆内存，使得 GC 更加频繁。（如果你感兴趣的话，可以用虚拟机参数 -XX:+PrintGC 试试。）那么，如何消除这部分开销呢？</p><h2 id="使用反射"><a href="#使用反射" class="headerlink" title="使用反射"></a>使用反射</h2><h3 id="java-lang-reflect-包"><a href="#java-lang-reflect-包" class="headerlink" title="java.lang.reflect 包"></a>java.lang.reflect 包</h3><p>Java 中的 <code>java.lang.reflect</code> 包提供了反射功能。<code>java.lang.reflect</code> 包中的类都没有 <code>public</code> 构造方法。</p><p><code>java.lang.reflect</code> 包的核心接口和类如下：</p><ul><li><code>Member</code> 接口：反映关于单个成员(字段或方法)或构造函数的标识信息。</li><li><code>Field</code> 类：提供一个类的域的信息以及访问类的域的接口。</li><li><code>Method</code> 类：提供一个类的方法的信息以及访问类的方法的接口。</li><li><code>Constructor</code> 类：提供一个类的构造函数的信息以及访问类的构造函数的接口。</li><li><code>Array</code> 类：该类提供动态地生成和访问 JAVA 数组的方法。</li><li><code>Modifier</code> 类：提供了 static 方法和常量，对类和成员访问修饰符进行解码。</li><li><code>Proxy</code> 类：提供动态地生成代理类和类实例的静态方法。</li></ul><h3 id="获取-Class-对象"><a href="#获取-Class-对象" class="headerlink" title="获取 Class 对象"></a>获取 Class 对象</h3><p>获取 <code>Class</code> 对象的三种方法：</p><p>（1）**<code>Class.forName</code> 静态方法**</p><p>【示例】使用 <code>Class.forName</code> 静态方法获取 <code>Class</code> 对象</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> io.github.dunwu.javacore.reflect;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ReflectClassDemo01</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> ClassNotFoundException &#123;<br>        <span class="hljs-type">Class</span> <span class="hljs-variable">c1</span> <span class="hljs-operator">=</span> Class.forName(<span class="hljs-string">&quot;io.github.dunwu.javacore.reflect.ReflectClassDemo01&quot;</span>);<br>        System.out.println(c1.getCanonicalName());<br><br>        <span class="hljs-type">Class</span> <span class="hljs-variable">c2</span> <span class="hljs-operator">=</span> Class.forName(<span class="hljs-string">&quot;[D&quot;</span>);<br>        System.out.println(c2.getCanonicalName());<br><br>        <span class="hljs-type">Class</span> <span class="hljs-variable">c3</span> <span class="hljs-operator">=</span> Class.forName(<span class="hljs-string">&quot;[[Ljava.lang.String;&quot;</span>);<br>        System.out.println(c3.getCanonicalName());<br>    &#125;<br>&#125;<br><span class="hljs-comment">//Output:</span><br><span class="hljs-comment">//io.github.dunwu.javacore.reflect.ReflectClassDemo01</span><br><span class="hljs-comment">//double[]</span><br><span class="hljs-comment">//java.lang.String[][]</span><br></code></pre></td></tr></table></figure><p>使用类的完全限定名来反射对象的类。常见的应用场景为：在 JDBC 开发中常用此方法加载数据库驱动。</p><p>（2）<strong>类名 + <code>.class</code></strong></p><p>【示例】直接用类名 + <code>.class</code> 获取 <code>Class</code> 对象</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ReflectClassDemo02</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">boolean</span> b;<br>        <span class="hljs-comment">// Class c = b.getClass(); // 编译错误</span><br>        <span class="hljs-type">Class</span> <span class="hljs-variable">c1</span> <span class="hljs-operator">=</span> <span class="hljs-type">boolean</span>.class;<br>        System.out.println(c1.getCanonicalName());<br><br>        <span class="hljs-type">Class</span> <span class="hljs-variable">c2</span> <span class="hljs-operator">=</span> java.io.PrintStream.class;<br>        System.out.println(c2.getCanonicalName());<br><br>        <span class="hljs-type">Class</span> <span class="hljs-variable">c3</span> <span class="hljs-operator">=</span> <span class="hljs-type">int</span>[][][].class;<br>        System.out.println(c3.getCanonicalName());<br>    &#125;<br>&#125;<br><span class="hljs-comment">//Output:</span><br><span class="hljs-comment">//boolean</span><br><span class="hljs-comment">//java.io.PrintStream</span><br><span class="hljs-comment">//int[][][]</span><br></code></pre></td></tr></table></figure><p>（3）**<code>Object</code> 的 <code>getClass</code> 方法**</p><p><code>Object</code> 类中有 <code>getClass</code> 方法，因为所有类都继承 <code>Object</code> 类。从而调用 <code>Object</code> 类来获取 <code>Class</code> 对象。</p><p>【示例】<code>Object</code> 的 <code>getClass</code> 方法获取 <code>Class</code> 对象</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> io.github.dunwu.javacore.reflect;<br><br><span class="hljs-keyword">import</span> java.util.HashSet;<br><span class="hljs-keyword">import</span> java.util.Set;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ReflectClassDemo03</span> &#123;<br>    <span class="hljs-keyword">enum</span> <span class="hljs-title class_">E</span> &#123;A, B&#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">Class</span> <span class="hljs-variable">c</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;foo&quot;</span>.getClass();<br>        System.out.println(c.getCanonicalName());<br><br>        <span class="hljs-type">Class</span> <span class="hljs-variable">c2</span> <span class="hljs-operator">=</span> ReflectClassDemo03.E.A.getClass();<br>        System.out.println(c2.getCanonicalName());<br><br>        <span class="hljs-type">byte</span>[] bytes = <span class="hljs-keyword">new</span> <span class="hljs-title class_">byte</span>[<span class="hljs-number">1024</span>];<br>        <span class="hljs-type">Class</span> <span class="hljs-variable">c3</span> <span class="hljs-operator">=</span> bytes.getClass();<br>        System.out.println(c3.getCanonicalName());<br><br>        Set&lt;String&gt; set = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashSet</span>&lt;&gt;();<br>        <span class="hljs-type">Class</span> <span class="hljs-variable">c4</span> <span class="hljs-operator">=</span> set.getClass();<br>        System.out.println(c4.getCanonicalName());<br>    &#125;<br>&#125;<br><span class="hljs-comment">//Output:</span><br><span class="hljs-comment">//java.lang.String</span><br><span class="hljs-comment">//io.github.dunwu.javacore.reflect.ReflectClassDemo.E</span><br><span class="hljs-comment">//byte[]</span><br><span class="hljs-comment">//java.util.HashSet</span><br></code></pre></td></tr></table></figure><h3 id="判断是否为某个类的实例"><a href="#判断是否为某个类的实例" class="headerlink" title="判断是否为某个类的实例"></a>判断是否为某个类的实例</h3><p>判断是否为某个类的实例有两种方式：</p><ol><li><strong>用 <code>instanceof</code> 关键字</strong></li><li><strong>用 <code>Class</code> 对象的 <code>isInstance</code> 方法</strong>（它是一个 Native 方法）</li></ol><p>【示例】</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">InstanceofDemo</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">ArrayList</span> <span class="hljs-variable">arrayList</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>();<br>        <span class="hljs-keyword">if</span> (arrayList <span class="hljs-keyword">instanceof</span> List) &#123;<br>            System.out.println(<span class="hljs-string">&quot;ArrayList is List&quot;</span>);<br>        &#125;<br>        <span class="hljs-keyword">if</span> (List.class.isInstance(arrayList)) &#123;<br>            System.out.println(<span class="hljs-string">&quot;ArrayList is List&quot;</span>);<br>        &#125;<br>    &#125;<br>&#125;<br><span class="hljs-comment">//Output:</span><br><span class="hljs-comment">//ArrayList is List</span><br><span class="hljs-comment">//ArrayList is List</span><br></code></pre></td></tr></table></figure><h3 id="创建实例"><a href="#创建实例" class="headerlink" title="创建实例"></a>创建实例</h3><p>通过反射来创建实例对象主要有两种方式：</p><ul><li>用 <code>Class</code> 对象的 <code>newInstance</code> 方法。</li><li>用 <code>Constructor</code> 对象的 <code>newInstance</code> 方法。</li></ul><p>【示例】</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">NewInstanceDemo</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span><br>        <span class="hljs-keyword">throws</span> IllegalAccessException, InstantiationException, NoSuchMethodException, InvocationTargetException &#123;<br>        Class&lt;?&gt; c1 = StringBuilder.class;<br>        <span class="hljs-type">StringBuilder</span> <span class="hljs-variable">sb</span> <span class="hljs-operator">=</span> (StringBuilder) c1.newInstance();<br>        sb.append(<span class="hljs-string">&quot;aaa&quot;</span>);<br>        System.out.println(sb.toString());<br><br>        <span class="hljs-comment">//获取String所对应的Class对象</span><br>        Class&lt;?&gt; c2 = String.class;<br>        <span class="hljs-comment">//获取String类带一个String参数的构造器</span><br>        <span class="hljs-type">Constructor</span> <span class="hljs-variable">constructor</span> <span class="hljs-operator">=</span> c2.getConstructor(String.class);<br>        <span class="hljs-comment">//根据构造器创建实例</span><br>        <span class="hljs-type">String</span> <span class="hljs-variable">str2</span> <span class="hljs-operator">=</span> (String) constructor.newInstance(<span class="hljs-string">&quot;bbb&quot;</span>);<br>        System.out.println(str2);<br>    &#125;<br>&#125;<br><span class="hljs-comment">//Output:</span><br><span class="hljs-comment">//aaa</span><br><span class="hljs-comment">//bbb</span><br></code></pre></td></tr></table></figure><h3 id="Field"><a href="#Field" class="headerlink" title="Field"></a>Field</h3><p><code>Class</code> 对象提供以下方法获取对象的成员（<code>Field</code>）：</p><ul><li><code>getFiled</code> - 根据名称获取公有的（public）类成员。</li><li><code>getDeclaredField</code> - 根据名称获取已声明的类成员。但不能得到其父类的类成员。</li><li><code>getFields</code> - 获取所有公有的（public）类成员。</li><li><code>getDeclaredFields</code> - 获取所有已声明的类成员。</li></ul><h3 id="Method"><a href="#Method" class="headerlink" title="Method"></a>Method</h3><p><code>Class</code> 对象提供以下方法获取对象的方法（<code>Method</code>）：</p><ul><li><code>getMethod</code> - 返回类或接口的特定方法。其中第一个参数为方法名称，后面的参数为方法参数对应 Class 的对象。</li><li><code>getDeclaredMethod</code> - 返回类或接口的特定声明方法。其中第一个参数为方法名称，后面的参数为方法参数对应 Class 的对象。</li><li><code>getMethods</code> - 返回类或接口的所有 public 方法，包括其父类的 public 方法。</li><li><code>getDeclaredMethods</code> - 返回类或接口声明的所有方法，包括 public、protected、默认（包）访问和 private 方法，但不包括继承的方法。</li></ul><h3 id="Constructor"><a href="#Constructor" class="headerlink" title="Constructor"></a>Constructor</h3><p><code>Class</code> 对象提供以下方法获取对象的构造方法（<code>Constructor</code>）：</p><ul><li><code>getConstructor</code> - 返回类的特定 public 构造方法。参数为方法参数对应 Class 的对象。</li><li><code>getDeclaredConstructor</code> - 返回类的特定构造方法。参数为方法参数对应 Class 的对象。</li><li><code>getConstructors</code> - 返回类的所有 public 构造方法。</li><li><code>getDeclaredConstructors</code> - 返回类的所有构造方法。</li></ul><p>获取一个 <code>Constructor</code> 对象后，可以用 <code>newInstance</code> 方法来创建类实例。</p><h3 id="绕开访问限制"><a href="#绕开访问限制" class="headerlink" title="绕开访问限制"></a>绕开访问限制</h3><p>有时候，我们需要通过反射访问私有成员、方法。可以使用 <code>Constructor/Field/Method.setAccessible(true)</code> 来绕开 Java 语言的访问限制。</p><h2 id="动态代理"><a href="#动态代理" class="headerlink" title="动态代理"></a>动态代理</h2><p>动态代理是一种方便运行时动态构建代理、动态处理代理方法调用的机制，很多场景都是利用类似机制做到的，比如用来包装 RPC 调用、面向切面的编程（AOP）。</p><p>实现动态代理的方式很多，比如 JDK 自身提供的动态代理，就是主要利用了上面提到的反射机制。还有其他的实现方式，比如利用传说中更高性能的字节码操作机制，类似 ASM、cglib（基于 ASM）、Javassist 等。</p><h3 id="静态代理"><a href="#静态代理" class="headerlink" title="静态代理"></a>静态代理</h3><p>静态代理其实就是指设计模式中的代理模式。</p><p>代理模式为其他对象提供一种代理以控制对这个对象的访问。</p><h3 id="JDK-动态代理"><a href="#JDK-动态代理" class="headerlink" title="JDK 动态代理"></a>JDK 动态代理</h3><p>为了解决静态代理的问题，就有了创建动态代理的想法：</p><p>在运行状态中，需要代理的地方，根据 Subject 和 RealSubject，动态地创建一个 Proxy，用完之后，就会销毁，这样就可以避免了 Proxy 角色的 class 在系统中冗杂的问题了。</p><p>Java 动态代理基于经典代理模式，引入了一个 <code>InvocationHandler</code>，<code>InvocationHandler</code> 负责统一管理所有的方法调用。</p><p>动态代理步骤：</p><ol><li>获取 RealSubject 上的所有接口列表；</li><li>确定要生成的代理类的类名，默认为：<code>com.sun.proxy.$ProxyXXXX</code>；</li><li>根据需要实现的接口信息，在代码中动态创建 该 Proxy 类的字节码；</li><li>将对应的字节码转换为对应的 class 对象；</li><li>创建 <code>InvocationHandler</code> 实例 handler，用来处理 <code>Proxy</code> 所有方法调用；</li><li>Proxy 的 class 对象 以创建的 handler 对象为参数，实例化一个 proxy 对象。</li></ol><p>从上面可以看出，JDK 动态代理的实现是基于实现接口的方式，使得 Proxy 和 RealSubject 具有相同的功能。</p><p>但其实还有一种思路：通过继承。即：让 Proxy 继承 RealSubject，这样二者同样具有相同的功能，Proxy 还可以通过重写 RealSubject 中的方法，来实现多态。CGLIB 就是基于这种思路设计的。</p><p>在 Java 的动态代理机制中，有两个重要的类（接口），一个是 <code>InvocationHandler</code> 接口、另一个则是 <code>Proxy</code> 类，这一个类和一个接口是实现我们动态代理所必须用到的。</p><p>JDK 动态代理特点：</p><ul><li>优点：相对于静态代理模式，不需要硬编码接口，代码复用率高。</li><li>缺点：强制要求代理类实现 <code>InvocationHandler</code> 接口。</li></ul>]]></content>
    
    
    <categories>
      
      <category>JavaSE</category>
      
    </categories>
    
    
    <tags>
      
      <tag>反射</tag>
      
      <tag>特性</tag>
      
      <tag>动态代理</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Java 泛型</title>
    <link href="/java%E6%B3%9B%E5%9E%8B.html"/>
    <url>/java%E6%B3%9B%E5%9E%8B.html</url>
    
    <content type="html"><![CDATA[<p>泛型的本质是为了<strong>参数化类型</strong>（在不创建新的类型的情况下，通过泛型指定的不同类型来控制形参具体限制的类型）。也就是说在泛型使用过程中，操作的数据类型被指定为一个参数，这种参数类型可以用在类、接口和方法中，分别被称为泛型类、泛型接口、泛型方法。</p><span id="more"></span><blockquote><p>转载：<a href="https://dunwu.github.io/javacore/pages/33a820/">深入理解 Java 泛型</a>（有改动）</p></blockquote><h2 id="为什么需要泛型"><a href="#为什么需要泛型" class="headerlink" title="为什么需要泛型"></a>为什么需要泛型</h2><p><strong>JDK5 引入了泛型机制</strong>。</p><p>为什么需要泛型呢？回答这个问题前，先让我们来看一个示例。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">NoGenericsDemo</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">List</span> <span class="hljs-variable">list</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>        list.add(<span class="hljs-string">&quot;abc&quot;</span>);<br>        list.add(<span class="hljs-number">18</span>);<br>        list.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">double</span>[] &#123;<span class="hljs-number">1.0</span>, <span class="hljs-number">2.0</span>&#125;);<br>        <span class="hljs-type">Object</span> <span class="hljs-variable">obj1</span> <span class="hljs-operator">=</span> list.get(<span class="hljs-number">0</span>);<br>        <span class="hljs-type">Object</span> <span class="hljs-variable">obj2</span> <span class="hljs-operator">=</span> list.get(<span class="hljs-number">1</span>);<br>        <span class="hljs-type">Object</span> <span class="hljs-variable">obj3</span> <span class="hljs-operator">=</span> list.get(<span class="hljs-number">2</span>);<br>        System.out.println(<span class="hljs-string">&quot;obj1 = [&quot;</span> + obj1 + <span class="hljs-string">&quot;]&quot;</span>);<br>        System.out.println(<span class="hljs-string">&quot;obj2 = [&quot;</span> + obj2 + <span class="hljs-string">&quot;]&quot;</span>);<br>        System.out.println(<span class="hljs-string">&quot;obj3 = [&quot;</span> + obj3 + <span class="hljs-string">&quot;]&quot;</span>);<br><br>        <span class="hljs-type">int</span> <span class="hljs-variable">num1</span> <span class="hljs-operator">=</span> (<span class="hljs-type">int</span>)list.get(<span class="hljs-number">0</span>);<br>        <span class="hljs-type">int</span> <span class="hljs-variable">num2</span> <span class="hljs-operator">=</span> (<span class="hljs-type">int</span>)list.get(<span class="hljs-number">1</span>);<br>        <span class="hljs-type">int</span> <span class="hljs-variable">num3</span> <span class="hljs-operator">=</span> (<span class="hljs-type">int</span>)list.get(<span class="hljs-number">2</span>);<br>        System.out.println(<span class="hljs-string">&quot;num1 = [&quot;</span> + num1 + <span class="hljs-string">&quot;]&quot;</span>);<br>        System.out.println(<span class="hljs-string">&quot;num2 = [&quot;</span> + num2 + <span class="hljs-string">&quot;]&quot;</span>);<br>        System.out.println(<span class="hljs-string">&quot;num3 = [&quot;</span> + num3 + <span class="hljs-string">&quot;]&quot;</span>);<br>    &#125;<br>&#125;<br><span class="hljs-comment">// Output:</span><br><span class="hljs-comment">// obj1 = [abc]</span><br><span class="hljs-comment">// obj2 = [18]</span><br><span class="hljs-comment">// obj3 = [[D@47089e5f]</span><br><span class="hljs-comment">// Exception in thread &quot;main&quot; java.lang.ClassCastException: java.lang.String cannot be cast to java.lang.Integer</span><br><span class="hljs-comment">// at io.github.dunwu.javacore.generics.NoGenericsDemo.main(NoGenericsDemo.java:23)</span><br></code></pre></td></tr></table></figure><p>示例说明：</p><p>在上面的示例中，<code>List</code> 容器没有指定存储数据类型，这种情况下，可以向 <code>List</code> 添加任意类型数据，编译器不会做类型检查，而是默默的将所有数据都转为 <code>Object</code>。</p><p>假设，最初我们希望向 <code>List</code> 存储的是整形数据，假设，某个家伙不小心存入了其他数据类型。当你试图从容器中取整形数据时，由于 <code>List</code> 当成 <code>Object</code> 类型来存储，你不得不使用类型强制转换。在运行时，才会发现 <code>List</code> 中数据不存储一致的问题，这就为程序运行带来了很大的风险（无形伤害最为致命）。</p><p>而泛型的出现，解决了类型安全问题。</p><p>泛型具有以下优点：</p><ul><li><strong>编译时的强类型检查</strong></li></ul><p>泛型要求在声明时指定实际数据类型，Java 编译器在编译时会对泛型代码做强类型检查，并在代码违反类型安全时发出告警。早发现，早治理，把隐患扼杀于摇篮，在编译时发现并修复错误所付出的代价远比在运行时小。</p><ul><li><strong>避免了类型转换</strong></li></ul><p>未使用泛型：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">List</span> <span class="hljs-variable">list</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>();<br>list.add(<span class="hljs-string">&quot;hello&quot;</span>);<br><span class="hljs-type">String</span> <span class="hljs-variable">s</span> <span class="hljs-operator">=</span> (String) list.get(<span class="hljs-number">0</span>);<br></code></pre></td></tr></table></figure><p>使用泛型：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java">List&lt;String&gt; list = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;String&gt;();<br>list.add(<span class="hljs-string">&quot;hello&quot;</span>);<br><span class="hljs-type">String</span> <span class="hljs-variable">s</span> <span class="hljs-operator">=</span> list.get(<span class="hljs-number">0</span>);   <span class="hljs-comment">// no cast</span><br></code></pre></td></tr></table></figure><ul><li><strong>泛型编程可以实现通用算法</strong></li></ul><p>通过使用泛型，程序员可以实现通用算法，这些算法可以处理不同类型的集合，可以自定义，并且类型安全且易于阅读。</p><h2 id="泛型类型"><a href="#泛型类型" class="headerlink" title="泛型类型"></a>泛型类型</h2><p><strong><code>泛型类型</code>是被参数化的类或接口。</strong></p><h3 id="泛型类"><a href="#泛型类" class="headerlink" title="泛型类"></a>泛型类</h3><p>泛型类的语法形式：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">name</span>&lt;T1, T2, ..., Tn&gt; &#123; <span class="hljs-comment">/* ... */</span> &#125;<br></code></pre></td></tr></table></figure><p>泛型类的声明和非泛型类的声明类似，除了在类名后面添加了类型参数声明部分。由尖括号（<code>&lt;&gt;</code>）分隔的类型参数部分跟在类名后面。它指定类型参数（也称为类型变量）T1，T2，…和 Tn。</p><p>一般将泛型中的类名称为<strong>原型</strong>，而将 <code>&lt;&gt;</code> 指定的参数称为<strong>类型参数</strong>。</p><ul><li>未应用泛型的类</li></ul><p>在泛型出现之前，如果一个类想持有一个可以为任意类型的数据，只能使用 <code>Object</code> 做类型转换。示例如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Info</span> &#123;<br><span class="hljs-keyword">private</span> Object value;<br><br><span class="hljs-keyword">public</span> Object <span class="hljs-title function_">getValue</span><span class="hljs-params">()</span> &#123;<br><span class="hljs-keyword">return</span> value;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setValue</span><span class="hljs-params">(Object value)</span> &#123;<br><span class="hljs-built_in">this</span>.value = value;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>单类型参数的泛型类</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Info</span>&lt;T&gt; &#123; <span class="hljs-comment">// T表示一个单一类型</span><br>    <span class="hljs-keyword">private</span> T value;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">Info</span><span class="hljs-params">()</span> &#123; &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">Info</span><span class="hljs-params">(T value)</span> &#123;<br>        <span class="hljs-built_in">this</span>.value = value;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> T <span class="hljs-title function_">getValue</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> value;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setValue</span><span class="hljs-params">(T value)</span> &#123;<br>        <span class="hljs-built_in">this</span>.value = value;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">toString</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;Info&#123;&quot;</span> + <span class="hljs-string">&quot;value=&quot;</span> + value + <span class="hljs-string">&#x27;&#125;&#x27;</span>;<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">GenericsClassDemo01</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        Info&lt;Integer&gt; info = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Info</span>&lt;&gt;();<br>        info.setValue(<span class="hljs-number">10</span>);<br>        System.out.println(info.getValue());<br><br>        Info&lt;String&gt; info2 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Info</span>&lt;&gt;();<br>        info2.setValue(<span class="hljs-string">&quot;xyz&quot;</span>);<br>        System.out.println(info2.getValue());<br>    &#125;<br>&#125;<br><span class="hljs-comment">// Output:</span><br><span class="hljs-comment">// 10</span><br><span class="hljs-comment">// xyz</span><br></code></pre></td></tr></table></figure><p>在上面的例子中，在初始化一个泛型类时，使用 <code>&lt;&gt;</code> 指定了内部具体类型，在编译时就会根据这个类型做强类型检查。</p><ul><li>多个类型参数的泛型类</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MyMap</span>&lt;K,V&gt; &#123;<br>    <span class="hljs-keyword">private</span> K key;<br>    <span class="hljs-keyword">private</span> V value;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">MyMap</span><span class="hljs-params">(K key, V value)</span> &#123;<br>        <span class="hljs-built_in">this</span>.key = key;<br>        <span class="hljs-built_in">this</span>.value = value;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">toString</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;MyMap&#123;&quot;</span> + <span class="hljs-string">&quot;key=&quot;</span> + key + <span class="hljs-string">&quot;, value=&quot;</span> + value + <span class="hljs-string">&#x27;&#125;&#x27;</span>;<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">GenericsClassDemo02</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        MyMap&lt;Integer, String&gt; map = <span class="hljs-keyword">new</span> <span class="hljs-title class_">MyMap</span>&lt;&gt;(<span class="hljs-number">1</span>, <span class="hljs-string">&quot;one&quot;</span>);<br>        System.out.println(map);<br>    &#125;<br>&#125;<br><span class="hljs-comment">// Output:</span><br><span class="hljs-comment">// MyMap&#123;key=1, value=one&#125;</span><br></code></pre></td></tr></table></figure><ul><li>泛型类的类型嵌套</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">GenericsClassDemo03</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        Info&lt;String&gt; info = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Info</span>(<span class="hljs-string">&quot;Hello&quot;</span>);<br>        MyMap&lt;Integer, Info&lt;String&gt;&gt; map = <span class="hljs-keyword">new</span> <span class="hljs-title class_">MyMap</span>&lt;&gt;(<span class="hljs-number">1</span>, info);<br>        System.out.println(map);<br>    &#125;<br>&#125;<br><span class="hljs-comment">// Output:</span><br><span class="hljs-comment">// MyMap&#123;key=1, value=Info&#123;value=Hello&#125;&#125;</span><br></code></pre></td></tr></table></figure><h3 id="泛型接口"><a href="#泛型接口" class="headerlink" title="泛型接口"></a>泛型接口</h3><p>接口也可以声明泛型。</p><p>泛型接口语法形式：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title">Content</span>&lt;<span class="hljs-title">T</span>&gt; &#123;<br>    <span class="hljs-function">T <span class="hljs-title">text</span>()</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>泛型接口有两种实现方式：</p><ul><li>实现接口的子类明确声明泛型类型</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">GenericsInterfaceDemo01</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Content</span>&lt;Integer&gt; &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> text;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">GenericsInterfaceDemo01</span><span class="hljs-params">(<span class="hljs-type">int</span> text)</span> &#123;<br>        <span class="hljs-built_in">this</span>.text = text;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> Integer <span class="hljs-title function_">text</span><span class="hljs-params">()</span> &#123; <span class="hljs-keyword">return</span> text; &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">GenericsInterfaceDemo01</span> <span class="hljs-variable">demo</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">GenericsInterfaceDemo01</span>(<span class="hljs-number">10</span>);<br>        System.out.print(demo.text());<br>    &#125;<br>&#125;<br><span class="hljs-comment">// Output:</span><br><span class="hljs-comment">// 10</span><br></code></pre></td></tr></table></figure><ul><li>实现接口的子类不明确声明泛型类型</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">GenericsInterfaceDemo02</span>&lt;T&gt; <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Content</span>&lt;T&gt; &#123;<br>    <span class="hljs-keyword">private</span> T text;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">GenericsInterfaceDemo02</span><span class="hljs-params">(T text)</span> &#123;<br>        <span class="hljs-built_in">this</span>.text = text;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> T <span class="hljs-title function_">text</span><span class="hljs-params">()</span> &#123; <span class="hljs-keyword">return</span> text; &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        GenericsInterfaceDemo02&lt;String&gt; gen = <span class="hljs-keyword">new</span> <span class="hljs-title class_">GenericsInterfaceDemo02</span>&lt;&gt;(<span class="hljs-string">&quot;ABC&quot;</span>);<br>        System.out.print(gen.text());<br>    &#125;<br>&#125;<br><span class="hljs-comment">// Output:</span><br><span class="hljs-comment">// ABC</span><br></code></pre></td></tr></table></figure><h2 id="泛型方法"><a href="#泛型方法" class="headerlink" title="泛型方法"></a>泛型方法</h2><p>泛型方法是引入其自己的类型参数的方法。泛型方法可以是普通方法、静态方法以及构造方法。</p><p>泛型方法语法形式如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> &lt;T&gt; T <span class="hljs-title function_">func</span><span class="hljs-params">(T obj)</span> &#123;&#125;<br></code></pre></td></tr></table></figure><p><strong>是否拥有泛型方法，与其所在的类是否是泛型没有关系。</strong></p><p>泛型方法的语法包括一个类型参数列表，在尖括号内，它出现在方法的返回类型之前。对于静态泛型方法，类型参数部分必须出现在方法的返回类型之前。类型参数能被用来声明返回值类型，并且能作为泛型方法得到的实际类型参数的占位符。</p><p><strong>使用泛型方法的时候，通常不必指明类型参数，因为编译器会为我们找出具体的类型。这称为类型参数推断（type argument inference）。类型推断只对赋值操作有效，其他时候并不起作用</strong>。如果将一个返回类型为 T 的泛型方法调用的结果作为参数，传递给另一个方法，这时编译器并不会执行推断。编译器会认为：调用泛型方法后，其返回值被赋给一个 Object 类型的变量。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">GenericsMethodDemo01</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> &lt;T&gt; <span class="hljs-keyword">void</span> <span class="hljs-title function_">printClass</span><span class="hljs-params">(T obj)</span> &#123;<br>        System.out.println(obj.getClass().toString());<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        printClass(<span class="hljs-string">&quot;abc&quot;</span>);<br>        printClass(<span class="hljs-number">10</span>);<br>    &#125;<br>&#125;<br><span class="hljs-comment">// Output:</span><br><span class="hljs-comment">// class java.lang.String</span><br><span class="hljs-comment">// class java.lang.Integer</span><br></code></pre></td></tr></table></figure><h2 id="类型擦除"><a href="#类型擦除" class="headerlink" title="类型擦除"></a>类型擦除</h2><p>Java 语言引入泛型是为了在编译时提供更严格的类型检查，并支持泛型编程。不同于 C++ 的模板机制，<strong>Java 泛型是使用类型擦除来实现的，使用泛型时，任何具体的类型信息都被擦除了</strong>。</p><p>那么，类型擦除做了什么呢？它做了以下工作：</p><ul><li>把泛型中的<strong>所有类型参数替换为 Object</strong>，如果指定类型边界，则使用类型边界来替换。因此，生成的字节码仅包含普通的类，接口和方法。</li><li>擦除出现的类型声明，即去掉 <code>&lt;&gt;</code> 的内容。比如 <code>T get()</code> 方法声明就变成了 <code>Object get()</code> ；<code>List&lt;String&gt;</code> 就变成了 <code>List</code>。如有必要，插入类型转换以保持类型安全。</li><li>生成桥接方法以保留扩展泛型类型中的多态性。<strong>类型擦除确保不为参数化类型创建新类</strong>；因此，泛型不会产生运行时开销。</li></ul><p>实例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java">ublic <span class="hljs-keyword">class</span> <span class="hljs-title class_">GenericsErasureTypeDemo</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        List&lt;Object&gt; list1 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;Object&gt;();<br>        List&lt;String&gt; list2 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;String&gt;();<br>        System.out.println(list1.getClass());<br>        System.out.println(list2.getClass());<br>    &#125;<br>&#125;<br><span class="hljs-comment">// Output:</span><br><span class="hljs-comment">// class java.util.ArrayList</span><br><span class="hljs-comment">// class java.util.ArrayList</span><br></code></pre></td></tr></table></figure><p>示例说明：</p><p>上面的例子中，虽然指定了不同的类型参数，但是 list1 和 list2 的类信息却是一样的。</p><p>这是因为：<strong>使用泛型时，任何具体的类型信息都被擦除了</strong>。这意味着：<code>ArrayList&lt;Object&gt;</code> 和 <code>ArrayList&lt;String&gt;</code> 在运行时，JVM 将它们视为同一类型。</p><h2 id="泛型和继承"><a href="#泛型和继承" class="headerlink" title="泛型和继承"></a>泛型和继承</h2><p><strong>泛型不能用于显式地引用运行时类型的操作之中，例如：转型、instanceof 操作和 new 表达式。因为所有关于参数的类型信息都丢失了</strong>。当你在编写泛型代码时，必须时刻提醒自己，你只是看起来好像拥有有关参数的类型信息而已。</p><p>正是由于泛型时基于类型擦除实现的，所以，<strong>泛型类型无法向上转型</strong>。</p><blockquote><p>向上转型是指用子类实例去初始化父类，这是面向对象中多态的重要表现。</p></blockquote><p><img src="https://cdn.jsdelivr.net/gh/gejoyy/Pictures@main/%E6%B3%9B%E5%9E%8B%E5%92%8C%E7%BB%A7%E6%89%BF.png" alt="泛型和继承"></p><p><code>Integer</code> 继承了 <code>Object</code>；<code>ArrayList</code> 继承了 <code>List</code>；但是 <code>List&lt;Interger&gt;</code> 却并非继承了 <code>List&lt;Object&gt;</code>。</p><p>这是因为，泛型类并没有自己独有的 <code>Class</code> 类对象。比如：并不存在 <code>List&lt;Object&gt;.class</code> 或是 <code>List&lt;Interger&gt;.class</code>，Java 编译器会将二者都视为 <code>List.class</code>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java">List&lt;Integer&gt; list = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>List&lt;Object&gt; list2 = list; <span class="hljs-comment">// Erorr</span><br></code></pre></td></tr></table></figure><h2 id="类型边界"><a href="#类型边界" class="headerlink" title="类型边界"></a>类型边界</h2><p>有时您可能希望限制可在参数化类型中用作类型参数的类型。**<code>类型边界</code>可以对泛型的类型参数设置限制条件**。例如，对数字进行操作的方法可能只想接受 <code>Number</code> 或其子类的实例。</p><p>要声明有界类型参数，请列出类型参数的名称，然后是 <code>extends</code> 关键字，后跟其限制类或接口。</p><p>类型边界的语法形式如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">&lt;T <span class="hljs-keyword">extends</span> <span class="hljs-title class_">XXX</span>&gt;<br></code></pre></td></tr></table></figure><p>示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">GenericsExtendsDemo01</span> &#123;<br>    <span class="hljs-keyword">static</span> &lt;T <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Comparable</span>&lt;T&gt;&gt; T <span class="hljs-title function_">max</span><span class="hljs-params">(T x, T y, T z)</span> &#123;<br>        <span class="hljs-type">T</span> <span class="hljs-variable">max</span> <span class="hljs-operator">=</span> x; <span class="hljs-comment">// 假设x是初始最大值</span><br>        <span class="hljs-keyword">if</span> (y.compareTo(max) &gt; <span class="hljs-number">0</span>) &#123;<br>            max = y; <span class="hljs-comment">//y 更大</span><br>        &#125;<br>        <span class="hljs-keyword">if</span> (z.compareTo(max) &gt; <span class="hljs-number">0</span>) &#123;<br>            max = z; <span class="hljs-comment">// 现在 z 更大</span><br>        &#125;<br>        <span class="hljs-keyword">return</span> max; <span class="hljs-comment">// 返回最大对象</span><br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        System.out.println(max(<span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>));<br>        System.out.println(max(<span class="hljs-number">6.6</span>, <span class="hljs-number">8.8</span>, <span class="hljs-number">7.7</span>));<br>        System.out.println(max(<span class="hljs-string">&quot;pear&quot;</span>, <span class="hljs-string">&quot;apple&quot;</span>, <span class="hljs-string">&quot;orange&quot;</span>));<br>    &#125;<br>&#125;<br><span class="hljs-comment">// Output:</span><br><span class="hljs-comment">// 5</span><br><span class="hljs-comment">// 8.8</span><br><span class="hljs-comment">// pear</span><br></code></pre></td></tr></table></figure><blockquote><p>示例说明：</p><p>上面的示例声明了一个泛型方法，类型参数 <code>T extends Comparable&lt;T&gt;</code> 表明传入方法中的类型必须实现了 Comparable 接口。</p></blockquote><p>类型边界可以设置多个，语法形式如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">&lt;T <span class="hljs-keyword">extends</span> <span class="hljs-title class_">B1</span> &amp; B2 &amp; B3&gt;<br></code></pre></td></tr></table></figure><blockquote><p>注意：extends 关键字后面的第一个类型参数可以是类或接口，其他类型参数只能是接口。</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">GenericsExtendsDemo02</span> &#123;<br>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">A</span> &#123; <span class="hljs-comment">/* ... */</span> &#125;<br>    <span class="hljs-keyword">interface</span> <span class="hljs-title class_">B</span> &#123; <span class="hljs-comment">/* ... */</span> &#125;<br>    <span class="hljs-keyword">interface</span> <span class="hljs-title class_">C</span> &#123; <span class="hljs-comment">/* ... */</span> &#125;<br>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">D1</span> &lt;T <span class="hljs-keyword">extends</span> <span class="hljs-title class_">A</span> &amp; B &amp; C&gt; &#123; <span class="hljs-comment">/* ... */</span> &#125;<br>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">D2</span> &lt;T <span class="hljs-keyword">extends</span> <span class="hljs-title class_">B</span> &amp; A &amp; C&gt; &#123; <span class="hljs-comment">/* ... */</span> &#125; <span class="hljs-comment">// 编译报错</span><br>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">E</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">A</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">B</span>, C &#123; <span class="hljs-comment">/* ... */</span> &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        D1&lt;E&gt; demo1 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">D1</span>&lt;&gt;();<br>        System.out.println(demo1.getClass().toString());<br>        D1&lt;String&gt; demo2 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">D1</span>&lt;&gt;(); <span class="hljs-comment">// 编译报错</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="类型通配符"><a href="#类型通配符" class="headerlink" title="类型通配符"></a>类型通配符</h2><p><code>类型通配符</code>一般是使用 <code>?</code> 代替具体的类型参数。例如 <code>List&lt;?&gt;</code> 在逻辑上是 <code>List&lt;String&gt;</code> ，<code>List&lt;Integer&gt;</code> 等所有 <code>List&lt;具体类型实参&gt;</code> 的父类。</p><p>它的语法形式为：<code>&lt;? extends Number&gt;</code></p><blockquote><p>Integer、Double、Float、Short、Long、Boolean、Byte、Character，他们都是<strong>继承 Number 类型</strong>。</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">GenericsUpperBoundedWildcardDemo</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-type">double</span> <span class="hljs-title function_">sumOfList</span><span class="hljs-params">(List&lt;? extends Number&gt; list)</span> &#123;<br>        <span class="hljs-type">double</span> <span class="hljs-variable">s</span> <span class="hljs-operator">=</span> <span class="hljs-number">0.0</span>;<br>        <span class="hljs-keyword">for</span> (Number n : list) &#123;<br>            s += n.doubleValue();<br>        &#125;<br>        <span class="hljs-keyword">return</span> s;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        List&lt;Integer&gt; li = Arrays.asList(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>);<br>        System.out.println(<span class="hljs-string">&quot;sum = &quot;</span> + sumOfList(li));<br>    &#125;<br>&#125;<br><span class="hljs-comment">// Output:</span><br><span class="hljs-comment">// sum = 6.0</span><br></code></pre></td></tr></table></figure><h3 id="下界通配符"><a href="#下界通配符" class="headerlink" title="下界通配符"></a>下界通配符</h3><p><strong><code>下界通配符</code><strong>将未知类型限制为该类型的</strong>特定类型或超类类型</strong>。</p><blockquote><p>注意：<strong>上界通配符和下界通配符不能同时使用</strong>。</p></blockquote><p>它的语法形式为：<code>&lt;? super Number&gt;</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">GenericsLowerBoundedWildcardDemo</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">addNumbers</span><span class="hljs-params">(List&lt;? <span class="hljs-built_in">super</span> Integer&gt; list)</span> &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; i &lt;= <span class="hljs-number">5</span>; i++) &#123;<br>            list.add(i);<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        List&lt;Integer&gt; list = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>        addNumbers(list);<br>        System.out.println(Arrays.deepToString(list.toArray()));<br>    &#125;<br>&#125;<br><span class="hljs-comment">// Output:</span><br><span class="hljs-comment">// [1, 2, 3, 4, 5]</span><br></code></pre></td></tr></table></figure><h3 id="无界通配符"><a href="#无界通配符" class="headerlink" title="无界通配符"></a>无界通配符</h3><p>无界通配符有两种应用场景：</p><ul><li>可以使用 Object 类中提供的功能来实现的方法。</li><li>使用不依赖于类型参数的泛型类中的方法。</li></ul><p>语法形式：<code>&lt;?&gt;</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">GenericsUnboundedWildcardDemo</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">printList</span><span class="hljs-params">(List&lt;?&gt; list)</span> &#123;<br>        <span class="hljs-keyword">for</span> (Object elem : list) &#123;<br>            System.out.print(elem + <span class="hljs-string">&quot; &quot;</span>);<br>        &#125;<br>        System.out.println();<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        List&lt;Integer&gt; li = Arrays.asList(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>);<br>        List&lt;String&gt; ls = Arrays.asList(<span class="hljs-string">&quot;one&quot;</span>, <span class="hljs-string">&quot;two&quot;</span>, <span class="hljs-string">&quot;three&quot;</span>);<br>        printList(li);<br>        printList(ls);<br>    &#125;<br>&#125;<br><span class="hljs-comment">// Output:</span><br><span class="hljs-comment">// 1 2 3</span><br><span class="hljs-comment">// one two three</span><br></code></pre></td></tr></table></figure><h2 id="泛型的约束"><a href="#泛型的约束" class="headerlink" title="泛型的约束"></a>泛型的约束</h2><ul><li><a href="https://docs.oracle.com/javase/tutorial/java/generics/restrictions.html#instantiate">泛型类型的类型参数不能是值类型</a></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">Pair&lt;<span class="hljs-type">int</span>, <span class="hljs-type">char</span>&gt; p = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Pair</span>&lt;&gt;(<span class="hljs-number">8</span>, <span class="hljs-string">&#x27;a&#x27;</span>);  <span class="hljs-comment">// 编译错误</span><br></code></pre></td></tr></table></figure><ul><li><a href="https://docs.oracle.com/javase/tutorial/java/generics/restrictions.html#createObjects">不能创建类型参数的实例</a></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> &lt;E&gt; <span class="hljs-keyword">void</span> <span class="hljs-title function_">append</span><span class="hljs-params">(List&lt;E&gt; list)</span> &#123;<br>    <span class="hljs-type">E</span> <span class="hljs-variable">elem</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">E</span>();  <span class="hljs-comment">// 编译错误</span><br>    list.add(elem);<br>&#125;<br></code></pre></td></tr></table></figure><ul><li><a href="https://docs.oracle.com/javase/tutorial/java/generics/restrictions.html#createStatic">不能声明类型为类型参数的静态成员</a></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MobileDevice</span>&lt;T&gt; &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> T os; <span class="hljs-comment">// error</span><br><br>    <span class="hljs-comment">// ...</span><br>&#125;<br></code></pre></td></tr></table></figure><ul><li><a href="https://docs.oracle.com/javase/tutorial/java/generics/restrictions.html#cannotCast">类型参数不能使用类型转换或 <code>instanceof</code></a></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> &lt;E&gt; <span class="hljs-keyword">void</span> <span class="hljs-title function_">rtti</span><span class="hljs-params">(List&lt;E&gt; list)</span> &#123;<br>    <span class="hljs-keyword">if</span> (list <span class="hljs-keyword">instanceof</span> ArrayList&lt;Integer&gt;) &#123;  <span class="hljs-comment">// 编译错误</span><br>        <span class="hljs-comment">// ...</span><br>    &#125;<br>&#125;<br>List&lt;Integer&gt; li = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>List&lt;Number&gt;  ln = (List&lt;Number&gt;) li;  <span class="hljs-comment">// 编译错误</span><br></code></pre></td></tr></table></figure><ul><li><a href="https://docs.oracle.com/javase/tutorial/java/generics/restrictions.html#createArrays">不能创建类型参数的数组</a></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">List&lt;Integer&gt;[] arrayOfLists = <span class="hljs-keyword">new</span> <span class="hljs-title class_">List</span>&lt;Integer&gt;[<span class="hljs-number">2</span>];  <span class="hljs-comment">// 编译错误</span><br></code></pre></td></tr></table></figure><ul><li><a href="https://docs.oracle.com/javase/tutorial/java/generics/restrictions.html#cannotCatch">不能创建、catch 或 throw 参数化类型对象</a></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// Extends Throwable indirectly</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">MathException</span>&lt;T&gt; <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Exception</span> &#123; <span class="hljs-comment">/* ... */</span> &#125;    <span class="hljs-comment">// 编译错误</span><br><br><span class="hljs-comment">// Extends Throwable directly</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">QueueFullException</span>&lt;T&gt; <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Throwable</span> &#123; <span class="hljs-comment">/* ... */</span> <span class="hljs-comment">// 编译错误</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> &lt;T <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Exception</span>, J&gt; <span class="hljs-keyword">void</span> <span class="hljs-title function_">execute</span><span class="hljs-params">(List&lt;J&gt; jobs)</span> &#123;<br>    <span class="hljs-keyword">try</span> &#123;<br>        <span class="hljs-keyword">for</span> (J job : jobs)<br>            <span class="hljs-comment">// ...</span><br>    &#125; <span class="hljs-keyword">catch</span> (T e) &#123;   <span class="hljs-comment">// compile-time error</span><br>        <span class="hljs-comment">// ...</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li><a href="https://docs.oracle.com/javase/tutorial/java/generics/restrictions.html#cannotOverload">仅仅是泛型类相同，而类型参数不同的方法不能重载</a></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Example</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">print</span><span class="hljs-params">(Set&lt;String&gt; strSet)</span> &#123; &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">print</span><span class="hljs-params">(Set&lt;Integer&gt; intSet)</span> &#123; &#125; <span class="hljs-comment">// 编译错误</span><br>&#125;<br></code></pre></td></tr></table></figure><h2 id="泛型最佳实践"><a href="#泛型最佳实践" class="headerlink" title="泛型最佳实践"></a>泛型最佳实践</h2><h3 id="泛型命名"><a href="#泛型命名" class="headerlink" title="泛型命名"></a>泛型命名</h3><p>泛型一些约定俗成的命名：</p><ul><li>E - Element</li><li>K - Key</li><li>N - Number</li><li>T - Type</li><li>V - Value</li><li>S,U,V etc. - 2nd, 3rd, 4th types</li></ul><h3 id="使用泛型的建议"><a href="#使用泛型的建议" class="headerlink" title="使用泛型的建议"></a>使用泛型的建议</h3><ul><li>消除类型检查告警</li><li>List 优先于数组</li><li>优先考虑使用泛型来提高代码通用性</li><li>优先考虑泛型方法来限定泛型的范围</li><li>利用有限制通配符来提升 API 的灵活性</li><li>优先考虑类型安全的异构容器</li></ul>]]></content>
    
    
    <categories>
      
      <category>JavaSE</category>
      
    </categories>
    
    
    <tags>
      
      <tag>特性</tag>
      
      <tag>泛型</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Java 异常</title>
    <link href="/java%E5%BC%82%E5%B8%B8.html"/>
    <url>/java%E5%BC%82%E5%B8%B8.html</url>
    
    <content type="html"><![CDATA[<p>Java 异常是 Java 提供的一种识别及响应错误的一致性机制，java 异常机制可以使程序中异常处理代码和正常业务代码分离，保证程序代码更加优雅，并提高程序健壮性。</p><span id="more"></span><blockquote><p>转载：<a href="https://dunwu.github.io/javacore/pages/37415c/">深入理解 Java 异常</a>（有改动）</p></blockquote><h2 id="异常框架"><a href="#异常框架" class="headerlink" title="异常框架"></a>异常框架</h2><p><strong><code>Throwable</code> 是 Java 语言中所有错误（<code>Error</code>）和异常（<code>Exception</code>）的超类。</strong>在 Java 中只有 <code>Throwable</code> 类型的实例才可以被抛出（<code>throw</code>）或者捕获（<code>catch</code>），它是异常处理机制的基本组成类型。</p><p><code>Throwable</code> 包含了其线程创建时线程执行堆栈的快照，它提供了 <code>printStackTrace()</code> 等接口用于获取堆栈跟踪数据等信息。</p><p>主要方法：</p><ul><li><code>fillInStackTrace</code> - 用当前的调用栈层次填充 <code>Throwable</code> 对象栈层次，添加到栈层次任何先前信息中。</li><li><code>getMessage</code> - 返回关于发生的异常的详细信息。这个消息在 <code>Throwable</code> 类的构造函数中初始化了。</li><li><code>getCause</code> - 返回一个 <code>Throwable</code> 对象代表异常原因。</li><li><code>getStackTrace</code> - 返回一个包含堆栈层次的数组。下标为 0 的元素代表栈顶，最后一个元素代表方法调用堆栈的栈底。</li><li><code>printStackTrace</code> - 打印 <code>toString()</code> 结果和栈层次到 <code>System.err</code>，即错误输出流。</li><li><code>toString</code> - 使用 <code>getMessage</code> 的结果返回代表 <code>Throwable</code> 对象的字符串。</li></ul><h3 id="Error"><a href="#Error" class="headerlink" title="Error"></a>Error</h3><p><code>Error</code> 是 <code>Throwable</code> 的一个子类。**<code>Error</code> 表示正常情况下，不大可能出现的严重问题<strong>。</strong>编译器不会检查 <code>Error</code>**。绝大部分的 Error 都会导致程序（比如 JVM 自身）处于非正常的、不可恢复状态。既然是非正常情况，所以不便于也不需要捕获，常见的比如 OutOfMemoryError 之类，都是 Error 的子类。</p><p>常见 <code>Error</code>：</p><ul><li><code>AssertionError</code> - 断言错误。</li><li><code>VirtualMachineError</code> - 虚拟机错误。</li><li><code>UnsupportedClassVersionError</code> - Java 类版本错误。</li><li><code>StackOverflowError</code> - 栈溢出错误。</li><li><code>OutOfMemoryError</code> - 内存溢出错误。</li></ul><h3 id="Exception"><a href="#Exception" class="headerlink" title="Exception"></a>Exception</h3><p><code>Exception</code> 是 <code>Throwable</code> 的一个子类。**<code>Exception</code> 表示合理的应用程序可能想要捕获的条件。**Exception 是程序正常运行中，可以预料的意外情况，可能并且应该被捕获，进行相应处理。</p><p>Exception 又分为可检查（checked）异常和不检查（unchecked）异常，可检查异常在源代码里必须显式地进行捕获处理，这是编译期检查的一部分。</p><p><strong>编译器会检查 <code>Exception</code> 异常。</strong>此类异常，要么通过 <code>throws</code> 进行声明抛出，要么通过 <code>try catch</code> 进行捕获处理，否则不能通过编译。</p><p>常见 <code>Exception</code>：</p><ul><li><code>ClassNotFoundException</code> - 应用程序试图加载类时，找不到相应的类，抛出该异常。</li><li><code>CloneNotSupportedException</code> - 当调用 Object 类中的 clone 方法克隆对象，但该对象的类无法实现 Cloneable 接口时，抛出该异常。</li><li><code>IllegalAccessException</code> - 拒绝访问一个类的时候，抛出该异常。</li><li><code>InstantiationException</code> - 当试图使用 Class 类中的 newInstance 方法创建一个类的实例，而指定的类对象因为是一个接口或是一个抽象类而无法实例化时，抛出该异常。</li><li><code>InterruptedException</code> - 一个线程被另一个线程中断，抛出该异常。</li><li><code>NoSuchFieldException</code> - 请求的变量不存在。</li><li><code>NoSuchMethodException</code> - 请求的方法不存在。</li></ul><h3 id="RuntimeException"><a href="#RuntimeException" class="headerlink" title="RuntimeException"></a>RuntimeException</h3><p><code>RuntimeException</code> 是 <code>Exception</code> 的一个子类。<code>RuntimeException</code> 是那些可能在 Java 虚拟机正常运行期间抛出的异常的超类。</p><p><strong>编译器不会检查 <code>RuntimeException</code> 异常。</strong>当程序中可能出现这类异常时，倘若既没有通过 <code>throws</code> 声明抛出它，也没有用 <code>try catch</code> 语句捕获它，程序还是会编译通过。</p><p>常见 <code>RuntimeException</code>：</p><ul><li><code>ArrayIndexOutOfBoundsException</code> - 用非法索引访问数组时抛出的异常。如果索引为负或大于等于数组大小，则该索引为非法索引。</li><li><code>ArrayStoreException</code> - 试图将错误类型的对象存储到一个对象数组时抛出的异常。</li><li><code>ClassCastException</code> - 当试图将对象强制转换为不是实例的子类时，抛出该异常。</li><li><code>IllegalArgumentException</code> - 抛出的异常表明向方法传递了一个不合法或不正确的参数。</li><li><code>IllegalMonitorStateException</code> - 抛出的异常表明某一线程已经试图等待对象的监视器，或者试图通知其他正在等待对象的监视器而本身没有指定监视器的线程。</li><li><code>IllegalStateException</code> - 在非法或不适当的时间调用方法时产生的信号。换句话说，即 Java 环境或 Java 应用程序没有处于请求操作所要求的适当状态下。</li><li><code>IllegalThreadStateException</code> - 线程没有处于请求操作所要求的适当状态时抛出的异常。</li><li><code>IndexOutOfBoundsException</code> - 指示某排序索引（例如对数组、字符串或向量的排序）超出范围时抛出。</li><li><code>NegativeArraySizeException</code> - 如果应用程序试图创建大小为负的数组，则抛出该异常。</li><li><code>NullPointerException</code> - 当应用程序试图在需要对象的地方使用 null 时，抛出该异常</li><li><code>NumberFormatException</code> - 当应用程序试图将字符串转换成一种数值类型，但该字符串不能转换为适当格式时，抛出该异常。</li><li><code>SecurityException</code> - 由安全管理器抛出的异常，指示存在安全侵犯。</li><li><code>StringIndexOutOfBoundsException</code> - 此异常由 String 方法抛出，指示索引或者为负，或者超出字符串的大小。</li><li><code>UnsupportedOperationException</code> - 当不支持请求的操作时，抛出该异常。</li></ul><h2 id="自定义异常"><a href="#自定义异常" class="headerlink" title="自定义异常"></a>自定义异常</h2><p><strong>自定义一个异常类，只需要继承 <code>Exception</code> 或 <code>RuntimeException</code> 即可。</strong></p><p>示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MyExceptionDemo</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">MyException</span>(<span class="hljs-string">&quot;自定义异常&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MyException</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">RuntimeException</span> &#123;<br>        <span class="hljs-keyword">public</span> <span class="hljs-title function_">MyException</span><span class="hljs-params">(String message)</span> &#123;<br>            <span class="hljs-built_in">super</span>(message);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>输出：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">Exception in thread <span class="hljs-string">&quot;main&quot;</span> io.github.dunwu.javacore.exception.MyExceptionDemo$MyException: 自定义异常<br></code></pre></td></tr></table></figure><h2 id="抛出异常"><a href="#抛出异常" class="headerlink" title="抛出异常"></a>抛出异常</h2><p>如果想在程序中明确地抛出异常，需要用到 <code>throw</code> 和 <code>throws</code> 。</p><p>如果一个方法没有捕获一个检查性异常，那么该方法必须使用 <code>throws</code> 关键字来声明。<code>throws</code> 关键字放在方法签名的尾部。</p><p><code>throw</code> 示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ThrowDemo</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">f</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RuntimeException</span>(<span class="hljs-string">&quot;抛出一个异常&quot;</span>);<br>        &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>            System.out.println(e);<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        f();<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p>输出：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">java.lang.RuntimeException: 抛出一个异常<br></code></pre></td></tr></table></figure><p>也可以使用 <code>throw</code> 关键字抛出一个异常，无论它是新实例化的还是刚捕获到的。</p><h2 id="获异常"><a href="#获异常" class="headerlink" title="获异常"></a>获异常</h2><p><strong>使用 try 和 catch 关键字可以捕获异常</strong>。try catch 代码块放在异常可能发生的地方。</p><p>它的语法形式如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">try</span> &#123;<br>    <span class="hljs-comment">// 可能会发生异常的代码块</span><br>&#125; <span class="hljs-keyword">catch</span> (Exception e1) &#123;<br>    <span class="hljs-comment">// 捕获并处理try抛出的异常类型Exception</span><br>&#125; <span class="hljs-keyword">catch</span> (Exception2 e2) &#123;<br>    <span class="hljs-comment">// 捕获并处理try抛出的异常类型Exception2</span><br>&#125; <span class="hljs-keyword">finally</span> &#123;<br>    <span class="hljs-comment">// 无论是否发生异常，都将执行的代码块</span><br>&#125;<br></code></pre></td></tr></table></figure><p>此外，JDK7 以后，<code>catch</code> 多种异常时，也可以像下面这样简化代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">try</span> &#123;<br>    <span class="hljs-comment">// 可能会发生异常的代码块</span><br>&#125; <span class="hljs-keyword">catch</span> (Exception | Exception2 e) &#123;<br>    <span class="hljs-comment">// 捕获并处理try抛出的异常类型</span><br>&#125; <span class="hljs-keyword">finally</span> &#123;<br>    <span class="hljs-comment">// 无论是否发生异常，都将执行的代码块</span><br>&#125;<br></code></pre></td></tr></table></figure><ul><li><code>try</code> - <strong><code>try</code> 语句用于监听。将要被监听的代码(可能抛出异常的代码)放在 <code>try</code> 语句块之内，当 <code>try</code> 语句块内发生异常时，异常就被抛出。</strong></li><li><code>catch</code> - <code>catch</code> 语句包含要捕获异常类型的声明。当保护代码块中发生一个异常时，<code>try</code> 后面的 <code>catch</code> 块就会被检查。</li><li><code>finally</code> - <strong><code>finally</code> 语句块总是会被执行，无论是否出现异常。</strong><code>try catch</code> 语句后不一定非要<code>finally</code> 语句。<code>finally</code> 常用于这样的场景：由于<code>finally</code> 语句块总是会被执行，所以那些在 <code>try</code> 代码块中打开的，并且必须回收的物理资源(如数据库连接、网络连接和文件)，一般会放在<code>finally</code> 语句块中释放资源。</li><li><code>try</code>、<code>catch</code>、<code>finally</code> 三个代码块中的局部变量不可共享使用。</li><li><code>catch</code> 块尝试捕获异常时，是按照 <code>catch</code> 块的声明顺序从上往下寻找的，一旦匹配，就不会再向下执行。因此，如果同一个 <code>try</code> 块下的多个 <code>catch</code> 异常类型有父子关系，应该将子类异常放在前面，父类异常放在后面。</li></ul><p>示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">TryCatchFinallyDemo</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-comment">// 此处产生了异常</span><br>            <span class="hljs-type">int</span> <span class="hljs-variable">temp</span> <span class="hljs-operator">=</span> <span class="hljs-number">10</span> / <span class="hljs-number">0</span>;<br>            System.out.println(<span class="hljs-string">&quot;两个数字相除的结果：&quot;</span> + temp);<br>            System.out.println(<span class="hljs-string">&quot;----------------------------&quot;</span>);<br>        &#125; <span class="hljs-keyword">catch</span> (ArithmeticException e) &#123;<br>            System.out.println(<span class="hljs-string">&quot;出现异常了：&quot;</span> + e);<br>        &#125; <span class="hljs-keyword">finally</span> &#123;<br>            System.out.println(<span class="hljs-string">&quot;不管是否出现异常，都执行此代码&quot;</span>);<br>        &#125;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p>运行时输出：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java">出现异常了：java.lang.ArithmeticException: / by zero<br>不管是否出现异常，都执行此代码<br></code></pre></td></tr></table></figure><h2 id="异常链"><a href="#异常链" class="headerlink" title="异常链"></a>异常链</h2><p>异常链是以一个异常对象为参数构造新的异常对象，新的异常对象将包含先前异常的信息。</p><p>通过使用异常链，我们可以提高代码的可理解性、系统的可维护性和友好性。</p><p>我们有两种方式处理异常，一是 <code>throws</code> 抛出交给上级处理，二是 <code>try…catch</code> 做具体处理。<code>try…catch</code> 的 <code>catch</code> 块我们可以不需要做任何处理，仅仅只用 throw 这个关键字将我们封装异常信息主动抛出来。然后在通过关键字 <code>throws</code> 继续抛出该方法异常。它的上层也可以做这样的处理，以此类推就会产生一条由异常构成的异常链。</p><blockquote><p><a href="https://juejin.cn/post/6844903657478029326#heading-10">深入理解 Java 异常</a></p></blockquote><h2 id="异常注意事项"><a href="#异常注意事项" class="headerlink" title="异常注意事项"></a>异常注意事项</h2><h3 id="finally-覆盖异常"><a href="#finally-覆盖异常" class="headerlink" title="finally 覆盖异常"></a>finally 覆盖异常</h3><p>Java 异常处理中 <code>finally</code> 中的 <code>return</code> 会覆盖 <code>catch</code> 代码块中的 <code>return</code> 语句和 <code>throw</code> 语句，所以 Java <strong>不建议在 <code>finally</code> 中使用 <code>return</code> 语句</strong>。</p><p>此外 <code>finally</code> 中的 <code>throw</code> 语句也会覆盖 <code>catch</code> 代码块中的 <code>return</code> 语句和 <code>throw</code> 语句。</p><p>示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">FinallyOverrideExceptionDemo</span> &#123;<br>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">f</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Exception</span>(<span class="hljs-string">&quot;A&quot;</span>);<br>        &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Exception</span>(<span class="hljs-string">&quot;B&quot;</span>);<br>        &#125; <span class="hljs-keyword">finally</span> &#123;<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Exception</span>(<span class="hljs-string">&quot;C&quot;</span>);<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>            f();<br>        &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>            System.out.println(e.getMessage());<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>输出：C</strong></p><h3 id="异常和线程"><a href="#异常和线程" class="headerlink" title="异常和线程"></a>异常和线程</h3><p>如果 Java 程序只有一个线程，那么没有被任何代码处理的异常会导致程序终止。如果 Java 程序是多线程的，那么没有被任何代码处理的异常仅仅会导致异常所在的线程结束。</p><h2 id="最佳实践"><a href="#最佳实践" class="headerlink" title="最佳实践"></a>最佳实践</h2><ul><li>对可恢复的情况使用检查性异常（Exception），对编程错误使用运行时异常（RuntimeException）。</li><li>优先使用 Java 标准的异常。</li><li>抛出与抽象相对应的异常。</li><li>在细节消息中包含能捕获失败的信息。</li><li>尽可能减少 try 代码块的大小。</li><li>尽量缩小异常范围。例如，如果明知尝试捕获的是一个 <code>ArithmeticException</code>，就应该 <code>catch</code> <code>ArithmeticException</code>，而不是 <code>catch</code> 范围较大的 <code>RuntimeException</code>，甚至是 <code>Exception</code>。</li><li>尽量不要在 <code>finally</code> 块抛出异常或者返回值。</li><li>不要忽略异常，一旦捕获异常，就应该处理，而非丢弃。</li><li>异常处理效率很低，所以不要用异常进行业务逻辑处理。</li><li>各类异常必须要有单独的日志记录，将异常分级，分类管理，因为有的时候仅仅想给第三方运维看到逻辑异常，而不是更细节的信息。</li><li>如何对异常进行分类：<ul><li>逻辑异常，这类异常用于描述业务无法按照预期的情况处理下去，属于用户制造的意外。</li><li>代码错误，这类异常用于描述开发的代码错误，例如 NPE，ILLARG，都属于程序员制造的 BUG。</li><li>专有异常，多用于特定业务场景，用于描述指定作业出现意外情况无法预先处理。</li></ul></li></ul><blockquote><p><a href="https://my.oschina.net/c5ms/blog/1827907">优雅的处理你的 Java 异常</a></p></blockquote>]]></content>
    
    
    <categories>
      
      <category>JavaSE</category>
      
    </categories>
    
    
    <tags>
      
      <tag>异常</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Java 控制语句</title>
    <link href="/java%E6%8E%A7%E5%88%B6%E8%AF%AD%E5%8F%A5.html"/>
    <url>/java%E6%8E%A7%E5%88%B6%E8%AF%AD%E5%8F%A5.html</url>
    
    <content type="html"><![CDATA[<p>Java 流程控制语句，包括if、switch、while、for等结构。</p><span id="more"></span><blockquote><p>转载：<a href="https://dunwu.github.io/javacore/pages/fb4f8c/">Java 控制语句</a>（有改动）</p></blockquote><h2 id="Java-控制语句"><a href="#Java-控制语句" class="headerlink" title="Java 控制语句"></a>Java 控制语句</h2><p>Java 控制语句大致可分为三大类：</p><ul><li>选择语句<ul><li>if, else-if, else</li><li>switch</li></ul></li><li>循环语句<ul><li>while</li><li>do…while</li><li>for</li><li>foreach</li></ul></li><li>中断语句<ul><li>break</li><li>continue</li><li>return</li></ul></li></ul><h2 id="选择语句"><a href="#选择语句" class="headerlink" title="选择语句"></a>选择语句</h2><h3 id="if-语句"><a href="#if-语句" class="headerlink" title="if 语句"></a>if 语句</h3><p><code>if</code> 语句会判断括号中的条件是否成立，如果成立则执行 <code>if</code> 语句中的代码块，否则跳过代码块继续执行。</p><h3 id="if…else-语句"><a href="#if…else-语句" class="headerlink" title="if…else 语句"></a>if…else 语句</h3><p><code>if</code> 语句后面可以跟 <code>else</code> 语句，当 <code>if</code> 语句的布尔表达式值为 <code>false</code> 时，<code>else</code> 语句块会被执行。</p><h3 id="if…else-if…else-语句"><a href="#if…else-if…else-语句" class="headerlink" title="if…else if…else 语句"></a>if…else if…else 语句</h3><ul><li><code>if</code> 语句至多有 1 个 <code>else</code> 语句，<code>else</code> 语句在所有的 <code>else if</code> 语句之后。</li><li><code>If</code> 语句可以有若干个 <code>else if</code> 语句，它们必须在 <code>else</code> 语句之前。</li><li>一旦其中一个 <code>else if</code> 语句检测为 <code>true</code>，其他的 <code>else if</code> 以及 <code>else</code> 语句都将跳过执行。</li></ul><h3 id="嵌套的-if…else-语句"><a href="#嵌套的-if…else-语句" class="headerlink" title="嵌套的 if…else 语句"></a>嵌套的 if…else 语句</h3><p>使用嵌套的 <code>if else</code> 语句是合法的。也就是说你可以在另一个 <code>if</code> 或者 <code>else if</code> 语句中使用 <code>if</code> 或者 <code>else if</code> 语句。</p><h3 id="switch-语句"><a href="#switch-语句" class="headerlink" title="switch 语句"></a>switch 语句</h3><p><code>switch</code> 语句判断一个变量与一系列值中某个值是否相等，每个值称为一个分支。</p><p><code>switch</code> 语句有如下规则：</p><ul><li><code>switch</code> 语句中的变量类型只能为 <code>byte</code>、<code>short</code>、<code>int</code>、<code>char</code> 或者 <code>String</code>。</li><li><code>switch</code> 语句可以拥有多个 <code>case</code> 语句。每个 <code>case</code> 后面跟一个要比较的值和冒号。</li><li><code>case</code> 语句中的值的数据类型必须与变量的数据类型相同，而且只能是常量或者字面常量。</li><li>当变量的值与 <code>case</code> 语句的值相等时，那么 <code>case</code> 语句之后的语句开始执行，直到 <code>break</code> 语句出现才会跳出 <code>switch</code> 语句。</li><li>当遇到 <code>break</code> 语句时，<code>switch</code> 语句终止。程序跳转到 <code>switch</code> 语句后面的语句执行。<code>case</code> 语句不必须要包含 <code>break</code> 语句。如果没有 <code>break</code> 语句出现，程序会继续执行下一条 <code>case</code> 语句，直到出现 <code>break</code> 语句。</li><li><code>switch</code> 语句可以包含一个 <code>default</code> 分支，该分支必须是 <code>switch</code> 语句的最后一个分支。<code>default</code> 在没有 <code>case</code> 语句的值和变量值相等的时候执行。<code>default</code> 分支不需要 <code>break</code> 语句。</li></ul><p><strong>语法</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">switch</span>(expression)&#123;<br>    <span class="hljs-keyword">case</span> value :<br>       <span class="hljs-comment">//语句</span><br>       <span class="hljs-keyword">break</span>; <span class="hljs-comment">//可选</span><br>    <span class="hljs-keyword">case</span> value :<br>       <span class="hljs-comment">//语句</span><br>       <span class="hljs-keyword">break</span>; <span class="hljs-comment">//可选</span><br>    <span class="hljs-comment">//你可以有任意数量的case语句</span><br>    <span class="hljs-keyword">default</span> : <span class="hljs-comment">//可选</span><br>       <span class="hljs-comment">//语句</span><br>       <span class="hljs-keyword">break</span>; <span class="hljs-comment">//可选，但一般建议加上</span><br>&#125;<br></code></pre></td></tr></table></figure><h2 id="循环语句"><a href="#循环语句" class="headerlink" title="循环语句"></a>循环语句</h2><h3 id="while-循环"><a href="#while-循环" class="headerlink" title="while 循环"></a>while 循环</h3><p>只要布尔表达式为 <code>true</code>，<code>while</code> 循环体会一直执行下去。</p><h3 id="do-while-循环"><a href="#do-while-循环" class="headerlink" title="do while 循环"></a>do while 循环</h3><p>对于 <code>while</code> 语句而言，如果不满足条件，则不能进入循环。但有时候我们需要即使不满足条件，也至少执行一次。</p><p><code>do while</code> 循环和 <code>while</code> 循环相似，不同的是，<code>do while</code> 循环至少会执行一次。</p><h3 id="for-循环"><a href="#for-循环" class="headerlink" title="for 循环"></a>for 循环</h3><p>虽然所有循环结构都可以用 <code>while</code> 或者 <code>do while</code> 表示，但 Java 提供了另一种语句 —— <code>for</code> 循环，使一些循环结构变得更加简单。 <code>for</code> 循环执行的次数是在执行前就确定的。</p><h3 id="foreach-循环"><a href="#foreach-循环" class="headerlink" title="foreach 循环"></a>foreach 循环</h3><p>Java5 引入了一种主要用于数组的增强型 for 循环。</p><p><strong>语法</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">for</span> (声明语句 : 表达式) &#123;<br>    <span class="hljs-comment">//代码句子</span><br>&#125;<br></code></pre></td></tr></table></figure><p><strong>声明语句</strong>：声明新的局部变量，该变量的类型必须和数组元素的类型匹配。其作用域限定在循环语句块，其值与此时数组元素的值相等。</p><p><strong>表达式</strong>：表达式是要访问的数组名，或者是返回值为数组的方法。</p><h2 id="中断语句"><a href="#中断语句" class="headerlink" title="中断语句"></a>中断语句</h2><h3 id="break-关键字"><a href="#break-关键字" class="headerlink" title="break 关键字"></a>break 关键字</h3><p><code>break</code> 主要用在循环语句或者 <code>switch</code> 语句中，用来跳出整个语句块。</p><p><code>break</code> 跳出最里层的循环，并且继续执行该循环下面的语句。</p><h3 id="continue-关键字"><a href="#continue-关键字" class="headerlink" title="continue 关键字"></a>continue 关键字</h3><p><code>continue</code> 适用于任何循环控制结构中。作用是让程序立刻跳转到下一次循环的迭代。在 <code>for</code> 循环中，<code>continue</code> 语句使程序立即跳转到更新语句。在 <code>while</code> 或者 <code>do while</code> 循环中，程序立即跳转到布尔表达式的判断语句。</p><h3 id="return-关键字"><a href="#return-关键字" class="headerlink" title="return 关键字"></a>return 关键字</h3><p>跳出整个函数体，函数体后面的部分不再执行。</p><h2 id="最佳实践"><a href="#最佳实践" class="headerlink" title="最佳实践"></a>最佳实践</h2><ul><li>选择分支特别多的情况下，<code>switch</code> 语句优于 <code>if...else if...else</code> 语句。</li><li><code>switch</code> 语句不要吝啬使用 <code>default</code>。</li><li><code>switch</code> 语句中的 <code>default</code> 要放在最后。</li><li><code>foreach</code> 循环优先于传统的 <code>for</code> 循环</li><li>不要循环遍历容器元素，然后删除特定元素。正确姿势应该是遍历容器的迭代器（<code>Iterator</code>），删除元素。</li></ul><blockquote><p><a href="https://book.douban.com/subject/2130190/">Java 编程思想</a></p></blockquote>]]></content>
    
    
    <categories>
      
      <category>JavaSE</category>
      
    </categories>
    
    
    <tags>
      
      <tag>基础</tag>
      
      <tag>关键字</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Java 枚举</title>
    <link href="/java%E6%9E%9A%E4%B8%BE.html"/>
    <url>/java%E6%9E%9A%E4%B8%BE.html</url>
    
    <content type="html"><![CDATA[<p>Java 枚举，也称作 Java 枚举类型，是一种字段由一组固定常量集合组成的类型。枚举的主要目的是加强编译时类型的安全性。enum 关键字是 Java 中的保留关键字。</p><span id="more"></span><blockquote><p>转载：<a href="https://dunwu.github.io/javacore/pages/979887/">深入理解 Java 枚举</a>（有改动）</p></blockquote><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p><code>enum</code> 的全称为 enumeration， 是 JDK5 中引入的特性。</p><p>在 Java 中，被 <code>enum</code> 关键字修饰的类型就是枚举类型。形式如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">enum</span> <span class="hljs-title class_">ColorEn</span> &#123; RED, GREEN, BLUE &#125;<br></code></pre></td></tr></table></figure><p><strong>枚举的好处</strong>：可以将常量组织起来，统一进行管理。</p><p><strong>枚举的典型应用场景</strong>：错误码、状态机等。</p><h2 id="枚举的本质"><a href="#枚举的本质" class="headerlink" title="枚举的本质"></a>枚举的本质</h2><p><strong>枚举的本质是 <code>java.lang.Enum</code> 的子类。</strong></p><p>尽管 <code>enum</code> 看起来像是一种新的数据类型，事实上，<strong>enum 是一种受限制的类，并且具有自己的方法</strong>。枚举这种特殊的类因为被修饰为 <code>final</code>，所以不能继承其他类。</p><p>定义的枚举值，会被默认修饰为 <code>public static final</code> ，从修饰关键字，即可看出枚举值本质上是静态常量。</p><blockquote><p><a href="https://www.cnblogs.com/ziph/p/13068923.html">深入理解 Java 枚举</a></p></blockquote><h2 id="枚举的方法"><a href="#枚举的方法" class="headerlink" title="枚举的方法"></a>枚举的方法</h2><p>在 enum 中，提供了一些基本方法：</p><ul><li><code>values()</code>：返回 enum 实例的数组，而且该数组中的元素严格保持在 enum 中声明时的顺序。</li><li><code>name()</code>：返回实例名。</li><li><code>ordinal()</code>：返回实例声明时的次序，从 0 开始。</li><li><code>getDeclaringClass()</code>：返回实例所属的 enum 类型。</li><li><code>equals()</code> ：判断是否为同一个对象。</li></ul><p>可以使用 <code>==</code> 来比较<code>enum</code>实例。</p><p>此外，<code>java.lang.Enum</code>实现了<code>Comparable</code>和 <code>Serializable</code> 接口，所以也提供 <code>compareTo()</code> 方法。</p><p><strong>例：展示 enum 的基本方法</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">EnumMethodDemo</span> &#123;<br>    <span class="hljs-keyword">enum</span> <span class="hljs-title class_">Color</span> &#123;RED, GREEN, BLUE;&#125;<br>    <span class="hljs-keyword">enum</span> <span class="hljs-title class_">Size</span> &#123;BIG, MIDDLE, SMALL;&#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String args[])</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;=========== Print all Color ===========&quot;</span>);<br>        <span class="hljs-keyword">for</span> (Color c : Color.values()) &#123;<br>            System.out.println(c + <span class="hljs-string">&quot; ordinal: &quot;</span> + c.ordinal());<br>        &#125;<br>        System.out.println(<span class="hljs-string">&quot;=========== Print all Size ===========&quot;</span>);<br>        <span class="hljs-keyword">for</span> (Size s : Size.values()) &#123;<br>            System.out.println(s + <span class="hljs-string">&quot; ordinal: &quot;</span> + s.ordinal());<br>        &#125;<br><br>        <span class="hljs-type">Color</span> <span class="hljs-variable">green</span> <span class="hljs-operator">=</span> Color.GREEN;<br>        System.out.println(<span class="hljs-string">&quot;green name(): &quot;</span> + green.name());<br>        System.out.println(<span class="hljs-string">&quot;green getDeclaringClass(): &quot;</span> + green.getDeclaringClass());<br>        System.out.println(<span class="hljs-string">&quot;green hashCode(): &quot;</span> + green.hashCode());<br>        System.out.println(<span class="hljs-string">&quot;green compareTo Color.GREEN: &quot;</span> + green.compareTo(Color.GREEN));<br>        System.out.println(<span class="hljs-string">&quot;green equals Color.GREEN: &quot;</span> + green.equals(Color.GREEN));<br>        System.out.println(<span class="hljs-string">&quot;green equals Size.MIDDLE: &quot;</span> + green.equals(Size.MIDDLE));<br>        System.out.println(<span class="hljs-string">&quot;green equals 1: &quot;</span> + green.equals(<span class="hljs-number">1</span>));<br>        System.out.format(<span class="hljs-string">&quot;green == Color.BLUE: %b\n&quot;</span>, green == Color.BLUE);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>输出</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java">=========== Print all Color ===========<br>RED ordinal: <span class="hljs-number">0</span><br>GREEN ordinal: <span class="hljs-number">1</span><br>BLUE ordinal: <span class="hljs-number">2</span><br>=========== Print all Size ===========<br>BIG ordinal: <span class="hljs-number">0</span><br>MIDDLE ordinal: <span class="hljs-number">1</span><br>SMALL ordinal: <span class="hljs-number">2</span><br>green <span class="hljs-title function_">name</span><span class="hljs-params">()</span>: GREEN<br>green <span class="hljs-title function_">getDeclaringClass</span><span class="hljs-params">()</span>: <span class="hljs-keyword">class</span> <span class="hljs-title class_">org</span>.zp.javase.enumeration.EnumDemo$Color<br>green <span class="hljs-title function_">hashCode</span><span class="hljs-params">()</span>: <span class="hljs-number">460141958</span><br>green compareTo Color.GREEN: <span class="hljs-number">0</span><br>green equals Color.GREEN: <span class="hljs-literal">true</span><br>green equals Size.MIDDLE: <span class="hljs-literal">false</span><br>green equals <span class="hljs-number">1</span>: <span class="hljs-literal">false</span><br>green == Color.BLUE: <span class="hljs-literal">false</span><br></code></pre></td></tr></table></figure><h2 id="枚举的特性"><a href="#枚举的特性" class="headerlink" title="枚举的特性"></a>枚举的特性</h2><p>枚举的特性，归结起来就是一句话：</p><blockquote><p><strong>除了不能继承，基本上可以将 <code>enum</code> 看做一个常规的类</strong>。</p></blockquote><h3 id="基本特性"><a href="#基本特性" class="headerlink" title="基本特性"></a>基本特性</h3><p><strong>如果枚举中没有定义方法，也可以在最后一个实例后面加逗号、分号或什么都不加。</strong></p><p>如果枚举中没有定义方法，<strong>枚举值默认为从 0 开始的有序数值</strong>。以 Color 枚举类型举例，它的枚举常量依次为 <code>RED：0，GREEN：1，BLUE：2</code>。</p><h3 id="枚举可以添加方法"><a href="#枚举可以添加方法" class="headerlink" title="枚举可以添加方法"></a>枚举可以添加方法</h3><p>前面提到，<strong>枚举值默认为从 0 开始的有序数值</strong> 。那么问题来了：如何为枚举显式的赋值。</p><ul><li><strong>Java 不允许使用 <code>=</code> 为枚举常量赋值（区别 c++）。</strong></li><li><strong>枚举可以添加普通方法、静态方法、抽象方法、构造方法。</strong></li></ul><p>Java 虽然不能直接为实例赋值，但是它有更优秀的解决方案：<strong>为 enum 添加方法来间接实现显式赋值</strong>。</p><p>创建 <code>enum</code> 时，可以为其添加多种方法，甚至可以为其添加构造方法。</p><p><strong>注意一个细节：如果要为 enum 定义方法，那么必须在 enum 的最后一个实例尾部添加一个分号。此外，在 enum 中，必须先定义实例，不能将字段或方法定义在实例前面。否则，编译器会报错。</strong></p><p>例：全面展示如何在枚举中定义普通方法、静态方法、抽象方法、构造方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">enum</span> <span class="hljs-title class_">ErrorCodeEn</span> &#123;<br>    OK(<span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-meta">@Override</span><br>        <span class="hljs-keyword">public</span> String <span class="hljs-title function_">getDescription</span><span class="hljs-params">()</span> &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;成功&quot;</span>;<br>        &#125;<br>    &#125;,<br>    ERROR_A(<span class="hljs-number">100</span>) &#123;<br>        <span class="hljs-meta">@Override</span><br>        <span class="hljs-keyword">public</span> String <span class="hljs-title function_">getDescription</span><span class="hljs-params">()</span> &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;错误A&quot;</span>;<br>        &#125;<br>    &#125;,<br>    ERROR_B(<span class="hljs-number">200</span>) &#123;<br>        <span class="hljs-meta">@Override</span><br>        <span class="hljs-keyword">public</span> String <span class="hljs-title function_">getDescription</span><span class="hljs-params">()</span> &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;错误B&quot;</span>;<br>        &#125;<br>    &#125;;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> code;<br><br>    <span class="hljs-comment">// 构造方法：enum的构造方法只能被声明为private权限或不声明权限</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-title function_">ErrorCodeEn</span><span class="hljs-params">(<span class="hljs-type">int</span> number)</span> &#123; <span class="hljs-comment">// 构造方法</span><br>        <span class="hljs-built_in">this</span>.code = number;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">getCode</span><span class="hljs-params">()</span> &#123; <span class="hljs-comment">// 普通方法</span><br>        <span class="hljs-keyword">return</span> code;<br>    &#125; <span class="hljs-comment">// 普通方法</span><br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> String <span class="hljs-title function_">getDescription</span><span class="hljs-params">()</span>; <span class="hljs-comment">// 抽象方法</span><br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String args[])</span> &#123; <span class="hljs-comment">// 静态方法</span><br>        <span class="hljs-keyword">for</span> (ErrorCodeEn s : ErrorCodeEn.values()) &#123;<br>            System.out.println(<span class="hljs-string">&quot;code: &quot;</span> + s.getCode() + <span class="hljs-string">&quot;, description: &quot;</span> + s.getDescription());<br>        &#125;<br>    &#125;<br>&#125;<br><span class="hljs-comment">// Output:</span><br><span class="hljs-comment">// code: 0, description: 成功</span><br><span class="hljs-comment">// code: 100, description: 错误A</span><br><span class="hljs-comment">// code: 200, description: 错误B</span><br></code></pre></td></tr></table></figure><h3 id="枚举可以实现接口"><a href="#枚举可以实现接口" class="headerlink" title="枚举可以实现接口"></a>枚举可以实现接口</h3><p><strong><code>enum</code> 可以像一般类一样实现接口。</strong></p><p>同样是实现上面中的错误码枚举类，通过实现接口，可以约束它的方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">INumberEnum</span> &#123;<br>    <span class="hljs-type">int</span> <span class="hljs-title function_">getCode</span><span class="hljs-params">()</span>;<br>    String <span class="hljs-title function_">getDescription</span><span class="hljs-params">()</span>;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">enum</span> <span class="hljs-title class_">ErrorCodeEn2</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">INumberEnum</span> &#123;<br>    OK(<span class="hljs-number">0</span>, <span class="hljs-string">&quot;成功&quot;</span>),<br>    ERROR_A(<span class="hljs-number">100</span>, <span class="hljs-string">&quot;错误A&quot;</span>),<br>    ERROR_B(<span class="hljs-number">200</span>, <span class="hljs-string">&quot;错误B&quot;</span>);<br><br>    ErrorCodeEn2(<span class="hljs-type">int</span> number, String description) &#123;<br>        <span class="hljs-built_in">this</span>.code = number;<br>        <span class="hljs-built_in">this</span>.description = description;<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> code;<br>    <span class="hljs-keyword">private</span> String description;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">getCode</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> code;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">getDescription</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> description;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="枚举不可以继承"><a href="#枚举不可以继承" class="headerlink" title="枚举不可以继承"></a>枚举不可以继承</h3><p><strong>enum 不可以继承另外一个类，当然，也不能继承另一个 enum 。</strong></p><p>因为 <code>enum</code> 实际上都继承自 <code>java.lang.Enum</code> 类，而 Java 不支持多重继承，所以 <code>enum</code> 不能再继承其他类，当然也不能继承另一个 <code>enum</code>。</p><h2 id="枚举的应用"><a href="#枚举的应用" class="headerlink" title="枚举的应用"></a>枚举的应用</h2><p>下面三种声明方式是等价的：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">enum</span> <span class="hljs-title class_">Color</span> &#123; RED, GREEN, BLUE &#125;<br><span class="hljs-keyword">enum</span> <span class="hljs-title class_">Color</span> &#123; RED, GREEN, BLUE, &#125;<br><span class="hljs-keyword">enum</span> <span class="hljs-title class_">Color</span> &#123; RED, GREEN, BLUE; &#125;<br></code></pre></td></tr></table></figure><h3 id="switch-状态机"><a href="#switch-状态机" class="headerlink" title="switch 状态机"></a>switch 状态机</h3><p>我们经常使用 switch 语句来写状态机。JDK7 以后，switch 已经支持 <code>int</code>、<code>char</code>、<code>String</code>、<code>enum</code> 类型的参数。这几种类型的参数比较起来，使用枚举的 switch 代码更具有可读性。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">StateMachineDemo</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">enum</span> <span class="hljs-title class_">Signal</span> &#123;<br>        GREEN, YELLOW, RED<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> String <span class="hljs-title function_">getTrafficInstruct</span><span class="hljs-params">(Signal signal)</span> &#123;<br>        <span class="hljs-type">String</span> <span class="hljs-variable">instruct</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;信号灯故障&quot;</span>;<br>        <span class="hljs-keyword">switch</span> (signal) &#123;<br>            <span class="hljs-keyword">case</span> RED:<br>                instruct = <span class="hljs-string">&quot;红灯停&quot;</span>;<br>                <span class="hljs-keyword">break</span>;<br>            <span class="hljs-keyword">case</span> YELLOW:<br>                instruct = <span class="hljs-string">&quot;黄灯请注意&quot;</span>;<br>                <span class="hljs-keyword">break</span>;<br>            <span class="hljs-keyword">case</span> GREEN:<br>                instruct = <span class="hljs-string">&quot;绿灯行&quot;</span>;<br>                <span class="hljs-keyword">break</span>;<br>            <span class="hljs-keyword">default</span>:<br>                <span class="hljs-keyword">break</span>;<br>        &#125;<br>        <span class="hljs-keyword">return</span> instruct;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        System.out.println(getTrafficInstruct(Signal.RED));<br>    &#125;<br>&#125;<br><span class="hljs-comment">// Output:</span><br><span class="hljs-comment">// 红灯停</span><br></code></pre></td></tr></table></figure><h3 id="错误码"><a href="#错误码" class="headerlink" title="错误码"></a>错误码</h3><p>枚举常被用于定义程序错误码。下面是一个简单示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ErrorCodeEnumDemo</span> &#123;<br>    <span class="hljs-keyword">enum</span> <span class="hljs-title class_">ErrorCodeEn</span> &#123;<br>        OK(<span class="hljs-number">0</span>, <span class="hljs-string">&quot;成功&quot;</span>),<br>        ERROR_A(<span class="hljs-number">100</span>, <span class="hljs-string">&quot;错误A&quot;</span>),<br>        ERROR_B(<span class="hljs-number">200</span>, <span class="hljs-string">&quot;错误B&quot;</span>);<br><br>        ErrorCodeEn(<span class="hljs-type">int</span> number, String msg) &#123;<br>            <span class="hljs-built_in">this</span>.code = number;<br>            <span class="hljs-built_in">this</span>.msg = msg;<br>        &#125;<br><br>        <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> code;<br>        <span class="hljs-keyword">private</span> String msg;<br><br>        <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">getCode</span><span class="hljs-params">()</span> &#123;<br>            <span class="hljs-keyword">return</span> code;<br>        &#125;<br><br>        <span class="hljs-keyword">public</span> String <span class="hljs-title function_">getMsg</span><span class="hljs-params">()</span> &#123;<br>            <span class="hljs-keyword">return</span> msg;<br>        &#125;<br><br>        <span class="hljs-meta">@Override</span><br>        <span class="hljs-keyword">public</span> String <span class="hljs-title function_">toString</span><span class="hljs-params">()</span> &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;ErrorCodeEn&#123;&quot;</span> + <span class="hljs-string">&quot;code=&quot;</span> + code + <span class="hljs-string">&quot;, msg=&#x27;&quot;</span> + msg + <span class="hljs-string">&#x27;\&#x27;&#x27;</span> + <span class="hljs-string">&#x27;&#125;&#x27;</span>;<br>        &#125;<br><br>        <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> String <span class="hljs-title function_">toStringAll</span><span class="hljs-params">()</span> &#123;<br>            <span class="hljs-type">StringBuilder</span> <span class="hljs-variable">sb</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">StringBuilder</span>();<br>            sb.append(<span class="hljs-string">&quot;ErrorCodeEn All Elements: [&quot;</span>);<br>            <span class="hljs-keyword">for</span> (ErrorCodeEn code : ErrorCodeEn.values()) &#123;<br>                sb.append(code.getCode()).append(<span class="hljs-string">&quot;, &quot;</span>);<br>            &#125;<br>            sb.append(<span class="hljs-string">&quot;]&quot;</span>);<br>            <span class="hljs-keyword">return</span> sb.toString();<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        System.out.println(ErrorCodeEn.toStringAll());<br>        <span class="hljs-keyword">for</span> (ErrorCodeEn s : ErrorCodeEn.values()) &#123;<br>            System.out.println(s);<br>        &#125;<br>    &#125;<br>&#125;<br><span class="hljs-comment">// Output:</span><br><span class="hljs-comment">// ErrorCodeEn All Elements: [0, 100, 200, ]</span><br><span class="hljs-comment">// ErrorCodeEn&#123;code=0, msg=&#x27;成功&#x27;&#125;</span><br><span class="hljs-comment">// ErrorCodeEn&#123;code=100, msg=&#x27;错误A&#x27;&#125;</span><br><span class="hljs-comment">// ErrorCodeEn&#123;code=200, msg=&#x27;错误B&#x27;&#125;</span><br></code></pre></td></tr></table></figure><h2 id="枚举工具类"><a href="#枚举工具类" class="headerlink" title="枚举工具类"></a>枚举工具类</h2><p>Java 中提供了两个方便操作 enum 的工具类——<code>EnumSet</code> 和 <code>EnumMap</code>。</p><p>主要接口：</p><ul><li><code>noneOf</code> - 创建一个具有指定元素类型的空 EnumSet</li><li><code>allOf</code> - 创建一个指定元素类型并包含所有枚举值的 EnumSet</li><li><code>range</code> - 创建一个包括枚举值中指定范围元素的 EnumSet</li><li><code>complementOf</code> - 初始集合包括指定集合的补集</li><li><code>of</code> - 创建一个包括参数中所有元素的 EnumSet</li><li><code>copyOf</code> - 创建一个包含参数容器中的所有元素的 EnumSet</li></ul><p>示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">EnumSetDemo</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;EnumSet展示&quot;</span>);<br>        EnumSet&lt;ErrorCodeEn&gt; errSet = EnumSet.allOf(ErrorCodeEn.class);<br>        <span class="hljs-keyword">for</span> (ErrorCodeEn e : errSet) &#123;<br>            System.out.println(e.name() + <span class="hljs-string">&quot; : &quot;</span> + e.ordinal());<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="EnumMap"><a href="#EnumMap" class="headerlink" title="EnumMap"></a>EnumMap</h3><p><code>EnumMap</code> 是专门为枚举类型量身定做的 <code>Map</code> 实现。虽然使用其它的 Map 实现（如 HashMap）也能完成枚举类型实例到值得映射，但是使用 EnumMap 会更加高效：它只能接收同一枚举类型的实例作为键值，并且由于枚举类型实例的数量相对固定并且有限，所以 EnumMap 使用数组来存放与枚举类型对应的值。这使得 EnumMap 的效率非常高。</p><p>主要接口：</p><ul><li><code>size</code> - 返回键值对数</li><li><code>containsValue</code> - 是否存在指定的 value</li><li><code>containsKey</code> - 是否存在指定的 key</li><li><code>get</code> - 根据指定 key 获取 value</li><li><code>put</code> - 取出指定的键值对</li><li><code>remove</code> - 删除指定 key</li><li><code>putAll</code> - 批量取出键值对</li><li><code>clear</code> - 清除数据</li><li><code>keySet</code> - 获取 key 集合</li><li><code>values</code> - 返回所有</li></ul><p>示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">EnumMapDemo</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">enum</span> <span class="hljs-title class_">Signal</span> &#123;<br>        GREEN, YELLOW, RED<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;EnumMap展示&quot;</span>);<br>        EnumMap&lt;Signal, String&gt; errMap = <span class="hljs-keyword">new</span> <span class="hljs-title class_">EnumMap</span>(Signal.class);<br>        errMap.put(Signal.RED, <span class="hljs-string">&quot;红灯&quot;</span>);<br>        errMap.put(Signal.YELLOW, <span class="hljs-string">&quot;黄灯&quot;</span>);<br>        errMap.put(Signal.GREEN, <span class="hljs-string">&quot;绿灯&quot;</span>);<br>        <span class="hljs-keyword">for</span> (Iterator&lt;Map.Entry&lt;Signal, String&gt;&gt; iter = errMap.entrySet().iterator(); iter.hasNext();) &#123;<br>            Map.Entry&lt;Signal, String&gt; entry = iter.next();<br>            System.out.println(entry.getKey().name() + <span class="hljs-string">&quot; : &quot;</span> + entry.getValue());<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p><a href="https://blog.csdn.net/javazejian/article/details/71333103#enumset%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86%E5%89%96%E6%9E%90">深入理解 Java 枚举类型(enum)</a></p></blockquote>]]></content>
    
    
    <categories>
      
      <category>JavaSE</category>
      
    </categories>
    
    
    <tags>
      
      <tag>基础</tag>
      
      <tag>枚举</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Java 数组</title>
    <link href="/java%E6%95%B0%E7%BB%84.html"/>
    <url>/java%E6%95%B0%E7%BB%84.html</url>
    
    <content type="html"><![CDATA[<p>数组对于每一门编程语言来说都是重要的数据结构之一，当然不同语言对数组的实现及处理也不尽相同，几乎所有程序设计语言都支持数组。</p><span id="more"></span><blockquote><p>转载：<a href="https://dunwu.github.io/javacore/pages/155518/">深入理解 Java 数组</a>（有改动）</p></blockquote><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>数组代表一系列对象或者基本数据类型，所有相同的类型都封装到一起，采用一个统一的标识符名称。</p><p><strong>数组的定义和使用需要通过方括号 <code>[]</code>。</strong></p><blockquote><p><strong>Java 中，数组是一种引用类型。</strong></p><p><strong>Java 中，数组是用来存储固定大小的同类型元素。</strong></p></blockquote><h3 id="数组和容器"><a href="#数组和容器" class="headerlink" title="数组和容器"></a>数组和容器</h3><p>Java 中，既然有了强大的容器，是不是就不需要数组了？</p><p>不是，数组也有其优势：</p><ul><li><p>Java 中，数组是一种效率最高的存储和随机访问对象引用序列的方式。<strong>数组的效率要高于容器</strong>（如 <code>ArrayList</code>）。</p></li><li><p><strong>数组可以持有值类型，而容器则不能</strong>（这时，就必须用到包装类）。</p></li></ul><h3 id="Java-数组的本质是对象"><a href="#Java-数组的本质是对象" class="headerlink" title="Java 数组的本质是对象"></a>Java 数组的本质是对象</h3><p>实例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">int</span>[] arr = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[<span class="hljs-number">3</span>];<br><span class="hljs-type">int</span> <span class="hljs-variable">size</span> <span class="hljs-operator">=</span> arr.length; #得到数组长度<br></code></pre></td></tr></table></figure><p>数组居然存在 length 这个属性，这很明显是对象才具有的特性。同时，数组也排除于 8 大基本数组类型之外，《java 核心卷一》中对数组的定义是：一个数据容器，用来存储相同数据类型的数据集合。</p><p>相应解释：</p><p><strong>Java 数组的本质是对象</strong>。它具有 Java 中其他对象的一些基本特点：封装了一些数据，可以访问属性，也可以调用方法。所以，数组是对象。</p><p><strong>如果有两个类 A 和 B，如果 B 继承（extends）了 A，那么 A[] 类型的引用就可以指向 B[] 类型的对象。</strong></p><h3 id="Java-数组和内存"><a href="#Java-数组和内存" class="headerlink" title="Java 数组和内存"></a>Java 数组和内存</h3><p>Java 数组在内存中的存储是这样的：</p><ul><li><p>数组对象（这里可以看成一个指针）存储在栈中。</p></li><li><p>数组元素存储在堆中。</p></li></ul><p>如下图所示：只有当 JVM 执行 <code>new String[]</code> 时，才会在堆中开辟相应的内存区域。数组对象 array 可以视为一个指针，指向这块内存的存储地址。</p><img src="https://cdn.jsdelivr.net/gh/gejoyy/Pictures@main/java%E6%95%B0%E7%BB%84%E5%92%8C%E5%86%85%E5%AD%98.png" alt="java数组和内存" style="zoom:60%;" /><h2 id="声明数组"><a href="#声明数组" class="headerlink" title="声明数组"></a>声明数组</h2><p>声明数组变量的语法如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">int</span>[] arr1; <span class="hljs-comment">// 推荐风格</span><br><span class="hljs-type">int</span> arr2[]; <span class="hljs-comment">// 效果相同</span><br></code></pre></td></tr></table></figure><h2 id="创建数组"><a href="#创建数组" class="headerlink" title="创建数组"></a>创建数组</h2><p>Java 语言使用 <code>new</code> 操作符来创建数组。有两种创建数组方式：</p><ul><li>指定数组维度<ul><li>为数组开辟指定大小的数组维度。</li><li>如果数组元素是基础数据类型，会将每个元素设为默认值；如果是引用类型，元素值为 <code>null</code>。</li></ul></li><li>不指定数组维度<ul><li>用花括号中的实际元素初始化数组，数组大小与元素数相同。</li></ul></li></ul><p>示例 1：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">int</span>[] array1 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[<span class="hljs-number">2</span>]; <span class="hljs-comment">// 指定数组维度（1维）</span><br><span class="hljs-comment">// output:&#123;0，0&#125;</span><br><br><span class="hljs-type">int</span>[] array2 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[] &#123; <span class="hljs-number">1</span>, <span class="hljs-number">2</span> &#125;; <span class="hljs-comment">// 不指定数组维度</span><br><span class="hljs-comment">// output:&#123;1, 2&#125;</span><br></code></pre></td></tr></table></figure><p>说明：请注意数组 array1 中的元素虽然没有初始化，但是 length 和指定的数组维度是一样的。这表明<strong>指定数组维度后，无论后面是否初始化数组中的元素，数组都已经开辟了相应的内存</strong>。</p><p>数组 array1 中的元素都被设为默认值。</p><p>示例 2：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ArrayDemo2</span> &#123;<br>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">User</span> &#123;&#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        User[] array1 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">User</span>[<span class="hljs-number">2</span>]; <span class="hljs-comment">// 指定数组维度</span><br>        User[] array2 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">User</span>[] &#123;<span class="hljs-keyword">new</span> <span class="hljs-title class_">User</span>(), <span class="hljs-keyword">new</span> <span class="hljs-title class_">User</span>()&#125;; <span class="hljs-comment">// 不指定数组维度</span><br><br>        System.out.println(<span class="hljs-string">&quot;array1: &quot;</span>);<br>        <span class="hljs-keyword">for</span> (User item : array1) &#123;<br>            System.out.println(item);<br>        &#125;<br>        System.out.println(<span class="hljs-string">&quot;array2: &quot;</span>);<br>        <span class="hljs-keyword">for</span> (User item : array2) &#123;<br>            System.out.println(item);<br>        &#125;<br>    &#125;<br>&#125;<br><span class="hljs-comment">// array1:</span><br><span class="hljs-comment">// null</span><br><span class="hljs-comment">// null</span><br><br><span class="hljs-comment">// array2:</span><br><span class="hljs-comment">// io.github.dunwu.javacore.array.ArrayDemo2$User@4141d797</span><br><span class="hljs-comment">// io.github.dunwu.javacore.array.ArrayDemo2$User@68f7aae2</span><br></code></pre></td></tr></table></figure><p>说明：如果使用指定数组维度方式创建数组，且数组元素为<strong>引用类型</strong>，则数组中的元素元素值为 <code>null</code>。</p><h3 id="数组维度的形式"><a href="#数组维度的形式" class="headerlink" title="数组维度的形式"></a>数组维度的形式</h3><p>创建数组时，指定的数组维度可以有多种形式：</p><ul><li>数组维度可以是整数、字符。</li><li>数组维度可以是整数型、字符型变量。</li><li>数组维度可以是计算结果为整数或字符的表达式。</li></ul><p>示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ArrayDemo3</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">length</span> <span class="hljs-operator">=</span> <span class="hljs-number">3</span>;<br>        <span class="hljs-comment">// 放开被注掉的代码，编译器会报错</span><br>        <span class="hljs-comment">// int[] array = new int[4.0];</span><br>        <span class="hljs-comment">// int[] array2 = new int[&quot;test&quot;];</span><br>        <span class="hljs-type">int</span>[] array3 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[<span class="hljs-string">&#x27;a&#x27;</span>];<br>        <span class="hljs-type">int</span>[] array4 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[length];<br>        <span class="hljs-type">int</span>[] array5 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[length + <span class="hljs-number">2</span>];<br>        <span class="hljs-type">int</span>[] array6 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[<span class="hljs-string">&#x27;a&#x27;</span> + <span class="hljs-number">2</span>];<br>        <span class="hljs-comment">// int[] array7 = new int[length + 2.1];</span><br>        System.out.println(<span class="hljs-string">&quot;array3.length = [&quot;</span> + array3.length + <span class="hljs-string">&quot;]&quot;</span>);<br>        System.out.println(<span class="hljs-string">&quot;array4.length = [&quot;</span> + array4.length + <span class="hljs-string">&quot;]&quot;</span>);<br>        System.out.println(<span class="hljs-string">&quot;array5.length = [&quot;</span> + array5.length + <span class="hljs-string">&quot;]&quot;</span>);<br>        System.out.println(<span class="hljs-string">&quot;array6.length = [&quot;</span> + array6.length + <span class="hljs-string">&quot;]&quot;</span>);<br>    &#125;<br>&#125;<br><span class="hljs-comment">// Output:</span><br><span class="hljs-comment">// array3.length = [97]</span><br><span class="hljs-comment">// array4.length = [3]</span><br><span class="hljs-comment">// array5.length = [5]</span><br><span class="hljs-comment">// array6.length = [99]</span><br></code></pre></td></tr></table></figure><p>说明：当指定的数组维度是字符时，Java 会将其转为整数。如字符 <code>a</code> 的 ASCII 码是 97。</p><p>综上，<strong>Java 数组的数组维度可以是常量、变量、表达式，只要转换为整数即可</strong>。</p><h3 id="数组维度的大小"><a href="#数组维度的大小" class="headerlink" title="数组维度的大小"></a>数组维度的大小</h3><p><strong>数组维度并非没有上限的，如果数值过大，编译时会报错。</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">int</span>[] array = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[<span class="hljs-number">6553612431</span>]; <span class="hljs-comment">// 数组维度过大，编译报错</span><br></code></pre></td></tr></table></figure><p>此外，<strong>数组过大，可能会导致栈溢出</strong>。</p><h2 id="访问数组"><a href="#访问数组" class="headerlink" title="访问数组"></a>访问数组</h2><p><strong>Java 中，可以通过在 <code>[]</code> 中指定下标，访问数组元素，下标位置从 0 开始。</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ArrayDemo4</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">int</span>[] array = &#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>&#125;;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; array.length; i++) &#123;<br>            array[i]++;<br>            System.out.println(String.format(<span class="hljs-string">&quot;array[%d] = %d&quot;</span>, i, array[i]));<br>        &#125;<br>    &#125;<br>&#125;<br><span class="hljs-comment">// Output:</span><br><span class="hljs-comment">// array[0] = 2</span><br><span class="hljs-comment">// array[1] = 3</span><br><span class="hljs-comment">// array[2] = 4</span><br></code></pre></td></tr></table></figure><h2 id="数组的引用"><a href="#数组的引用" class="headerlink" title="数组的引用"></a>数组的引用</h2><p><strong>Java 中，数组类型是一种引用类型</strong>。</p><p>因此，它可以作为引用，被 Java 函数<strong>作为函数入参或返回值</strong>。</p><p>数组作为函数入参的示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ArrayRefDemo</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">fun</span><span class="hljs-params">(<span class="hljs-type">int</span>[] array)</span> &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i : array) &#123;<br>            System.out.print(i + <span class="hljs-string">&quot;\t&quot;</span>);<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">int</span>[] array = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[] &#123;<span class="hljs-number">1</span>, <span class="hljs-number">3</span>, <span class="hljs-number">5</span>&#125;;<br>        fun(array);<br>    &#125;<br>&#125;<br><span class="hljs-comment">// Output:</span><br><span class="hljs-comment">// 135</span><br></code></pre></td></tr></table></figure><p>数组作为函数返回值的示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ArrayRefDemo2</span> &#123;<br>    <span class="hljs-comment">// 返回一个数组</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span>[] fun() &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[] &#123;<span class="hljs-number">1</span>, <span class="hljs-number">3</span>, <span class="hljs-number">5</span>&#125;;<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">int</span>[] array = fun();<br>        System.out.println(Arrays.toString(array));<br>    &#125;<br>&#125;<br><span class="hljs-comment">// Output:</span><br><span class="hljs-comment">// [1, 3, 5]</span><br></code></pre></td></tr></table></figure><h2 id="多维数组"><a href="#多维数组" class="headerlink" title="多维数组"></a>多维数组</h2><p>多维数组可以看成是数组的数组，比如二维数组就是一个特殊的一维数组，其每一个元素都是一个一维数组。</p><p>Java 可以支持二维数组、三维数组、四维数组、五维数组。。。</p><p>示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java">Integer[][] a1 = &#123; <span class="hljs-comment">// 自动装箱</span><br>    &#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>,&#125;,<br>    &#123;<span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">6</span>,&#125;,<br>&#125;;<br><span class="hljs-comment">// a1: [[1, 2, 3], [4, 5, 6]]</span><br><br>Double[][][] a2 = &#123; <span class="hljs-comment">// 自动装箱</span><br>    &#123; &#123;<span class="hljs-number">1.1</span>, <span class="hljs-number">2.2</span>&#125;, &#123;<span class="hljs-number">3.3</span>, <span class="hljs-number">4.4</span>&#125; &#125;,<br>    &#123; &#123;<span class="hljs-number">5.5</span>, <span class="hljs-number">6.6</span>&#125;, &#123;<span class="hljs-number">7.7</span>, <span class="hljs-number">8.8</span>&#125; &#125;,<br>    &#123; &#123;<span class="hljs-number">9.9</span>, <span class="hljs-number">1.2</span>&#125;, &#123;<span class="hljs-number">2.3</span>, <span class="hljs-number">3.4</span>&#125; &#125;,<br>&#125;;<br><span class="hljs-comment">// a2: [[[1.1, 2.2], [3.3, 4.4]], [[5.5, 6.6], [7.7, 8.8]], [[9.9, 1.2], [2.3, 3.4]]]</span><br><br>String[][] a3 = &#123;<br>    &#123;<span class="hljs-string">&quot;The&quot;</span>, <span class="hljs-string">&quot;Quick&quot;</span>, <span class="hljs-string">&quot;Sly&quot;</span>, <span class="hljs-string">&quot;Fox&quot;</span>&#125;,<br>    &#123;<span class="hljs-string">&quot;Jumped&quot;</span>, <span class="hljs-string">&quot;Over&quot;</span>&#125;,<br>    &#123;<span class="hljs-string">&quot;The&quot;</span>, <span class="hljs-string">&quot;Lazy&quot;</span>, <span class="hljs-string">&quot;Brown&quot;</span>, <span class="hljs-string">&quot;Dog&quot;</span>, <span class="hljs-string">&quot;and&quot;</span>, <span class="hljs-string">&quot;friend&quot;</span>&#125;,<br>&#125;;<br><span class="hljs-comment">// a3: [[The, Quick, Sly, Fox], [Jumped, Over], [The, Lazy, Brown, Dog, and, friend]]</span><br></code></pre></td></tr></table></figure><h2 id="Arrays-类"><a href="#Arrays-类" class="headerlink" title="Arrays 类"></a>Arrays 类</h2><p>Java 中，提供了一个很有用的数组工具类：Arrays。</p><p>它提供的主要操作有：</p><ul><li><code>Array.sort()</code> - 排序</li><li><code>Array.binarySearch()</code> - 查找</li><li><code>Array.equals()</code> - 比较</li><li><code>Array.fill()</code> - 填充</li><li><code>Array.asList()</code> - 转列表</li><li><code>Array.hash()</code> - 哈希</li><li><code>Array.toString()</code> - 转字符串</li></ul><blockquote><p>参考：<a href="https://developer.aliyun.com/article/280643">使用 Arrays 类操作 Java 中的数组</a></p></blockquote>]]></content>
    
    
    <categories>
      
      <category>JavaSE</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数组</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Java 方法</title>
    <link href="/java%E6%96%B9%E6%B3%95.html"/>
    <url>/java%E6%96%B9%E6%B3%95.html</url>
    
    <content type="html"><![CDATA[<p>Java 方法（又称为函数）是定义在类中的一段独立的代码块，用来实现某个功能，解决了重复性代码的问题。方法的主要作用是为了提高程序的复用性和可读性。</p><span id="more"></span><blockquote><p>转载：<a href="https://dunwu.github.io/javacore/pages/7a3ffc/">深入理解 Java 方法</a>（有改动）</p></blockquote><h3 id="方法定义"><a href="#方法定义" class="headerlink" title="方法定义"></a>方法定义</h3><p>方法定义语法格式：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java">[修饰符] 返回值类型 方法名([参数类型 参数名])&#123;<br>    ...<br>    方法体<br>    ...<br>    <span class="hljs-keyword">return</span> 返回值;<br>&#125;<br></code></pre></td></tr></table></figure><p>方法包含一个方法头和一个方法体。下面是一个方法的所有部分：</p><ul><li><strong>修饰符</strong> - 修饰符是可选的，它告诉编译器如何调用该方法。定义了该方法的访问类型。</li><li><strong>返回值类型</strong> - 返回值类型表示方法执行结束后，返回结果的数据类型。如果没有返回值，应设为 void。</li><li><strong>方法名</strong> - 是方法的实际名称。方法名和参数表共同构成方法签名。</li><li><strong>参数类型</strong> - 参数像是一个占位符。当方法被调用时，传递值给参数。参数列表是指方法的参数类型、顺序和参数的个数。参数是可选的，方法可以不包含任何参数。</li><li><strong>方法体</strong> - 方法体包含具体的语句，定义该方法的功能。</li><li><strong>return</strong> - 必须返回声明方法时返回值类型相同的数据类型。在 void 方法中，return 语句可有可无。</li></ul><h3 id="方法的调用"><a href="#方法的调用" class="headerlink" title="方法的调用"></a>方法的调用</h3><p>当程序调用一个方法时，程序的控制权交给了被调用的方法。当被调用方法的返回语句执行或者到达方法体闭括号时候交还控制权给程序。</p><p>Java 支持两种调用方法的方式，根据方法是否有返回值来选择。</p><ul><li>有返回值方法 - 有返回值方法通常被用来给一个变量赋值或代入到运算表达式中进行计算。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">int</span> <span class="hljs-variable">larger</span> <span class="hljs-operator">=</span> max(<span class="hljs-number">30</span>, <span class="hljs-number">40</span>);<br></code></pre></td></tr></table></figure><ul><li>无返回值方法 - 无返回值方法只能是一条语句。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">System.out.println(<span class="hljs-string">&quot;Hello World&quot;</span>);<br></code></pre></td></tr></table></figure><h2 id="方法参数"><a href="#方法参数" class="headerlink" title="方法参数"></a>方法参数</h2><p>在 C&#x2F;C++ 等编程语言中，方法的参数传递一般有两种形式：</p><ul><li>值传递 - 值传递的参数被称为形参。值传递时，传入的参数，在方法中的修改，不会在方法外部生效。</li><li>引用传递 - 引用传递的参数被称为实参。引用传递时，传入的参数，在方法中的修改，会在方法外部生效。</li></ul><p><u><strong>Java 中只有值传递，不存在引用传递!</strong></u></p><p>示例一：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MethodParamDemo</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">method</span><span class="hljs-params">(<span class="hljs-type">int</span> value)</span> &#123;<br>        value =  value + <span class="hljs-number">1</span>;<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">num</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        method(num);<br>        System.out.println(<span class="hljs-string">&quot;num = [&quot;</span> + num + <span class="hljs-string">&quot;]&quot;</span>);<br>    &#125;<br>&#125;<br><span class="hljs-comment">// Output:</span><br><span class="hljs-comment">// num = [0]</span><br></code></pre></td></tr></table></figure><p>示例二：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MethodParamDemo2</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">method</span><span class="hljs-params">(StringBuilder sb)</span> &#123;<br>        sb = <span class="hljs-keyword">new</span> <span class="hljs-title class_">StringBuilder</span>(<span class="hljs-string">&quot;B&quot;</span>);<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">StringBuilder</span> <span class="hljs-variable">sb</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">StringBuilder</span>(<span class="hljs-string">&quot;A&quot;</span>);<br>        System.out.println(<span class="hljs-string">&quot;sb = [&quot;</span> + sb.toString() + <span class="hljs-string">&quot;]&quot;</span>);<br>        method(sb);<br>        System.out.println(<span class="hljs-string">&quot;sb = [&quot;</span> + sb.toString() + <span class="hljs-string">&quot;]&quot;</span>);<br>        sb = <span class="hljs-keyword">new</span> <span class="hljs-title class_">StringBuilder</span>(<span class="hljs-string">&quot;C&quot;</span>);<br>        System.out.println(<span class="hljs-string">&quot;sb = [&quot;</span> + sb.toString() + <span class="hljs-string">&quot;]&quot;</span>);<br>    &#125;<br>&#125;<br><span class="hljs-comment">// Output:</span><br><span class="hljs-comment">// sb = [A]</span><br><span class="hljs-comment">// sb = [A]</span><br><span class="hljs-comment">// sb = [C]</span><br></code></pre></td></tr></table></figure><p>以上两个示例，<strong>无论向方法中传入的参数是基础数据类型，还是引用类型，在方法中修改的值，在外部都未生效</strong>。</p><blockquote><p>Java 对于基本数据类型，会直接拷贝值传递到方法中；对于引用数据类型，拷贝当前对象的引用地址，然后把该地址传递过去，所以也是值传递。</p><p>参考：<a href="https://zhuanlan.zhihu.com/p/24556934?refer=dreawer">图解 Java 中的参数传递</a></p></blockquote><p>String 特例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>       <span class="hljs-type">String</span> <span class="hljs-variable">str</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;11111&quot;</span>;<br>       changeStr(str);<br>       System.out.println(str);<span class="hljs-comment">//输出11111</span><br>   &#125;<br>   <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">changeStr</span><span class="hljs-params">(String str)</span>&#123;<br>       str = <span class="hljs-string">&quot;22222&quot;</span>;<br>   &#125;<br></code></pre></td></tr></table></figure><p><code>str</code> 不变，因为<strong>String 对象具有不可变性</strong>，所以针对操作<code>str = &quot;22222&quot;</code>，在 String 池中不存在的时候,就是相当于<code>str = new String()</code>，new 操作会在堆中重新创建一个对象，此时<code>str</code>指向这个对象，而原<code>str</code>不变（值传递）。</p><p><strong>在 Java 中，当基本类型作为参数传入方法时，无论该参数在方法内怎样被改变，外部的变量原型总是不变的，因为方法内部有外部变量的一份拷贝，对这个拷贝的更改不会改变外部变量的值。</strong></p><blockquote><p>结论：八个基本数据类型，String 对象，作为参数传递不会改变其原先值！</p></blockquote><p><strong>当方法传入的参数为非基本类型时（对象类型的变量），方法里面改变参数变量的同时变量原型也会随之改变。</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">StringBuffer</span> <span class="hljs-variable">strBuf</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">StringBuffer</span>(“original”);<br>changeStringBuffer(strBuf) &#123;strbuf.apend(“ is changed!”)&#125; <span class="hljs-comment">//改变送进的StringBuffer变量</span><br>System.out.println(strBuf); <span class="hljs-comment">//这时strBuf的值就变为了original is changed!</span><br></code></pre></td></tr></table></figure><p>这种特性就叫做“引用传递”，也叫做传址，即方法操作<strong>参数变量时是拷贝了变量的引用</strong>，注意下传递给方法的参数为变量的引用，<strong>其实也就是指针，而后通过这个引用找到变量（在这里是对象）的真正地址，并对其进行操作</strong>。</p><h2 id="方法修饰符"><a href="#方法修饰符" class="headerlink" title="方法修饰符"></a>方法修饰符</h2><p>Java 方法的修饰符是可选的，它告诉编译器如何调用该方法，以及定义了该方法的访问类型。</p><h3 id="访问控制修饰符"><a href="#访问控制修饰符" class="headerlink" title="访问控制修饰符"></a>访问控制修饰符</h3><p>访问权限控制的等级，从最大权限到最小权限依次为：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> &gt; <span class="hljs-keyword">protected</span> &gt; 包访问权限（没有任何关键字）&gt; <span class="hljs-keyword">private</span><br></code></pre></td></tr></table></figure><ul><li><code>public</code> - 表示任何类都可以访问；</li><li><code>包访问权限</code> - 包访问权限，没有任何关键字。它表示当前包中的所有其他类都可以访问，但是其它包的类无法访问。</li><li><code>protected</code> - 表示子类可以访问，此外，同一个包内的其他类也可以访问，即使这些类不是子类。</li><li><code>private</code> - 表示其它任何类都无法访问。</li></ul><h3 id="static"><a href="#static" class="headerlink" title="static"></a>static</h3><p><strong>被 <code>static</code> 修饰的方法被称为静态方法。</strong></p><p>静态方法相比于普通的实例方法，主要有以下区别：</p><ul><li>在外部调用静态方法时，可以使用 <code>类名.方法名</code> 的方式，也可以使用 <code>对象名.方法名</code> 的方式。而实例方法只有后面这种方式。也就是说，<strong>调用静态方法可以无需创建对象</strong>。</li><li><strong>静态方法在访问本类的成员时，只允许访问静态成员</strong>（即静态成员变量和静态方法），而不允许访问实例成员变量和实例方法；实例方法则无此限制。</li></ul><p><em>静态方法常被用于各种工具类、工厂方法类。</em></p><h3 id="final"><a href="#final" class="headerlink" title="final"></a>final</h3><p>被 <code>final</code> 修饰的方法不能被子类覆写（Override）。</p><p>final 方法示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">FinalMethodDemo</span> &#123;<br>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Father</span> &#123;<br>        <span class="hljs-keyword">protected</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">print</span><span class="hljs-params">()</span> &#123;<br>            System.out.println(<span class="hljs-string">&quot;call Father print()&quot;</span>);<br>        &#125;;<br>    &#125;<br><br>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Son</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Father</span> &#123;<br>        <span class="hljs-meta">@Override</span><br>        <span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">print</span><span class="hljs-params">()</span> &#123;<br>            System.out.println(<span class="hljs-string">&quot;call print()&quot;</span>);<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">Father</span> <span class="hljs-variable">demo</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Son</span>();<br>        demo.print();<br>    &#125;<br>&#125;<br><span class="hljs-comment">// 编译时会报错</span><br></code></pre></td></tr></table></figure><p>上面示例中，父类 Father 中定义了一个 final 方法 print()，则其子类不能 Override 这个 final 方法，否则会编译报错。</p><blockquote><ul><li>final 关键字可以用于成员变量、本地变量、方法以及类</li><li>final 成员变量必须在声明的时候初始化或者在构造器中初始化，否则就汇报编译错误</li><li>不能够对 final 变量再次赋值</li><li>本地变量必须在声明时赋值</li><li>在匿名类中所有变量都必须是 final 变量</li><li>final 方法不能被重写</li><li>final 类不能被继承</li><li>接口中声明的所有变量本身是 final 的</li><li>final 和 abstract 这两个关键字是反相关的，final 类就不可能是 abstract 的</li><li>没有在声明时初始化 final 变量的称为空白 final 变量(blank final variable)，它们必须在构造器中初始化，或者调用 this() 初始化，不这么做的话，编译器会报错 final 变量(变量名)需要进行初始化</li><li>按照 Java 代码惯例，final 变量就是常量，而且通常常量名要大写</li><li>对于集合对象声明为 final 指的是引用不能被更改</li></ul><p>参考：<a href="https://developer.aliyun.com/article/723832">深入理解 Java 中的 final 关键字</a></p></blockquote><h3 id="default"><a href="#default" class="headerlink" title="default"></a>default</h3><p><strong><code>default</code> 方法只能出现在接口 <code>Interface</code> 中</strong>。<strong>接口中被 <code>default</code> 修饰的方法被称为默认方法，实现此接口的类如果没 Override 此方法，则直接继承这个方法，不再强制必须实现此方法。</strong></p><p><code>default</code> 方法示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">DefaultMethodDemo</span> &#123;<br>    <span class="hljs-keyword">interface</span> <span class="hljs-title class_">MyInterface</span> &#123;<br>        <span class="hljs-keyword">default</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">print</span><span class="hljs-params">()</span> &#123;<br>            System.out.println(<span class="hljs-string">&quot;Hello World&quot;</span>);<br>        &#125;<br>    &#125;<br><br><br>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MyClass</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">MyInterface</span> &#123;&#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">MyInterface</span> <span class="hljs-variable">obj</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">MyClass</span>();<br>        obj.print();<br>    &#125;<br>&#125;<br><span class="hljs-comment">// Output:</span><br><span class="hljs-comment">// Hello World</span><br></code></pre></td></tr></table></figure><h3 id="abstract"><a href="#abstract" class="headerlink" title="abstract"></a>abstract</h3><p><strong>被 <code>abstract</code> 修饰的方法被称为抽象方法，方法不能有实体。抽象方法只能出现抽象类中。</strong></p><p>抽象方法示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">AbstractMethodDemo</span> &#123;<br>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">AbstractClass</span> &#123;<br>        <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">print</span><span class="hljs-params">()</span>; <span class="hljs-comment">// 不用实现</span><br>    &#125;<br><br>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ConcreteClass</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">AbstractClass</span> &#123;<br>        <span class="hljs-meta">@Override</span><br>        <span class="hljs-keyword">void</span> <span class="hljs-title function_">print</span><span class="hljs-params">()</span> &#123;<br>            System.out.println(<span class="hljs-string">&quot;call print()&quot;</span>);<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">AbstractClass</span> <span class="hljs-variable">demo</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ConcreteClass</span>();<br>        demo.print();<br>    &#125;<br><br>&#125;<br><span class="hljs-comment">// Outpu:</span><br><span class="hljs-comment">// call print()</span><br></code></pre></td></tr></table></figure><h3 id="synchronized"><a href="#synchronized" class="headerlink" title="synchronized"></a>synchronized</h3><p><code>synchronized</code> 用于并发编程。<strong>被 <code>synchronized</code> 修饰的方法在一个时刻，只允许一个线程执行，相当于锁。</strong></p><blockquote><p>在 Java 的同步容器（Vector、Stack、HashTable）中，会有大量的 synchronized 方法。不过，请记住：在 Java 并发编程中，synchronized 方法并不是一个好的选择，大多数情况下，我们会选择更加轻量级的锁 。</p></blockquote><h2 id="特殊方法"><a href="#特殊方法" class="headerlink" title="特殊方法"></a>特殊方法</h2><p>Java 中，有一些较为特殊的方法，分别使用于特殊的场景。</p><h3 id="main-方法"><a href="#main-方法" class="headerlink" title="main 方法"></a>main 方法</h3><p>Java 中的 main 方法是一种特殊的静态方法，因为所有的 Java 程序都是由 <code>public static void main(String[] args)</code> 方法开始执行，main 方法中的 args 是用来接收接收命令行输入参数的。</p><p>示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MainMethodDemo</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-keyword">for</span> (String arg : args) &#123;<br>            System.out.println(<span class="hljs-string">&quot;arg = [&quot;</span> + arg + <span class="hljs-string">&quot;]&quot;</span>);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>依次执行</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java">javac MainMethodDemo.java<br>java MainMethodDemo A B C<br></code></pre></td></tr></table></figure><p>控制台会打印输出参数：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java">arg = [A]<br>arg = [B]<br>arg = [C]<br></code></pre></td></tr></table></figure><h3 id="构造方法"><a href="#构造方法" class="headerlink" title="构造方法"></a>构造方法</h3><ul><li><p>任何类都有构造方法，构造方法的作用就是在初始化类实例时，设置实例的状态。</p></li><li><p>每个类都有构造方法。如果没有显式地为类定义任何构造方法，Java 编译器将会为该类提供一个默认构造方法。</p></li><li><p>在创建一个对象的时候，至少要调用一个构造方法。构造方法的名称必须与类同名，一个类可以有多个构造方法。</p></li></ul><p><strong>注意，构造方法可以使用 private 修饰，这种情况下，类无法调用此构造方法去实例化对象，这常常用于设计模式中的单例模式。</strong></p><h3 id="finalize-方法"><a href="#finalize-方法" class="headerlink" title="finalize() 方法"></a>finalize() 方法</h3><p><code>finalize</code> 在对象被垃圾收集器析构(回收)之前调用，用来清除回收对象。</p><p>finalizer() 通常是不可预测的，也是很危险的，一般情况下是<strong>不必要的</strong>。使用终结方法会导致行为不稳定、降低性能，以及可移植性问题。</p><blockquote><p>所以，<strong>应该尽量避免使用 <code>finalizer()</code><strong>。千万不要把它当成是 C&#x2F;C++ 中的析构函数来用。原因是：</strong>Finalizer 线程会和我们的主线程进行竞争，不过由于它的优先级较低，获取到的 CPU 时间较少，因此它永远也赶不上主线程的步伐。所以最后可能会发生 OutOfMemoryError 异常。</strong></p><p>参考：<a href="https://zhuanlan.zhihu.com/p/27850176">重载 Finalize 引发的内存泄露</a></p></blockquote><h2 id="覆写和重载"><a href="#覆写和重载" class="headerlink" title="覆写和重载"></a>覆写和重载</h2><p><strong>覆写（Override）是指子类定义了与父类中同名的方法，但是在方法覆写时必须考虑到访问权限，子类覆写的方法不能拥有比父类更加严格的访问权限。</strong></p><p>覆写示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MethodOverrideDemo</span> &#123;<br>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Animal</span> &#123;<br>        <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">move</span><span class="hljs-params">()</span> &#123;<br>            System.out.println(<span class="hljs-string">&quot;会动&quot;</span>);<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Dog</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Animal</span> &#123;<br>        <span class="hljs-meta">@Override</span><br>        <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">move</span><span class="hljs-params">()</span> &#123;<br>            <span class="hljs-built_in">super</span>.move();<br>            System.out.println(<span class="hljs-string">&quot;会跑&quot;</span>);<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">Animal</span> <span class="hljs-variable">dog</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Dog</span>();<br>        dog.move();<br>    &#125;<br>&#125;<br><span class="hljs-comment">// Output:</span><br><span class="hljs-comment">// 会动</span><br><span class="hljs-comment">// 会跑</span><br></code></pre></td></tr></table></figure><p><strong>方法的重载（Overload）是指方法名称相同，但参数的类型或参数的个数不同。通过传递参数的个数及类型的不同可以完成不同功能的方法调用。</strong></p><blockquote><p>注意：重载一定是方法的参数不完全相同。如果方法的参数完全相同，仅仅是返回值不同，Java 是无法编译通过的。</p></blockquote><p>重载示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MethodOverloadDemo</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">add</span><span class="hljs-params">(<span class="hljs-type">int</span> x, <span class="hljs-type">int</span> y)</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;x + y = &quot;</span> + (x + y));<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">add</span><span class="hljs-params">(<span class="hljs-type">double</span> x, <span class="hljs-type">double</span> y)</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;x + y = &quot;</span> + (x + y));<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        add(<span class="hljs-number">10</span>, <span class="hljs-number">20</span>);<br>        add(<span class="hljs-number">1.0</span>, <span class="hljs-number">2.0</span>);<br>    &#125;<br>&#125;<br><span class="hljs-comment">// Output:</span><br><span class="hljs-comment">// x + y = 30</span><br><span class="hljs-comment">// x + y = 3.0</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>JavaSE</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java</tag>
      
      <tag>方法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Java 面向对象</title>
    <link href="/java%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1.html"/>
    <url>/java%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1.html</url>
    
    <content type="html"><![CDATA[<p>Java 面向对象具有以下三个主要特征：一、封装（Encapsulation）；二、继承（Inheritance）；三、多态（Polymorphism）。封装使得对象的内部状态和行为对外部不可见，这不仅提高了代码的可维护性和复用性，还可以保护数据的安全性。</p><span id="more"></span><blockquote><p>转载：<a href="https://dunwu.github.io/javacore/pages/3e1661/">Java 面向对象</a>（有改动）</p></blockquote><h2 id="面向对象"><a href="#面向对象" class="headerlink" title="面向对象"></a>面向对象</h2><p>每种编程语言，都有自己的操纵内存中元素的方式。Java 中提供了基本数据类型，但这还不能满足编写程序时，需要抽象更加复杂数据类型的需要。因此，Java 中，允许开发者通过类创建自定义类型。</p><p>Java 世界有一句名言：一切皆为对象。这句话，你可能第一天学 Java 时，就听过了。这不仅仅是一句口号，也体现在 Java 的设计上。</p><ul><li>首先，所有 Java 类都继承自 <code>Object</code> 类（从这个名字，就可见一斑）。</li><li>几乎所有 Java 对象初始化时，都要使用 <code>new</code> 创建对象（基本数据类型、String、枚举特殊处理），对象存储在堆中。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">String</span> <span class="hljs-variable">s</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;abc&quot;</span>;<br><span class="hljs-type">String</span> <span class="hljs-variable">s</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>(<span class="hljs-string">&quot;abc&quot;</span>);<br></code></pre></td></tr></table></figure><p>其中，<code>String s</code> 定义了一个名为 s 的引用，它指向一个 <code>String</code> 类型的对象，而实际的对象是 <code>“abc”</code> 字符串。</p><p><strong>与 C&#x2F;C++ 这类语言不同，程序员只需要通过 <code>new</code> 创建一个对象，但不必负责销毁或结束一个对象。</strong>负责运行 Java 程序的 Java 虚拟机有一个垃圾回收器，它会监视 <code>new</code> 创建的对象，一旦发现对象不再被引用，则会释放对象的内存空间。</p><h3 id="封装"><a href="#封装" class="headerlink" title="封装"></a>封装</h3><p><strong>封装（Encapsulation）是指一种将抽象性函式接口的实现细节部份包装、隐藏起来的方法。</strong></p><p>封装最主要的作用在于我们能修改自己的实现代码，而不用修改那些调用我们代码的程序片段。</p><p>封装的优点：</p><ul><li>良好的封装能够减少耦合。</li><li>类内部的结构可以自由修改。</li><li>可以对成员变量进行更精确的控制。</li><li>隐藏信息，实现细节。</li></ul><p>实现封装的步骤：</p><ol><li>修改属性的可见性来限制对属性的访问（一般限制为 private）。</li><li>对每个值属性提供对外的公共方法访问，也就是创建一对赋取值方法，用于对私有属性的访问。</li></ol><h3 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h3><p><strong>继承（Inheritance）是子类继承父类的特征和行为，使得子类对象（实例）具有父类的实例域和方法，或子类从父类继承方法，使得子类具有父类相同的行为。</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 子类继承父类</span><br>class 父类 &#123;&#125;<br>class 子类 extends 父类 &#123;&#125;<br></code></pre></td></tr></table></figure><h4 id="继承的特性"><a href="#继承的特性" class="headerlink" title="继承的特性"></a>继承的特性</h4><ul><li>子类可以继承父类的属性和方法。需要注意的是，<strong>构造方法除外，构造方法只能被调用，而不能被继承。</strong></li><li>子类可以拥有自己的属性和方法，即子类可以对父类进行<strong>扩展</strong>。</li><li>子类可以用自己的方式实现父类的方法。</li><li>Java 的继承是<strong>单继承</strong>，但是可以多重继承，单继承就是一个子类只能继承一个父类，<strong>多重继承就是，例如 A 类继承 B 类，B 类继承 C 类</strong>（传递性质），所以按照关系就是 C 类是 B 类的父类，B 类是 A 类的父类，这是 Java 继承区别于 C++ 继承的一个特性。</li><li>提高了类之间的<strong>耦合性</strong>（继承的缺点，耦合度高就会造成代码之间的联系越紧密，代码独立性越差）。</li></ul><h4 id="继承关键字"><a href="#继承关键字" class="headerlink" title="继承关键字"></a>继承关键字</h4><p>继承可以使用 <code>extends</code> 和 <code>implements</code> 这两个关键字来实现继承，而且所有的类都是继承于 <code>java.lang.Object</code>，当一个类没有继承的两个关键字，则默认继承 <code>Object</code>（这个类在 <strong><code>java.lang</code></strong> 包中，所以不需要 **<code>import</code>**）祖先类。</p><h3 id="多态"><a href="#多态" class="headerlink" title="多态"></a>多态</h3><p><strong>多态(Polymorphism）是指在面向对象编程中，同一个类的对象在不同情况下表现出不同的行为和状态</strong>。 子类可以继承父类的属性和方法，子类对象可以直接使用父类中的方法和变量。 子类可以对从父类继承的方法进行<strong>重新实现</strong>，使得子类对象调用这个方法时表现出不同的行为。</p><h2 id="类"><a href="#类" class="headerlink" title="类"></a>类</h2><p>与大多数面向对象编程语言一样，Java 使用 <code>class</code>（类）关键字来表示自定义类型。自定义类型是为了更容易抽象现实事物。</p><p>在一个类中，可以设置一静一动两种元素：属性（静）和方法（动）。</p><ul><li><strong>属性（成员、字段）</strong> - 属性抽象的是事物的状态。</li><li><strong>方法（为函数）</strong> - 方法抽象的是事物的行为。</li></ul><h2 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h2><p>Java 方法（又称为函数）是定义在类中的一段独立的代码块，用来实现某个功能，解决了重复性代码的问题。方法的主要作用是为了提高程序的复用性和可读性。</p><h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java">修饰符 返回值类型 方法名(参数类型 参数名)&#123;<br>    ...<br>    方法体<br>    ...<br>    <span class="hljs-keyword">return</span> 返回值;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="构造方法"><a href="#构造方法" class="headerlink" title="构造方法"></a>构造方法</h3><p>每个类都有构造方法。如果没有显式地为类定义任何构造方法，Java 编译器将会为该类提供一个默认构造方法。</p><p>在创建一个对象的时候，至少要调用一个构造方法。构造方法的名称必须与类同名，一个类可以有多个构造方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Puppy</span>&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">Puppy</span><span class="hljs-params">()</span>&#123;<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">Puppy</span><span class="hljs-params">(String name)</span>&#123;<br>        <span class="hljs-comment">// 这个构造器仅有一个参数：name</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h2><p>Java 支持的变量类型有：</p><ul><li><code>局部变量</code> - 类方法中的变量。</li><li><code>实例变量（也叫成员变量）</code> - 类方法外的变量，不过没有 <code>static</code> 修饰。</li><li><code>类变量（也叫静态变量）</code> - 类方法外的变量，用 <code>static</code> 修饰。</li></ul><h3 id="变量修饰符"><a href="#变量修饰符" class="headerlink" title="变量修饰符"></a>变量修饰符</h3><ul><li>访问级别修饰符 - 如果变量是实例变量或类变量，可以添加访问级别修饰符（public&#x2F;protected&#x2F;private）</li><li>静态修饰符 - 如果变量是类变量，需要添加 static 修饰</li><li>final - 如果变量使用 final 修饰符，就表示这是一个<strong>常量</strong>，<strong>不能被修改</strong>。</li></ul><h3 id="创建对象"><a href="#创建对象" class="headerlink" title="创建对象"></a>创建对象</h3><p>对象是根据类创建的。在 Java 中，使用关键字 new 来创建一个新的对象。创建对象需要以下三步：</p><ul><li><strong>声明</strong>：声明一个对象，包括对象名称和对象类型。</li><li><strong>实例化</strong>：使用关键字 new 来创建一个对象。</li><li><strong>初始化</strong>：使用 new 创建对象时，会调用构造方法初始化对象。</li></ul><h2 id="访问权限控制"><a href="#访问权限控制" class="headerlink" title="访问权限控制"></a>访问权限控制</h2><h3 id="代码组织"><a href="#代码组织" class="headerlink" title="代码组织"></a>代码组织</h3><p><strong>当编译一个 .java 文件时，在 .java 文件中的每个类都会输出一个与类同名的 .class 文件。</strong></p><p>MultiClassDemo.java 示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">MultiClass1</span> &#123;&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">MultiClass2</span> &#123;&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">MultiClass3</span> &#123;&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MultiClassDemo</span> &#123;&#125;<br></code></pre></td></tr></table></figure><p>执行 <code>javac MultiClassDemo.java</code> 命令，本地会生成 MultiClass1.class、MultiClass2.class、MultiClass3.class、MultiClassDemo.class 四个文件。</p><p><strong>Java 可运行程序是由一组 .class 文件打包并压缩成的一个 .jar 文件</strong>。Java 解释器负责这些文件的查找、装载和解释。<strong>Java 类库实际上是一组类文件（.java 文件）。</strong></p><ul><li><strong>其中每个文件允许有一个 public 类，以及任意数量的非 public 类</strong>。</li><li><strong>public 类名必须和 .java 文件名完全相同，包括大小写。</strong></li></ul><p>程序一般不止一个人编写，会调用系统提供的代码、第三方库中的代码、项目中其他人写的代码等，不同的人因为不同的目的可能定义同样的类名&#x2F;接口名，这就是命名冲突。</p><p>Java 中为了解决命名冲突问题，提供了包（<code>package</code>）和导入（<code>import</code>）机制。</p><h4 id="package"><a href="#package" class="headerlink" title="package"></a>package</h4><p>包（<code>package</code>）的原则：</p><ul><li>包类似于文件夹，文件放在文件夹中，类和接口则放在包中。为了便于组织，文件夹一般是一个<strong>有层次的树形结构</strong>，包也类似。</li><li><strong>包名以逗号 <code>.</code> 分隔，表示层次结构。</strong></li><li>Java 中命名包名的一个惯例是<strong>使用域名作为前缀</strong>，因为域名是唯一的，一般按照<strong>域名的反序来定义包名</strong>，比如，域名是：apache.org，包名就以 org.apache 开头。</li><li><strong>包名和文件目录结构必须完全匹配。</strong>Java 解释器运行过程如下：<ul><li>找出环境变量 CLASSPATH，作为 .class 文件的根目录。</li><li>从根目录开始，获取包名称，并将逗号 <code>.</code> 替换为文件分隔符（反斜杠 <code>/</code>），通过这个路径名称去查找 Java 类。</li></ul></li></ul><h4 id="import"><a href="#import" class="headerlink" title="import"></a>import</h4><p>同一个包下的类之间互相引用是不需要包名的，可以直接使用。但如果类不在同一个包内，则必须要知道其所在的包，使用有两种方式：</p><ul><li><p>通过类的完全限定名</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">PackageDemo</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span> <span class="hljs-params">(String[]args)</span>&#123;<br>        System.out.println(<span class="hljs-keyword">new</span> <span class="hljs-title class_">java</span>.util.Date());<br>        System.out.println(<span class="hljs-keyword">new</span> <span class="hljs-title class_">java</span>.util.Date());<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>通过 import 将用到的类引入到当前类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.util.Date;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">PackageDemo2</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        System.out.println(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Date</span>());<br>        System.out.println(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Date</span>());<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li></ul><p>显然是 <code>import</code> 方式，代码更加整洁。</p><h3 id="访问权限修饰关键字"><a href="#访问权限修饰关键字" class="headerlink" title="访问权限修饰关键字"></a>访问权限修饰关键字</h3><p>访问权限控制的等级，从最大权限到最小权限依次为：</p><figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs actionscript"><span class="hljs-keyword">public</span> &gt; <span class="hljs-keyword">protected</span> &gt; 包访问权限（没有任何关键字）&gt; <span class="hljs-keyword">private</span><br></code></pre></td></tr></table></figure><ul><li><code>public</code> - 表示任何类都可以访问；</li><li><code>包访问权限</code> - 包访问权限，没有任何关键字。它表示当前包中的所有其他类都可以访问，但是其它包的类无法访问。</li><li><code>protected</code> - 表示子类可以访问，此外，<strong>同一个包内的其他类也可以访问</strong>，即使这些类不是子类。</li><li><code>private</code> - 表示其它任何类都无法访问。</li></ul><h2 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h2><p>接口是对行为的抽象，它是抽象方法的集合，利用接口可以达到 API 定义和实现分离的目的。</p><p>接口，不能实例化；不能包含任何非常量成员，任何 field 都是隐含着 <code>public static final</code> 的意义；同时，没有非静态方法实现，<strong>也就是说要么是抽象方法，要么是静态方法</strong>。</p><p>Java 标准类库中，定义了非常多的接口，比如 <code>java.util.List</code>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">Comparable</span>&lt;T&gt; &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">compareTo</span><span class="hljs-params">(T o)</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="抽象类"><a href="#抽象类" class="headerlink" title="抽象类"></a>抽象类</h2><p>抽象类是不能实例化的类，用 <code>abstract</code> 关键字修饰 <code>class</code>，其目的主要是代码重用。除了不能实例化，形式上和一般的 Java 类并没有太大区别，可以有一个或者多个抽象方法，也可以没有抽象方法。抽象类大多用于抽取相关 Java 类的共用方法实现或者是共同成员变量，然后通过继承的方式达到代码复用的目的。</p><ol><li>抽象类不能被实例化(初学者很容易犯的错)，如果被实例化，就会报错，编译无法通过。只有抽象类的非抽象子类可以创建对象。</li><li>抽象类中不一定包含抽象方法，但是有抽象方法的类必定是抽象类。</li><li>抽象类中的抽象方法只是声明，不包含方法体，就是不给出方法的具体实现也就是方法的具体功能。</li><li>构造方法，类方法（用 static 修饰的方法）不能声明为抽象方法。</li><li>抽象类的子类必须给出抽象类中的抽象方法的具体实现，除非该子类也是抽象类。</li></ol>]]></content>
    
    
    <categories>
      
      <category>JavaSE</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java</tag>
      
      <tag>oop</tag>
      
      <tag>类</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Java 数据类型</title>
    <link href="/java%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B.html"/>
    <url>/java%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B.html</url>
    
    <content type="html"><![CDATA[<p>Java 中的数据类型有两类：值类型（又叫内置数据类型，基本数据类型），引用类型（除值类型以外，都是引用类型，包括字符串、数组等）。</p><span id="more"></span><blockquote><p>转载：<a href="https://dunwu.github.io/javacore/pages/55d693/">深入理解 Java 基本数据类型</a>（有改动）</p></blockquote><h2 id="数据类型分类"><a href="#数据类型分类" class="headerlink" title="数据类型分类"></a>数据类型分类</h2><p>Java 数据类型分为值类型和引用类型：</p><ul><li>值类型包括：boolean、char、byte、short、int、long、float 、double。</li><li>引用类型包括：数组、类、接口、枚举。</li></ul><h3 id="值类型"><a href="#值类型" class="headerlink" title="值类型"></a>值类型</h3><p>Java 语言提供了 <strong>8</strong> 种基本类型，大致分为 <strong>4</strong> 类。</p><table><thead><tr><th>基本数据类型</th><th>分类</th><th>比特数</th><th>默认值</th><th>取值范围</th></tr></thead><tbody><tr><td><code>boolean</code></td><td><strong>布尔型</strong></td><td>8 位</td><td><code>false</code></td><td>{false, true}</td></tr><tr><td><code>char</code></td><td><strong>字符型</strong></td><td>16 位</td><td><code>&#39;\u0000&#39;</code></td><td>[0, $2^{16} - 1$]</td></tr><tr><td><code>byte</code></td><td><strong>整数型</strong></td><td>8 位</td><td><code>0</code></td><td>[-$2^7$, $2^7 - 1$]</td></tr><tr><td><code>short</code></td><td><strong>整数型</strong></td><td>16 位</td><td><code>0</code></td><td>[-$2^{15}$, $2^{15} - 1$]</td></tr><tr><td><code>int</code></td><td><strong>整数型</strong></td><td>32 位</td><td><code>0</code></td><td>[-$2^{31}$, $2^{31} - 1$]</td></tr><tr><td><code>long</code></td><td><strong>整数型</strong></td><td>64 位</td><td><code>0L</code></td><td>[-$2^{63}$, $2^{63} - 1$]</td></tr><tr><td><code>float</code></td><td><strong>浮点型</strong></td><td>32 位</td><td><code>+0.0F</code></td><td>[$2^{-149}$, $2^{128} - 1$]</td></tr><tr><td><code>double</code></td><td><strong>浮点型</strong></td><td>64 位</td><td><code>+0.0D</code></td><td>[$2^{-1074}$, $2^{1024} - 1$]</td></tr></tbody></table><p>尽管各种数据类型的默认值看起来不一样，但在内存中都是零。</p><p>在这些基本类型中，<code>boolean</code> 和 <code>char</code> 是唯二的无符号类型。</p><h3 id="值类型和引用类型的区别"><a href="#值类型和引用类型的区别" class="headerlink" title="值类型和引用类型的区别"></a>值类型和引用类型的区别</h3><ul><li>从概念方面来说<ul><li>基本类型：变量名指向具体的数值。</li><li>引用类型：变量名指向存数据对象的内存地址。</li></ul></li><li>从内存方面来说<ul><li>基本类型：变量在声明之后，Java 就会立刻分配给他内存空间。</li><li>引用类型：它以特殊的方式（类似 C 指针）向对象实体（具体的值），这类变量声明时不会分配内存，只是存储了一个内存地址。</li></ul></li><li>从使用方面来说<ul><li>基本类型：使用时需要赋具体值,判断时使用 <code>==</code> 号。</li><li>引用类型：使用时可以赋 null，判断时使用 <code>equals</code> 方法。</li></ul></li></ul><blockquote><p><a href="https://juejin.im/post/59cd71835188255d3448faf6">Java 基本数据类型和引用类型</a></p></blockquote><h2 id="数据转换"><a href="#数据转换" class="headerlink" title="数据转换"></a>数据转换</h2><p>Java 中，数据类型转换有两种方式：</p><ul><li>自动转换</li><li>强制转换</li></ul><h3 id="自动转换"><a href="#自动转换" class="headerlink" title="自动转换"></a>自动转换</h3><p>一般情况下，定义了某数据类型的变量，就不能再随意转换。但是 JAVA 允许用户对基本类型做<strong>有限度</strong>的类型转换。</p><p>如果符合以下条件，则 JAVA 将会自动做类型转换：</p><ul><li><p><strong>由小数据转换为大数据</strong>，显而易见的是，“小”数据类型的数值表示范围小于“大”数据类型的数值表示范围，即精度小于“大”数据类型。这些类型由“小”到“大”分别为：(byte，short，char) &lt; int &lt; long &lt; float &lt; double。</p></li><li><p><strong>转换前后的数据类型要兼容</strong>，由于 boolean 类型只能存放 true 或 false，这与整数或字符是不兼容的，因此不可以做类型转换。</p></li><li><p><strong>整型类型和浮点型进行计算后，结果会转为浮点类型</strong></p></li></ul><p>例如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">long</span> <span class="hljs-variable">x</span> <span class="hljs-operator">=</span> <span class="hljs-number">30</span>;<br><span class="hljs-type">float</span> <span class="hljs-variable">y</span> <span class="hljs-operator">=</span> <span class="hljs-number">14.3f</span>;<br>System.out.println(<span class="hljs-string">&quot;x/y = &quot;</span> + x/y);<br></code></pre></td></tr></table></figure><p>输出：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">x/y = <span class="hljs-number">1.9607843</span><br></code></pre></td></tr></table></figure><p>可见 long 虽然精度大于 float 类型，但是结果为浮点数类型。</p><h3 id="强制转换"><a href="#强制转换" class="headerlink" title="强制转换"></a>强制转换</h3><p>在不符合自动转换条件时或者根据用户的需要，可以对数据类型做强制的转换。</p><p><strong>强制转换使用括号 <code>()</code> 。</strong></p><p>引用类型也可以使用强制转换。</p><p>例如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">float</span> <span class="hljs-variable">f</span> <span class="hljs-operator">=</span> <span class="hljs-number">25.5f</span>;<br><span class="hljs-type">int</span> <span class="hljs-variable">x</span> <span class="hljs-operator">=</span> (<span class="hljs-type">int</span>)f;<br>System.out.println(<span class="hljs-string">&quot;x = &quot;</span> + x);<br></code></pre></td></tr></table></figure><h2 id="装箱和拆箱"><a href="#装箱和拆箱" class="headerlink" title="装箱和拆箱"></a>装箱和拆箱</h2><p><strong>引入包装类的目的</strong>就是：提供一种机制，使得<strong>基本数据类型可以与引用类型互相转换</strong>。</p><p>基本数据类型与包装类的转换被称为<code>装箱</code>和<code>拆箱</code>。</p><ul><li><strong><code>装箱</code>（boxing）是将值类型转换为引用类型</strong>。例如：<code>int</code> 转 <code>Integer</code><ul><li>装箱过程是通过调用包装类的 <code>valueOf</code> 方法实现的。</li></ul></li><li><strong><code>拆箱</code>（unboxing）是将引用类型转换为值类型</strong>。例如：<code>Integer</code> 转 <code>int</code><ul><li>拆箱过程是通过调用包装类的 <code>xxxValue</code> 方法实现的。（xxx 代表对应的基本数据类型）。</li></ul></li></ul><h3 id="包装器类型"><a href="#包装器类型" class="headerlink" title="包装器类型"></a>包装器类型</h3><ul><li>Byte（对应 byte）</li><li>Short（对应 short）</li><li>Integer（对应 int）</li><li>Long（对应 long）</li><li>Float（对应 float）</li><li>Double（对应 double）</li><li>Character（对应 char）</li><li>Boolean（对应 boolean）</li></ul><h3 id="自动装箱"><a href="#自动装箱" class="headerlink" title="自动装箱"></a><strong>自动装箱</strong></h3><p>隐式地创建对象</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">Integer</span> <span class="hljs-variable">i1</span> <span class="hljs-operator">=</span> <span class="hljs-number">10</span>; <span class="hljs-comment">// 自动装箱</span><br><span class="hljs-type">Integer</span> <span class="hljs-variable">i2</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Integer</span>(<span class="hljs-number">10</span>); <span class="hljs-comment">// 非自动装箱</span><br><span class="hljs-type">Integer</span> <span class="hljs-variable">i3</span> <span class="hljs-operator">=</span> Integer.valueOf(<span class="hljs-number">10</span>); <span class="hljs-comment">// 非自动装箱</span><br><span class="hljs-type">int</span> <span class="hljs-variable">i4</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Integer</span>(<span class="hljs-number">10</span>); <span class="hljs-comment">// 自动拆箱</span><br><span class="hljs-type">int</span> <span class="hljs-variable">i5</span> <span class="hljs-operator">=</span> i2.intValue(); <span class="hljs-comment">// 非自动拆箱</span><br></code></pre></td></tr></table></figure><p>注意：</p><ul><li>对于 <code>i1 == i2</code> 输出为 <code>false</code>，因为 i1 和 i2 都是包装类，java 将它们当作两个<strong>对象</strong>，自然不相等。</li><li>对于 <code>i1 == i4</code> 输出为 <code>true</code>，因为 i4 为值，java 自动将 i1 这个包装类<strong>自动拆箱</strong>为一个 <code>int</code> 值。</li></ul><h3 id="装箱、拆箱注意点"><a href="#装箱、拆箱注意点" class="headerlink" title="装箱、拆箱注意点"></a>装箱、拆箱注意点</h3><ol><li>装箱操作会创建对象，频繁的装箱操作会造成不必要的内存消耗，影响性能。所以<strong>应该尽量避免装箱。</strong></li><li>基础数据类型的比较操作使用 <code>==</code>，包装类的比较操作使用 <code>equals</code> 方法。</li></ol><blockquote><p><a href="https://www.cnblogs.com/dolphin0520/p/3780005.html">深入剖析 Java 中的装箱和拆箱</a></p></blockquote><h2 id="判等问题"><a href="#判等问题" class="headerlink" title="判等问题"></a>判等问题</h2><p>Java 中，通常使用 <code>equals</code> 或 <code>==</code> 进行判等操作。<code>equals</code> 是方法而 <code>==</code> 是操作符。此外，二者使用也是有区别的：</p><ul><li>对<strong>基本类型</strong>，比如 <code>int</code>、<code>long</code>，进行判等，<strong>只能使用 <code>==</code>，比较的是字面值</strong>。因为基本类型的值就是其数值。</li><li>对<strong>引用类型</strong>，比如 <code>Integer</code>、<code>Long</code> 和 <code>String</code>，进行判等，<strong>需要使用 <code>equals</code> 进行内容判等</strong>。因为引用类型的直接值是指针，使用 <code>==</code> 的话，比较的是指针，也就是两个对象在内存中的地址，即比较它们是不是同一个对象，而不是比较对象的内容。</li></ul><h3 id="包装类的判等"><a href="#包装类的判等" class="headerlink" title="包装类的判等"></a>包装类的判等</h3><p>【示例】包装类的判等</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">Integer</span> <span class="hljs-variable">a</span> <span class="hljs-operator">=</span> <span class="hljs-number">127</span>; <span class="hljs-comment">//Integer.valueOf(127)</span><br><span class="hljs-type">Integer</span> <span class="hljs-variable">b</span> <span class="hljs-operator">=</span> <span class="hljs-number">127</span>; <span class="hljs-comment">//Integer.valueOf(127)</span><br><span class="hljs-comment">// a == b ? true</span><br><br><span class="hljs-type">Integer</span> <span class="hljs-variable">c</span> <span class="hljs-operator">=</span> <span class="hljs-number">128</span>; <span class="hljs-comment">//Integer.valueOf(128)</span><br><span class="hljs-type">Integer</span> <span class="hljs-variable">d</span> <span class="hljs-operator">=</span> <span class="hljs-number">128</span>; <span class="hljs-comment">//Integer.valueOf(128)</span><br><span class="hljs-comment">// c == d ? false</span><br><span class="hljs-comment">//设置-XX:AutoBoxCacheMax=1000再试试</span><br><br><span class="hljs-type">Integer</span> <span class="hljs-variable">e</span> <span class="hljs-operator">=</span> <span class="hljs-number">127</span>; <span class="hljs-comment">//Integer.valueOf(127)</span><br><span class="hljs-type">Integer</span> <span class="hljs-variable">f</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Integer</span>(<span class="hljs-number">127</span>); <span class="hljs-comment">//new instance</span><br><span class="hljs-comment">// e == f ? false</span><br><br><span class="hljs-type">Integer</span> <span class="hljs-variable">g</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Integer</span>(<span class="hljs-number">127</span>); <span class="hljs-comment">//new instance</span><br><span class="hljs-type">Integer</span> <span class="hljs-variable">h</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Integer</span>(<span class="hljs-number">127</span>); <span class="hljs-comment">//new instance</span><br><span class="hljs-comment">// g == h ? false</span><br><br><span class="hljs-type">Integer</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">128</span>; <span class="hljs-comment">//unbox</span><br><span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">128</span>;<br><span class="hljs-comment">// i == j ? true</span><br></code></pre></td></tr></table></figure><ul><li><p>第一个案例中，编译器会把 <code>Integer a = 127</code> 转换为 <code>Integer.valueOf(127)</code>。查看源码可以发现，这个转换在内部其实做了缓存，<strong>使得两个 Integer 指向同一个对象</strong>，所以 &#x3D;&#x3D; 返回 true。</p></li><li><p>第二个案例中，之所以同样的代码 128 就返回 false 的原因是，默认情况下会缓存[-128,127]的数值，而 128 处于这个区间之外。设置 JVM 参数加上 -XX:AutoBoxCacheMax&#x3D;1000 再试试，是不是就返回 true 了呢？</p></li><li><p>第三和第四个案例中，New 出来的 Integer 始终是<strong>不走缓存的新对象</strong>。比较两个新对象，或者比较一个新对象和一个来自缓存的对象，结果肯定不是相同的对象，因此返回 false。</p></li><li><p>第五个案例中，我们把装箱的 Integer 和基本类型 int 比较，前者会先拆箱再比较，比较的肯定是<strong>数值</strong>而不是引用，因此返回 true。</p></li></ul><blockquote><p>【总结】综上，我们可以得出结论：包装类需要使用 <code>equals</code> 进行内容判等，而不能使用 <code>==</code>。</p></blockquote><h3 id="String-的判等"><a href="#String-的判等" class="headerlink" title="String 的判等"></a>String 的判等</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">String</span> <span class="hljs-variable">a</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;1&quot;</span>;<br><span class="hljs-type">String</span> <span class="hljs-variable">b</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;1&quot;</span>;<br><span class="hljs-comment">// a == b ? true</span><br><br><span class="hljs-type">String</span> <span class="hljs-variable">c</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>(<span class="hljs-string">&quot;2&quot;</span>);<br><span class="hljs-type">String</span> <span class="hljs-variable">d</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>(<span class="hljs-string">&quot;2&quot;</span>);<br><span class="hljs-comment">// c == d ? false</span><br><br><span class="hljs-type">String</span> <span class="hljs-variable">e</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>(<span class="hljs-string">&quot;3&quot;</span>).intern(); <span class="hljs-comment">// 走常量池机制</span><br><span class="hljs-type">String</span> <span class="hljs-variable">f</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>(<span class="hljs-string">&quot;3&quot;</span>).intern();<br><span class="hljs-comment">// e == f ? true</span><br><br><span class="hljs-type">String</span> <span class="hljs-variable">g</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>(<span class="hljs-string">&quot;4&quot;</span>);<br><span class="hljs-type">String</span> <span class="hljs-variable">h</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>(<span class="hljs-string">&quot;4&quot;</span>);<br><span class="hljs-comment">// g.equals(h)) ? true</span><br></code></pre></td></tr></table></figure><blockquote><p>在 JVM 中，当代码中出现双引号形式创建<strong>字符串对象</strong>时，JVM 会先对这个字符串进行检查，如果字符串常量池中存在相同内容的字符串对象的引用，则将这个引用返回；否则，创建新的字符串对象，然后将这个引用放入字符串常量池，并返回该引用。这种机制，就是<strong>字符串驻留或池化</strong>。</p></blockquote><ul><li><p>第一个案例返回 true，因为 Java 的字符串<strong>驻留机制</strong>，直接使用双引号声明出来的两个 String 对象指向<strong>常量池</strong>中的相同字符串。</p></li><li><p>第二个案例，new 出来的两个 String 是不同对象，引用当然不同，所以得到 false 的结果。</p></li><li><p>第三个案例，使用 String 提供的 intern 方法也会<strong>走常量池机制</strong>，所以同样能得到 true。</p></li><li><p>第四个案例，通过 equals 对值内容判等，是正确的处理方式，当然会得到 true。</p></li></ul><p><em>虽然使用 new 声明的字符串调用 intern 方法，也可以让字符串进行驻留，但在业务代码中滥用 intern，可能会产生性能问题。</em></p><p><strong>原因</strong>在于：字符串常量池是一个固定容量的 <strong>Map</strong>。如果容量太小（Number of buckets&#x3D;60013）、字符串太多（1000 万个字符串），那么每一个桶中的字符串数量会非常多，所以搜索起来就很慢。</p><p><strong>解决方法</strong>是：设置 JVM 参数 -XX:StringTableSize&#x3D;10000000，指定更多的桶。</p><h3 id="实现-equals"><a href="#实现-equals" class="headerlink" title="实现 equals"></a>实现 equals</h3><p>Object 类源码里 equals 的实现其实是比较对象引用</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">equals</span><span class="hljs-params">(Object obj)</span> &#123;<br>    <span class="hljs-keyword">return</span> (<span class="hljs-built_in">this</span> == obj);<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>对于自定义类型，如果不覆写 equals 的话，默认就是使用 Object 基类的按引用的比较方式。</strong></p><p>实现一个更好的 equals 应该注意的点：</p><ul><li>考虑到性能，可以先进行指针判等，如果对象是同一个那么直接返回 true；</li><li>需要对另一方进行判空，空对象和自身进行比较，结果一定是 fasle；</li><li>需要判断两个对象的类型，如果类型都不同，那么直接返回 false；</li><li>确保类型相同的情况下再进行类型强制转换，然后逐一判断所有字段。</li></ul><p>自定义 equals 示例</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 自定义类</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Point</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> x;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> y;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> String desc;<br>&#125;<br><br><span class="hljs-comment">// 自定义equals：</span><br><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">equals</span><span class="hljs-params">(Object o)</span> &#123;<br>    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">this</span> == o) <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    <span class="hljs-keyword">if</span> (o == <span class="hljs-literal">null</span> || getClass() != o.getClass()) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    <span class="hljs-type">Point</span> <span class="hljs-variable">that</span> <span class="hljs-operator">=</span> (Point) o;<br>    <span class="hljs-keyword">return</span> x == that.x &amp;&amp; y == that.y;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="数值计算"><a href="#数值计算" class="headerlink" title="数值计算"></a>数值计算</h2><h3 id="浮点数计算问题"><a href="#浮点数计算问题" class="headerlink" title="浮点数计算问题"></a>浮点数计算问题</h3><p>计算机是把数值保存在了变量中，不同类型的数值变量能保存的数值范围不同，当数值超过类型能表达的数值上限则会发生溢出问题。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java">System.out.println(<span class="hljs-number">0.1</span> + <span class="hljs-number">0.2</span>); <span class="hljs-comment">// 0.30000000000000004</span><br>System.out.println(<span class="hljs-number">1.0</span> - <span class="hljs-number">0.8</span>); <span class="hljs-comment">// 0.19999999999999996</span><br>System.out.println(<span class="hljs-number">4.015</span> * <span class="hljs-number">100</span>); <span class="hljs-comment">// 401.49999999999994</span><br>System.out.println(<span class="hljs-number">123.3</span> / <span class="hljs-number">100</span>); <span class="hljs-comment">// 1.2329999999999999</span><br><span class="hljs-type">double</span> <span class="hljs-variable">amount1</span> <span class="hljs-operator">=</span> <span class="hljs-number">2.15</span>;<br><span class="hljs-type">double</span> <span class="hljs-variable">amount2</span> <span class="hljs-operator">=</span> <span class="hljs-number">1.10</span>;<br>System.out.println(amount1 - amount2); <span class="hljs-comment">// 1.0499999999999998</span><br></code></pre></td></tr></table></figure><p>出现上述结果的原因是，计算机以<strong>二进制</strong>存储数值，，浮点数也不例外。比如，0.1 的二进制表示为 0.0 0011 0011 0011… （0011 无限循环)，再转换为十进制就是 0.1000000000000000055511151231257827021181583404541015625。对于计算机而言，0.1 无法精确表达，这是浮点数计算造成精度损失的根源。</p><h3 id="使用-BigDecimal"><a href="#使用-BigDecimal" class="headerlink" title="使用 BigDecimal"></a>使用 BigDecimal</h3><p>BigDecimal 是不可变的，可以用来表示任意精度的带符号十进制数。double 的问题是从小数点转换到二进制丢失精度，二进制丢失精度。BigDecimal 在处理的时候把十进制小数扩大 N 倍让它在整数上进行计算，并保留相应的精度信息。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">BigDecimal</span> <span class="hljs-variable">bigDecimal</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">BigDecimal</span>(<span class="hljs-number">0.1</span>);<br>System.out.println(<span class="hljs-string">&quot;bigDecimal值为: &quot;</span> + bigDecimal);<br><span class="hljs-comment">//输出  0.1000000000000000055511151231257827021181583404541015625</span><br><br>System.out.println(String.format(<span class="hljs-string">&quot;%.1f&quot;</span>, bigDecimal)); <span class="hljs-comment">// 0.1</span><br></code></pre></td></tr></table></figure><p>参数类型为 double 的构造方法的结果有一定的<strong>不可预知性</strong>，需要通过格式化输出！</p><p><u><strong>推荐使用字符串为形参传入构造函数</strong></u></p><ul><li><p>String 类型参的构造方法是<strong>完全可预知的</strong>。比如 new BigDecimal(“0.1”) 将创建一个 BigDecimal 对象，它正好等于预期的 0.1。因此优先使用 String 构造方法。</p></li><li><p>当是形参为浮点数时，推荐先将<strong>浮点数转换为字符串类型</strong>然后放入构造函数中。例如:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">BigDecimal</span> <span class="hljs-variable">bigDecimal</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">BigDecimal</span>(Double.toString(<span class="hljs-number">2.1</span>));<br><span class="hljs-comment">/* 或者 */</span><br><span class="hljs-type">BigDecimal</span> <span class="hljs-variable">bigDecimal1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">BigDecimal</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Double</span>(<span class="hljs-number">2.1</span>).toString());<br></code></pre></td></tr></table></figure></li></ul><h3 id="BigDecimal-判等问题"><a href="#BigDecimal-判等问题" class="headerlink" title="BigDecimal 判等问题"></a>BigDecimal 判等问题</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">wrong</span><span class="hljs-params">()</span> &#123;<br>    System.out.println(<span class="hljs-keyword">new</span> <span class="hljs-title class_">BigDecimal</span>(<span class="hljs-string">&quot;1.0&quot;</span>).equals(<span class="hljs-keyword">new</span> <span class="hljs-title class_">BigDecimal</span>(<span class="hljs-string">&quot;1&quot;</span>))); <span class="hljs-comment">//false</span><br>&#125;<br><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">right</span><span class="hljs-params">()</span> &#123;<br>    System.out.println(<span class="hljs-keyword">new</span> <span class="hljs-title class_">BigDecimal</span>(<span class="hljs-string">&quot;1.0&quot;</span>).compareTo(<span class="hljs-keyword">new</span> <span class="hljs-title class_">BigDecimal</span>(<span class="hljs-string">&quot;1&quot;</span>)) == <span class="hljs-number">0</span>); <span class="hljs-comment">//true</span><br>&#125;<br></code></pre></td></tr></table></figure><p>BigDecimal 的 equals 方法的注释中说明了原因，equals 比较的是 BigDecimal 的 value 和 scale，1.0 的 scale 是 1，1 的 scale 是 0，所以结果一定是 false。</p><p><strong>如果只比较 BigDecimal 的 value，可以使用 compareTo 方法</strong>。</p>]]></content>
    
    
    <categories>
      
      <category>JavaSE</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java</tag>
      
      <tag>数据类型</tag>
      
      <tag>值类型</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>webserver 知识点</title>
    <link href="/webserver%E5%AD%A6%E4%B9%A0.html"/>
    <url>/webserver%E5%AD%A6%E4%B9%A0.html</url>
    
    <content type="html"><![CDATA[<p>在学习开源轻量级 web 服务器 <a href="https://github.com/qinguoyi/TinyWebServer/tree/master">TinyWebServer</a> 过程中，总结记录的相关知识点。</p><span id="more"></span><h2 id="五种-I-x2F-O-模型"><a href="#五种-I-x2F-O-模型" class="headerlink" title="五种 I&#x2F;O 模型"></a>五种 I&#x2F;O 模型</h2><ul><li><strong>阻塞 IO</strong>:调用者调用了某个函数，等待这个函数返回，期间什么也不做，不停的去检查这个函数有没有返回，必须等这个函数返回才能进行下一步动作</li><li><strong>非阻塞 IO</strong>:非阻塞等待，每隔一段时间就去检测 IO 事件是否就绪。没有就绪就可以做其他事。非阻塞 I&#x2F;O 执行系统调用总是立即返回，不管时间是否已经发生，若时间没有发生，则返回-1，此时可以根据 errno 区分这两种情况，对于 accept，recv 和 send，事件未发生时，errno 通常被设置成 eagain</li><li><strong>信号驱动 IO</strong>:linux 用套接口进行信号驱动 IO，安装一个信号处理函数，进程继续运行并不阻塞，当 IO 时间就绪，进程收到 SIGIO 信号。然后处理 IO 事件。</li><li><strong>IO 复用</strong>:linux 用 select&#x2F;poll 函数实现 IO 复用模型，这两个函数也会使进程阻塞，但是和阻塞 IO 所不同的是这两个函数可以同时阻塞多个 IO 操作。而且可以同时对多个读操作、写操作的 IO 函数进行检测。知道有数据可读或可写时，才真正调用 IO 操作函数</li><li><strong>异步 IO</strong>:linux 中，可以调用 aio_read 函数告诉内核描述字缓冲区指针和缓冲区的大小、文件偏移及通知的方式，然后立即返回，当内核将数据拷贝到缓冲区后，再通知应用程序。</li></ul><p>注意：阻塞 I&#x2F;O，非阻塞 I&#x2F;O，信号驱动 I&#x2F;O 和 I&#x2F;O 复用都是同步 I&#x2F;O。同步 I&#x2F;O 指内核向应用程序通知的是就绪事件，比如只通知有客户端连接，要求用户代码自行执行 I&#x2F;O 操作，异步 I&#x2F;O 是指内核向应用程序通知的是完成事件，比如读取客户端的数据后才通知应用程序，由内核完成 I&#x2F;O 操作。</p><h2 id="事件处理模式"><a href="#事件处理模式" class="headerlink" title="事件处理模式"></a>事件处理模式</h2><ul><li>reactor 模式中，主线程(<strong>I&#x2F;O 处理单元</strong>)只负责监听文件描述符上是否有事件发生，有的话立即通知工作线程(<strong>逻辑单元</strong> )，读写数据、接受新连接及处理客户请求均在工作线程中完成。通常由<strong>同步 I&#x2F;O</strong>实现。</li><li>proactor 模式中，主线程和内核负责处理读写数据、接受新连接等 I&#x2F;O 操作，工作线程仅负责业务逻辑，如处理客户请求。通常由<strong>异步 I&#x2F;O</strong>实现。</li></ul><h2 id="同步-I-x2F-O-模拟-proactor-模式"><a href="#同步-I-x2F-O-模拟-proactor-模式" class="headerlink" title="同步 I&#x2F;O 模拟 proactor 模式"></a>同步 I&#x2F;O 模拟 proactor 模式</h2><p>同步 I&#x2F;O 模型的工作流程如下（epoll_wait 为例）：</p><ul><li>主线程往 epoll 内核事件表注册 socket 上的读就绪事件。</li><li>主线程调用 epoll_wait 等待 socket 上有数据可读</li><li>当 socket 上有数据可读，epoll_wait 通知主线程,主线程从 socket 循环读取数据，直到没有更多数据可读，然后将读取到的数据封装成一个请求对象并插入请求队列。</li><li>睡眠在请求队列上某个工作线程被唤醒，它获得请求对象并处理客户请求，然后往 epoll 内核事件表中注册该 socket 上的写就绪事件</li><li>主线程调用 epoll_wait 等待 socket 可写。</li><li>当 socket 上有数据可写，epoll_wait 通知主线程。主线程往 socket 上写入服务器处理客户请求的结果。</li></ul><h2 id="并发编程模式"><a href="#并发编程模式" class="headerlink" title="并发编程模式"></a>并发编程模式</h2><p>并发编程方法的实现有多线程和多进程两种，但这里涉及的并发模式指 I&#x2F;O 处理单元与逻辑单元的协同完成任务的方法。</p><ul><li>半同步&#x2F;半异步模式</li><li>领导者&#x2F;追随者模式</li></ul><h2 id="半同步-x2F-半反应堆"><a href="#半同步-x2F-半反应堆" class="headerlink" title="半同步&#x2F;半反应堆"></a>半同步&#x2F;半反应堆</h2><p>半同步&#x2F;半反应堆并发模式是半同步&#x2F;半异步的变体，将半异步具体化为某种事件处理模式。</p><p><strong>并发模式中的同步和异步：</strong></p><ul><li>同步指的是程序完全按照代码序列的顺序执行</li><li>异步指的是程序的执行需要由系统事件驱动</li></ul><p><strong>半同步&#x2F;半异步模式工作流程</strong>:</p><ul><li>同步线程用于处理客户逻辑</li><li>异步线程用于处理 I&#x2F;O 事件</li><li>异步线程监听到客户请求后，就将其封装成请求对象并插入请求队列中</li><li>请求队列将通知某个工作在同步模式的工作线程来读取并处理该请求对象</li></ul><p><strong>半同步&#x2F;半反应堆工作流程（以 Proactor 模式为例）</strong></p><ul><li>主线程充当异步线程，负责监听所有 socket 上的事件</li><li>若有新请求到来，主线程接收之以得到新的连接 socket，然后往 epoll 内核事件表中注册该 socket 上的读写事件</li><li>如果连接 socket 上有读写事件发生，主线程从 socket 上接收数据，并将数据封装成请求对象插入到请求队列中</li><li>所有工作线程睡眠在请求队列上，当有任务到来时，通过竞争（如互斥锁）获得任务的接管权</li></ul><h2 id="线程池"><a href="#线程池" class="headerlink" title="线程池"></a>线程池</h2><ul><li>空间换时间,浪费服务器的硬件资源,换取运行效率.</li><li>池是一组资源的集合,这组资源在服务器启动之初就被完全创建好并初始化,这称为静态资源.</li><li>当服务器进入正式运行阶段,开始处理客户请求的时候,如果它需要相关的资源,可以直接从池中获取,无需动态分配.</li><li>当服务器处理完一个客户连接后,可以把相关的资源放回池中,无需执行系统调用释放资源.</li></ul><h2 id="select-x2F-poll-x2F-epoll"><a href="#select-x2F-poll-x2F-epoll" class="headerlink" title="select&#x2F;poll&#x2F;epoll"></a><strong>select&#x2F;poll&#x2F;epoll</strong></h2><ul><li><p>调用函数</p></li><li><ul><li>select 和 poll 都是一个函数，epoll 是一组函数</li></ul></li><li><p>文件描述符数量</p></li><li><ul><li>select 通过线性表描述文件描述符集合，文件描述符有上限，一般是 1024，但可以修改源码，重新编译内核，不推荐</li><li>poll 是链表描述，突破了文件描述符上限，最大可以打开文件的数目</li><li>epoll 通过红黑树描述，最大可以打开文件的数目，可以通过命令 ulimit -n number 修改，仅对当前终端有效</li></ul></li><li><p>将文件描述符从用户传给内核</p></li><li><ul><li>select 和 poll 通过将所有文件描述符拷贝到内核态，每次调用都需要拷贝</li><li>epoll 通过 epoll_create 建立一棵红黑树，通过 epoll_ctl 将要监听的文件描述符注册到红黑树上</li></ul></li><li><p>内核判断就绪的文件描述符</p></li><li><ul><li>select 和 poll 通过遍历文件描述符集合，判断哪个文件描述符上有事件发生</li><li>epoll_create 时，内核除了帮我们在 epoll 文件系统里建了个红黑树用于存储以后 epoll_ctl 传来的 fd 外，还会再建立一个 list 链表，用于存储准备就绪的事件，当 epoll_wait 调用时，仅仅观察这个 list 链表里有没有数据即可。</li><li>epoll 是根据每个 fd 上面的回调函数(中断函数)判断，只有发生了事件的 socket 才会主动的去调用 callback 函数，其他空闲状态 socket 则不会，若是就绪事件，插入 list</li></ul></li><li><p>应用程序索引就绪文件描述符</p></li><li><ul><li>select&#x2F;poll 只返回发生了事件的文件描述符的个数，若知道是哪个发生了事件，同样需要遍历</li><li>epoll 返回的发生了事件的个数和结构体数组，结构体包含 socket 的信息，因此直接处理返回的数组即可</li></ul></li><li><p>工作模式</p></li><li><ul><li>select 和 poll 都只能工作在相对低效的 LT 模式下</li><li>epoll 则可以工作在 ET 高效模式，并且 epoll 还支持 EPOLLONESHOT 事件，该事件能进一步减少可读、可写和异常事件被触发的次数。</li></ul></li><li><p>应用场景</p></li><li><ul><li>当所有的 fd 都是活跃连接，使用 epoll，需要建立文件系统，红黑书和链表对于此来说，效率反而不高，不如 selece 和 poll</li><li>当监测的 fd 数目较小，且各个 fd 都比较活跃，建议使用 select 或者 poll</li><li>当监测的 fd 数目非常大，成千上万，且单位时间只有其中的一部分 fd 处于就绪状态，这个时候使用 epoll 能够明显提升性能</li></ul></li></ul><h2 id="ET、LT、EPOLLONESHOT"><a href="#ET、LT、EPOLLONESHOT" class="headerlink" title="ET、LT、EPOLLONESHOT"></a>ET、LT、EPOLLONESHOT</h2><ul><li><p>LT 水平触发模式</p></li><li><ul><li>epoll_wait 检测到文件描述符有事件发生，则将其通知给应用程序，应用程序可以不立即处理该事件。</li><li>当下一次调用 epoll_wait 时，epoll_wait 还会再次向应用程序报告此事件，直至被处理</li></ul></li><li><p>ET 边缘触发模式</p></li><li><ul><li>epoll_wait 检测到文件描述符有事件发生，则将其通知给应用程序，应用程序必须立即处理该事件</li><li>必须要一次性将数据读取完，使用非阻塞 I&#x2F;O，读取到出现 eagain</li></ul></li><li><p>EPOLLONESHOT</p></li><li><ul><li>一个线程读取某个 socket 上的数据后开始处理数据，在处理过程中该 socket 上又有新数据可读，此时另一个线程被唤醒读取，此时出现两个线程处理同一个 socket</li><li>我们期望的是一个 socket 连接在任一时刻都只被一个线程处理，通过 epoll_ctl 对该文件描述符注册 epolloneshot 事件，一个线程处理 socket 时，其他线程将无法处理，<strong>当该线程处理完后，需要通过 epoll_ctl 重置 epolloneshot 事件</strong></li></ul></li></ul>]]></content>
    
    
    <categories>
      
      <category>知识储备</category>
      
    </categories>
    
    
    <tags>
      
      <tag>webserver</tag>
      
      <tag>linux</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>cpp 刷题笔记</title>
    <link href="/cpp%E5%88%B7%E9%A2%98%E7%AC%94%E8%AE%B0.html"/>
    <url>/cpp%E5%88%B7%E9%A2%98%E7%AC%94%E8%AE%B0.html</url>
    
    <content type="html"><![CDATA[<p>刷代码随想录过程中记得笔记。</p><span id="more"></span><h3 id="常用函数"><a href="#常用函数" class="headerlink" title="常用函数"></a>常用函数</h3><ul><li><p>在<code>sort</code>中使用 lambda 表示式：<code>sort(arr.begin(), arr.end(), [](int a, int b)-&gt;bool &#123;return a &gt; b; &#125;);</code>。</p></li><li><p><code>s = s1.substr(pos, len)</code>从 pos 位置开始，长度为 len 的子串。</p></li><li><p><code>str[i] = tolower(str[i]);</code>大写字母转小写，<code>str[i] = toupper(str[i]);</code>小写字母转大写。</p></li><li><p><code>bool binary_search(arr.begin(), arrr.end(), 3)</code>返回 <strong>bool</strong>。</p></li><li><p>getline 按逗号分割字符串：</p></li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs cpp">vector&lt;string&gt; strs;<br><span class="hljs-function">stringstream <span class="hljs-title">ss</span><span class="hljs-params">(line)</span></span>;<br>string str;<br><span class="hljs-keyword">while</span> (<span class="hljs-built_in">getline</span>(ss, str, <span class="hljs-string">&#x27;,&#x27;</span>)) &#123;<br>     strs.<span class="hljs-built_in">push_back</span>(str);<br>&#125;<br></code></pre></td></tr></table></figure><ul><li><p>把 “ab” 换成 “####”：<code>str=str.replace(str.find(&quot;a&quot;),2,&quot;####&quot;);</code></p></li><li><p>有序列表中二分查找 <code>lower_bound (begin, last, val, compare)</code> 找到<mark>大于等于 val</mark>的位置，<code>upper_bound (begin, last, val, compare)</code>找到<mark>大于 val</mark>的位置。</p></li><li><p><code>uique (begin,last)</code> 左闭右开区间。</p></li><li><p><code>string.erase(pos)</code> <code>string.erase(first, last)</code>通过迭代器删除元素。</p></li><li><p><strong>remove 和 rease 搭配删除所有指定值，remove 将元素移到末尾，没有改变 size</strong>：</p></li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs cpp">vector&lt;<span class="hljs-type">int</span>&gt; vec = &#123; <span class="hljs-number">1</span>,<span class="hljs-number">1</span>,<span class="hljs-number">1</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>,<span class="hljs-number">6</span>,<span class="hljs-number">7</span>,<span class="hljs-number">8</span>&#125;;<br>vec.<span class="hljs-built_in">erase</span>(<span class="hljs-built_in">remove</span>(vec.<span class="hljs-built_in">begin</span>(), vec.<span class="hljs-built_in">end</span>(), <span class="hljs-number">1</span>), vec.<span class="hljs-built_in">end</span>());<br><span class="hljs-comment">// vec = &#123;3,4,5,6,7,8&#125;</span><br></code></pre></td></tr></table></figure><ul><li><p><code>nth_element(begin, last, nth, comp)</code>默认升序排列，找到第 nth 大的元素，移到第 nth 的位置。</p></li><li><p>利用 bitset 进行任意进制转二进制：</p></li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// stol() 第二个参数默认为 NULL，第三个默认 10 进制，可 8/16 进制</span><br><span class="hljs-function">bitset&lt;16&gt; <span class="hljs-title">bin</span><span class="hljs-params">(stol(t, <span class="hljs-literal">nullptr</span>, <span class="hljs-number">16</span>))</span></span>;   先转为 <span class="hljs-type">long</span>，通过 bitset 转为二进制 <span class="hljs-number">16</span> 位<br>string s = bin.<span class="hljs-built_in">to_string</span>();<br></code></pre></td></tr></table></figure><h3 id="ACM-模式输入输出"><a href="#ACM-模式输入输出" class="headerlink" title="ACM 模式输入输出"></a>ACM 模式输入输出</h3><ul><li><p>用 while 循环读取字符串时，输入<code>Ctrl+X</code>标志终止输入。</p></li><li><p><code>#include &lt;bits/stdc++.h&gt;</code>，万能头文件。</p></li><li><p><code>using namespace std;</code>，定义域名空间。</p></li><li><p><code>while (getchar() != &#39;\n&#39;) &#123; 判断换行符号&#125;</code>，<strong>读取一行内任意个数元素</strong>。</p></li><li><p><code>getchar()</code>，从缓冲区取一个字符，缓冲区少一个字符。</p></li></ul><h3 id="List"><a href="#List" class="headerlink" title="List"></a>List</h3><ul><li><p>list 的成员函数 remove, erase, pop_front, pop_back, clear 自动释放元素内存空间，同时元素迭代器失效。</p></li><li><p>删除某个元素，仅仅会删除元素的迭代器失效。插入、删除元素不会对其他元素造成影响。</p></li></ul><h3 id="二分法"><a href="#二分法" class="headerlink" title="二分法"></a>二分法</h3><p>注意<code>while (left &lt;= right)</code>取<strong>等号</strong>，查找值是否存在。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">search</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums, <span class="hljs-type">int</span> target)</span> </span>&#123;<br>    <span class="hljs-type">int</span> left = <span class="hljs-number">0</span>;<br>    <span class="hljs-type">int</span> right = nums.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>; <span class="hljs-comment">// 定义 target 在左闭右闭的间里，[left, right]</span><br>    <span class="hljs-keyword">while</span> (left &lt;= right) &#123; <span class="hljs-comment">// 当 left==right，区间 [left, right] 依然有效，所以用 &lt;=</span><br>        <span class="hljs-type">int</span> mid = left + ((right - left) / <span class="hljs-number">2</span>); <span class="hljs-comment">// 防止溢出 等同于 (left + right)/2</span><br>        <span class="hljs-keyword">if</span> (nums[mid] &gt; target) right = middle - <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (nums[mid] &lt; target) left = middle + <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">return</span> mid;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h3><p>注意<code>while (left &lt; right)</code>，交换左右元素，至少有<strong>两个</strong>元素，才能交换，因此不能取等号。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">partition</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums, <span class="hljs-type">int</span> left, <span class="hljs-type">int</span> right)</span> </span>&#123;<br>        <span class="hljs-type">int</span> pivot = nums[left];<br>        <span class="hljs-keyword">while</span> (left &lt; right) &#123;<br>            <span class="hljs-keyword">while</span> (left &lt; right &amp;&amp; pivot &lt;= nums[right])    right--;<br>            nums[left] = nums[right];<br>            <span class="hljs-keyword">while</span> (left &lt; right &amp;&amp; pivot &gt;= nums[left])     left++;<br>            nums[right] = nums[left];<br>        &#125;<br>        nums[left] = pivot;<br>        <span class="hljs-keyword">return</span> left;<br>    &#125;<br><span class="hljs-comment">// 递归</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">quicksort</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums, <span class="hljs-type">int</span> left, <span class="hljs-type">int</span> right)</span> </span>&#123;<br>    <span class="hljs-type">int</span> pivot;<br>    <span class="hljs-keyword">if</span> (left &lt; right) &#123;<br>        pivot = <span class="hljs-built_in">partition</span>(nums, left, right);<br>        <span class="hljs-built_in">quicksort</span>(nums, left, pivot - <span class="hljs-number">1</span>);<br>        <span class="hljs-built_in">quicksort</span>(nums, pivot + <span class="hljs-number">1</span>, right);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>有重复元素时多加 ‘&#x3D;‘ ，<strong>多加不会出错</strong>。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">while</span> (left &lt; right &amp;&amp; pivot &lt;= nums[right])    right--;<br><span class="hljs-keyword">while</span> (left &lt; right &amp;&amp; pivot &gt;= nums[left])     left++;<br></code></pre></td></tr></table></figure><h3 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h3><ul><li><p><code>for (int i = 0; i &lt;= arr.size() - k; i += k)</code>，每次遍历 k 个元素，注意 <code>i&lt;=arr.size()-k</code>。</p></li><li><p><code>priority_queue&lt;int,vector&lt;int&gt;，less&lt;int&gt;&gt;</code>，第二个参数是存储容器，第三个是比较函数，默认<code>less&lt;int&gt;</code>大顶堆，自顶向下变小，<code>greater&lt;int&gt;</code>小顶堆，自顶向下变大。</p></li><li><p>求数组中三数之和（固定第一个，再用双指针），四数之和，<strong>先排序</strong>，方便后面剪枝。</p></li></ul><h3 id="链表"><a href="#链表" class="headerlink" title="链表"></a>链表</h3><ul><li>自定义链表结构：</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">ListNode</span> &#123;<br>    <span class="hljs-type">int</span> val;<br>    ListNode* next;<br>    <span class="hljs-built_in">ListNode</span>(<span class="hljs-type">int</span> val):<span class="hljs-built_in">val</span>(val), <span class="hljs-built_in">next</span>(<span class="hljs-literal">nullptr</span>)&#123;&#125;<br>&#125;;<br>ListNode* node = <span class="hljs-keyword">new</span> <span class="hljs-built_in">ListNode</span>(val);<br><br><span class="hljs-comment">//使用虚拟头节点</span><br>ListNode* dummyHead = <span class="hljs-keyword">new</span> <span class="hljs-built_in">ListNode</span>(<span class="hljs-number">0</span>);<br>dummyHead-&gt;next = head;<br>ListNode* cur = dummyHead;<br></code></pre></td></tr></table></figure><ul><li>定义指针数组（哈希）：</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs cpp">vector&lt;ListNode*&gt; vec;<br>ListNode* cur=head;<br><span class="hljs-keyword">while</span>(cur)&#123;<br>    vec.<span class="hljs-built_in">push_back</span>(cur);<br>    cur=cur-&gt;next;<br>&#125;<br></code></pre></td></tr></table></figure><p>应用：对链表每 K 个结点翻转，定义一个指针数组，对数组翻转，变相对链表操作。</p><h3 id="String"><a href="#String" class="headerlink" title="String"></a>String</h3><ul><li>双指针法判断<strong>回文</strong>：</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">countSubstrings</span><span class="hljs-params">(string s)</span> </span>&#123;<br>    <span class="hljs-type">int</span> result = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; s.<span class="hljs-built_in">size</span>(); i++) &#123;<br>        result += <span class="hljs-built_in">extend</span>(s, i, i); <span class="hljs-comment">// 以 i 为中心</span><br>        result += <span class="hljs-built_in">extend</span>(s, i, i + <span class="hljs-number">1</span>); <span class="hljs-comment">// 以 i 和 i+1 为中心</span><br>    &#125;<br>    <span class="hljs-keyword">return</span> result;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">extend</span><span class="hljs-params">(<span class="hljs-type">const</span> string&amp; s, <span class="hljs-type">int</span> i, <span class="hljs-type">int</span> j)</span> </span>&#123;<br>    <span class="hljs-type">int</span> res = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">while</span> (i &gt;= <span class="hljs-number">0</span> &amp;&amp; j &lt; s.<span class="hljs-built_in">size</span>() &amp;&amp; s[i] == s[j]) &#123;<br>        i--;<br>        j++;<br>        res++;<br>    &#125;<br>    <span class="hljs-keyword">return</span> res;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li><p><code>if(str.find(&quot;a&quot;) != -1)</code>返回结果是 <strong>-1</strong> 不是 end()。</p></li><li><p><code>s.substr(start,len)</code>，从 start 位置取长度为 len 的子串。</p></li><li><p>查找字符串 S 是否包含子串 sub，S+S 拼接破环头尾，判断<code>S.find(sub)</code>存在。</p></li><li><p><strong>stoll</strong>：string 型变量转换为 long long 型变量（常用），兼容 int long；<br><strong>stod</strong>：string 型变量转换为 double 型变量（常用），兼容 float。</p></li></ul><h3 id="优先队列（堆）"><a href="#优先队列（堆）" class="headerlink" title="优先队列（堆）"></a>优先队列（堆）</h3><ul><li><code>priority_queue&lt;int, vector&lt;int&gt;, cmp&gt; p_queue</code>默认底层容器 vector，默认大顶堆 less。</li><li>自定义比较函数 class：</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">cmp</span>&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">operator</span><span class="hljs-params">()</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp;a,vector&lt;<span class="hljs-type">int</span>&gt;&amp;b)</span></span>&#123;<br>        <span class="hljs-keyword">return</span> a[<span class="hljs-number">0</span>]&gt;b[<span class="hljs-number">0</span>];   小顶堆<br>    &#125;<br>&#125;;<br>priority_queue&lt;vector&lt;<span class="hljs-type">int</span>&gt;,vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt;,cmp&gt; q;<br></code></pre></td></tr></table></figure><ul><li>自定义比较结构体 struct:</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">cmp</span> &#123;<br>     <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">operator</span><span class="hljs-params">()</span><span class="hljs-params">(pair&lt;<span class="hljs-type">int</span>,<span class="hljs-type">int</span>&gt;&amp; a,pair&lt;<span class="hljs-type">int</span>,<span class="hljs-type">int</span>&gt;&amp; b)</span></span>&#123;<br>         <span class="hljs-keyword">return</span> a.second &gt; b.second;<br>    &#125;<br>&#125;;<br>priority_queue&lt;pair&lt;<span class="hljs-type">int</span>,<span class="hljs-type">int</span>&gt;, vector&lt;pair&lt;<span class="hljs-type">int</span>,<span class="hljs-type">int</span>&gt;&gt;, cmp&gt; q;<br></code></pre></td></tr></table></figure><ul><li>两种自定义比较函数，小顶堆，注意符号（默认大顶堆），第二个参数设置底层容器，必填，否则第三个参数不起作用。</li></ul><h3 id="二叉树"><a href="#二叉树" class="headerlink" title="二叉树"></a>二叉树</h3><ul><li>数据结构模板：</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">TreeNode</span> &#123;<br>    <span class="hljs-type">int</span> val;<br>    TreeNode *left;<br>    TreeNode *right;<br>    <span class="hljs-built_in">TreeNode</span>(<span class="hljs-type">int</span> x) : <span class="hljs-built_in">val</span>(x), <span class="hljs-built_in">left</span>(<span class="hljs-literal">nullptr</span>), <span class="hljs-built_in">right</span>(<span class="hljs-literal">nullptr</span>) &#123;&#125;<br>&#125;;<br></code></pre></td></tr></table></figure><ul><li>二叉树递归参数传值 val，切忌不要用引用 &amp;val，不能改变 val 值，<strong>方便回溯</strong>。</li><li>递归遍历函数是否需要返回值？<ul><li>若只要找到一条路径，不用全部遍历，则要返回值 bool。</li><li>若找到所有满足条件路径，要求全部遍历，则不需要返回值。</li></ul></li><li>递归返回<code>TreeNode*</code>，可以<code>return nullptr</code>。</li><li><strong>删除</strong>二叉树节点，<strong>增加</strong>二叉树节点，都是用<strong>递归函数的返回值</strong>来完成。</li><li>根据有序数组创建<strong>二叉搜索树</strong>，同时也是平衡树：</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function">TreeNode* <span class="hljs-title">createTree</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; vec,<span class="hljs-type">int</span> left,<span class="hljs-type">int</span> right)</span></span>&#123;<br>    <span class="hljs-keyword">if</span>(left &gt; right) <span class="hljs-keyword">return</span> <span class="hljs-literal">nullptr</span>;<br>    <span class="hljs-type">int</span> mid = (left+right)/<span class="hljs-number">2</span>;<br>    TreeNode* node = <span class="hljs-keyword">new</span> <span class="hljs-built_in">TreeNode</span>(vec[mid]);<br>    node-&gt;left = <span class="hljs-built_in">createTree</span>(vec,left,mid<span class="hljs-number">-1</span>);<br>    node-&gt;right = <span class="hljs-built_in">createTree</span>(vec,mid+<span class="hljs-number">1</span>,right);<br>    <span class="hljs-keyword">return</span> node;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>求公共最近公共邻居 leetcode.236：</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">TreeNode* <span class="hljs-title">lowestCommonAncestor</span><span class="hljs-params">(TreeNode* root, TreeNode* p, TreeNode* q)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (root == q || root == p || root == <span class="hljs-literal">NULL</span>) <span class="hljs-keyword">return</span> root;<br>        TreeNode* left = <span class="hljs-built_in">lowestCommonAncestor</span>(root-&gt;left, p, q);<br>        TreeNode* right = <span class="hljs-built_in">lowestCommonAncestor</span>(root-&gt;right, p, q);<br>        <span class="hljs-keyword">if</span> (left != <span class="hljs-literal">NULL</span> &amp;&amp; right != <span class="hljs-literal">NULL</span>) <span class="hljs-keyword">return</span> root;<br><br>        <span class="hljs-keyword">if</span> (left == <span class="hljs-literal">NULL</span> &amp;&amp; right != <span class="hljs-literal">NULL</span>) <span class="hljs-keyword">return</span> right;<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (left != <span class="hljs-literal">NULL</span> &amp;&amp; right == <span class="hljs-literal">NULL</span>) <span class="hljs-keyword">return</span> left;<br>        <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;<br>        &#125;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><ul><li><p>考虑设置 全局变量<code>public: TreeNode* pre</code>递归过程更新全局指针变量。</p></li><li><p><strong>递归一定看函数返回什么，指针？整数？，利用起来<code>root-&gt;left = deleteNode(root-&gt;left,key);</code>。</strong></p></li></ul><h3 id="回溯法"><a href="#回溯法" class="headerlink" title="回溯法"></a>回溯法</h3><ul><li><p><strong>关键词：返回所有可能方案。</strong></p></li><li><p><strong>回溯是递归的副产品，只要有递归就会有回溯。</strong></p></li><li><p>回溯法就是暴力搜索，并不是什么高效的算法，最多在剪枝一下（解决多层 for 循环）。</p></li><li><p>通用模板：</p></li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-type">void</span> backtracking（参数） &#123;<br>    <span class="hljs-keyword">if</span> （终止条件） &#123;<br>        存放结果；<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br>    <span class="hljs-keyword">for</span> （选择：本层集合中元素（树中节点孩子的数量就是集合的大小）) &#123;<br>        处理节点；<br>        backtracking（路径，选择列表）; <span class="hljs-comment">// 递归</span><br>        回溯，撤销处理结果！!!<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>在终止条件前加入剪枝，即进入递归后提前<code>return</code>：</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">private</span>:<br>    vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; result; <span class="hljs-comment">// 存放符合条件结果的集合</span><br>    vector&lt;<span class="hljs-type">int</span>&gt; path; <span class="hljs-comment">// 用来存放符合条件结果</span><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">backtracking</span><span class="hljs-params">(<span class="hljs-type">int</span> n, <span class="hljs-type">int</span> k, <span class="hljs-type">int</span> startIndex)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (path.<span class="hljs-built_in">size</span>() == k) &#123;<br>            result.<span class="hljs-built_in">push_back</span>(path);<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = startIndex; i &lt;= n; i++) &#123;<br>            path.<span class="hljs-built_in">push_back</span>(i); <span class="hljs-comment">// 处理节点</span><br>            <span class="hljs-built_in">backtracking</span>(n, k, i + <span class="hljs-number">1</span>);   <span class="hljs-comment">//注意 传 i+1, 不是 startIndex</span><br>            path.<span class="hljs-built_in">pop_back</span>(); <span class="hljs-comment">// 回溯，撤销处理的节点</span><br>        &#125;<br>    &#125;<br><span class="hljs-keyword">public</span>:<br>    vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">combine</span>(<span class="hljs-type">int</span> n, <span class="hljs-type">int</span> k) &#123;<br>        result.<span class="hljs-built_in">clear</span>();<br>        path.<span class="hljs-built_in">clear</span>();<br>        <span class="hljs-built_in">backtracking</span>(n, k, <span class="hljs-number">1</span>);<br>        <span class="hljs-keyword">return</span> result;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><ul><li><p>经典组合题，注意<code>backtracking(n, k, i + 1)</code>; 传 <strong>i+1</strong>, 回溯部分<code>path.pop_back()</code>以及相应处理。</p></li><li><p>善用<code>used[]</code>，标记已访问的元素。</p></li><li><p>全组合用<code>startIndex</code>（无顺序且组合不能重复）;</p><p>全排列<strong>不需要</strong><code>startIndex</code>，而是用<code>used[ ]</code>（有顺序且同一元素不能重复选取）。</p></li><li><p><strong>对于结果有重复子集，需去重，则先排序，通过判断相邻结点是否重复使用过。</strong></p></li><li><p><code>if (i &gt; 0 &amp;&amp; nums[i] == nums[i - 1] &amp;&amp; used[i - 1] == false) continue;</code>, 先排序，对于{1, 1, 2}, <code>used[0]=false</code>表示同一数层上 n[0] 已被用过，而 n[0]&#x3D;&#x3D;n[1]，所以跳过；对于<code>used[0]=true</code>，表示 n[0] 在<strong>上一层</strong>，同一条树枝上，不在同一层，可重复使用。</p></li><li><p>经典排列题，含去重：</p></li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">private</span>:<br>    vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; result;<br>    vector&lt;<span class="hljs-type">int</span>&gt; path;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">backtracking</span> <span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums, vector&lt;<span class="hljs-type">bool</span>&gt;&amp; used)</span> </span>&#123;<br>        <span class="hljs-comment">// 此时说明找到了一组</span><br>        <span class="hljs-keyword">if</span> (path.<span class="hljs-built_in">size</span>() == nums.<span class="hljs-built_in">size</span>()) &#123;<br>            result.<span class="hljs-built_in">push_back</span>(path);<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; nums.<span class="hljs-built_in">size</span>(); i++) &#123;<br>            <span class="hljs-comment">// used[i - 1] == true，说明同一树枝 nums[i - 1] 使用过</span><br>            <span class="hljs-comment">// used[i - 1] == false，说明同一树层 nums[i - 1] 使用过</span><br>            <span class="hljs-comment">// 如果同一树层 nums[i - 1] 使用过则直接跳过</span><br>            <span class="hljs-keyword">if</span> (i &gt; <span class="hljs-number">0</span> &amp;&amp; nums[i] == nums[i - <span class="hljs-number">1</span>] &amp;&amp; used[i - <span class="hljs-number">1</span>] == <span class="hljs-literal">false</span>) &#123;<br>                <span class="hljs-keyword">continue</span>;<br>            &#125;<br>            <span class="hljs-comment">//if ( used[i] == true ) continue;</span><br>            <span class="hljs-keyword">if</span> (used[i] == <span class="hljs-literal">false</span>) &#123;<br>                used[i] = <span class="hljs-literal">true</span>;<br>                path.<span class="hljs-built_in">push_back</span>(nums[i]);<br>                <span class="hljs-built_in">backtracking</span>(nums, used);<br>                path.<span class="hljs-built_in">pop_back</span>();<br>                used[i] = <span class="hljs-literal">false</span>;<br>            &#125;<br>        &#125;<br>    &#125;<br><span class="hljs-keyword">public</span>:<br>    vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">permuteUnique</span>(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums) &#123;<br>        result.<span class="hljs-built_in">clear</span>();<br>        path.<span class="hljs-built_in">clear</span>();<br>        <span class="hljs-built_in">sort</span>(nums.<span class="hljs-built_in">begin</span>(), nums.<span class="hljs-built_in">end</span>()); <span class="hljs-comment">// 排序</span><br>        <span class="hljs-function">vector&lt;<span class="hljs-type">bool</span>&gt; <span class="hljs-title">used</span><span class="hljs-params">(nums.size(), <span class="hljs-literal">false</span>)</span></span>;<br>        <span class="hljs-built_in">backtracking</span>(nums, used);<br>        <span class="hljs-keyword">return</span> result;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><ul><li><p><code>if (used[i] == false) &#123; ... &#125;</code>，记住前提条件，<strong>上一层已选过，就不考虑啦</strong>，或者改为<code>if (used[i] == true) continue;</code>。</p></li><li><p>递归和回溯：<br>1）要遍历所有元素找全部结果，函数 void 无返回值。<br>2）只要找到一条路径&#x2F;结果，函数有返回值 bool（同二叉树）。</p></li></ul><h3 id="贪心算法"><a href="#贪心算法" class="headerlink" title="贪心算法"></a>贪心算法</h3><ul><li><p>贪心的本质是选择每一阶段的局部最优，从而达到全局最优。</p></li><li><p><strong>提前排序给定数组！降低难度！</strong></p></li><li><p>加关键词 static 才能在 sort 使用 cmp 函数，sort 要求 cmp 函数为 static，或者声明类外作为全局函数。</p></li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">static</span> <span class="hljs-type">bool</span> <span class="hljs-title">cmp</span><span class="hljs-params">(<span class="hljs-type">int</span> a,<span class="hljs-type">int</span> b)</span></span>&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">abs</span>(a) &gt; <span class="hljs-built_in">abs</span>(b);<br>&#125;<br><span class="hljs-built_in">sort</span>(nums.<span class="hljs-built_in">begin</span>(),nums.<span class="hljs-built_in">end</span>(),cmp);<br></code></pre></td></tr></table></figure><ul><li><strong>左右排序两次问题，区间问题，或数组中当前元素与左右元素比较时</strong>，先顺序遍历，在逆序遍历，两次遍历不能同时兼顾左右（lc.135），换句话说，遇到两个维度权衡的时候，一定要先确定一个维度，再确定另一个维度。</li></ul><h3 id="动态规划"><a href="#动态规划" class="headerlink" title="动态规划"></a>动态规划</h3><blockquote><ol><li><p>确定 dp 数组以及下标的含义</p></li><li><p>确定递推公式</p></li><li><p>dp 数组如何初始化</p></li><li><p>确定遍历顺序</p></li><li><p>举例推导 dp 数组</p></li></ol></blockquote><p><strong>debug 最好方式就是把 dp 数组打印出来，看看究竟是不是按照自己思路推导的！</strong></p><p>dp 初始化后，遍历数组考虑初始值，避免越界。</p><h3 id="经典01背包问题"><a href="#经典01背包问题" class="headerlink" title="经典01背包问题"></a>经典01背包问题</h3><ul><li><p>每个物品只能放入一次。</p></li><li><p>外层遍历物品，<strong>内层遍历容量</strong>。</p></li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// 二维数组</span><br>vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">dp</span>(weight.<span class="hljs-built_in">size</span>(), <span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">int</span>&gt;(bagweight + <span class="hljs-number">1</span>, <span class="hljs-number">0</span>));<br><span class="hljs-comment">// 初始化</span><br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = weight[<span class="hljs-number">0</span>]; j &lt;= bagweight; j++) &#123;<br>    dp[<span class="hljs-number">0</span>][j] = value[<span class="hljs-number">0</span>];<br>&#125;<br><span class="hljs-comment">// weight 数组的大小 就是物品个数</span><br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt; weight.<span class="hljs-built_in">size</span>(); i++) &#123; <span class="hljs-comment">// 遍历物品</span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt;= bagweight; j++) &#123; <span class="hljs-comment">// 遍历背包容量</span><br>        放不下 i 重量<br>        <span class="hljs-keyword">if</span> (j &lt; weight[i]) dp[i][j] = dp[i - <span class="hljs-number">1</span>][j];<br>        <span class="hljs-keyword">else</span> dp[i][j] = <span class="hljs-built_in">max</span>(dp[i - <span class="hljs-number">1</span>][j], dp[i - <span class="hljs-number">1</span>][j - weight[i]] + value[i]);<br>    &#125;<br>&#125;<br>cout &lt;&lt; dp[weight.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>][bagweight] &lt;&lt; endl;<br></code></pre></td></tr></table></figure><ul><li><strong>滚动数组</strong>：降低空间复杂度。先正序遍历物品，在倒序遍历背包容量，dp[j] 表示：容量维 j 的背包，所背的物品价值最大为 dp[j]，<strong>倒序遍历是为了保证物品 i 只被放入一次！</strong></li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// 初始化</span><br><span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">dp</span><span class="hljs-params">(bagWeight + <span class="hljs-number">1</span>, <span class="hljs-number">0</span>)</span></span>;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; weight.<span class="hljs-built_in">size</span>(); i++) &#123; <span class="hljs-comment">// 遍历物品</span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = bagWeight; j &gt;= weight[i]; j--) &#123; <span class="hljs-comment">// 遍历背包容量</span><br>        dp[j] = <span class="hljs-built_in">max</span>(dp[j], dp[j - weight[i]] + value[i]);<br>    &#125;<br>&#125;<br>cout &lt;&lt; dp[bagWeight] &lt;&lt; endl;<br></code></pre></td></tr></table></figure><ul><li><p><code>dp[i]</code>表示不放物体，相当于<code>dp[i-1][j]</code>，不放物体 i，<code>dp[j - weight[i]] + value[i]</code>表示放物体 i，为放物体前容量的最大价值 + 物体 i 的价值。</p></li><li><p>为什么第二次循环<code>j&gt;=weight[i]</code>，因为<code>dp[j - weight[i]]</code>表示放物体前的容量，不能为负数，考虑能放下的情况，放还是不放；对于不能放下就默认等于上一次值，不考虑。</p></li><li><p>注意第二重<strong>循环 j 初始值</strong>，为 dp 容量最大值。</p></li></ul><h3 id="完全背包问题"><a href="#完全背包问题" class="headerlink" title="完全背包问题"></a>完全背包问题</h3><ul><li>每件物品无限件，可重复放入背包。</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// 先遍历物品，再遍历背包</span><br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; weight.<span class="hljs-built_in">size</span>(); i++) &#123; <span class="hljs-comment">// 遍历物品</span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = weight[i]; j &lt;= bagWeight ; j++) &#123; <span class="hljs-comment">// 遍历背包容量</span><br>        dp[j] = <span class="hljs-built_in">max</span>(dp[j], dp[j - weight[i]] + value[i]);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li><p><strong>内循环 从小到大遍历，因为每件物品添加多次</strong>。</p></li><li><p><strong>理解 内循环 dp[j]：每次容量为 j 的时候，所以后面内容都是考虑当前容量为 j</strong>。</p></li><li><p><strong>如果求<mark>组合数</mark>就是外层 for 循环遍历物品，内层 for 遍历背包</strong>。</p><p><strong>如果求<mark>排列数</mark>就是外层 for 遍历背包，内层 for 循环遍历物品</strong>。</p></li><li><p>滚动数组为了取代二维数组，但<strong>内循环一般是倒序</strong>的，防止重复选取。</p></li></ul><h3 id="求连续公共子序列"><a href="#求连续公共子序列" class="headerlink" title="求连续公共子序列"></a>求连续公共子序列</h3><ul><li><p><code>dp[i][j]</code>：以下标 <strong>i-1</strong> 为结尾的 A，和以下标 <strong>j-1</strong> 为结尾的 B，最长重复子数组<strong>长度</strong>为<code>dp[i][j]</code>。</p></li><li><p>求<strong>连续</strong>最长重复子数组：</p></li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">findLength</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums1, vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums2)</span> </span>&#123;<br>        vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">dp</span>(nums1.<span class="hljs-built_in">size</span>()+<span class="hljs-number">1</span>,<span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">int</span>&gt;(nums2.<span class="hljs-built_in">size</span>()+<span class="hljs-number">1</span>,<span class="hljs-number">0</span>));<br>        <span class="hljs-type">int</span> res = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i &lt;=nums1.<span class="hljs-built_in">size</span>();i++)&#123;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">1</span>;j&lt;=nums2.<span class="hljs-built_in">size</span>();j++)&#123;<br>                <span class="hljs-keyword">if</span>(nums1[i<span class="hljs-number">-1</span>] == nums2[j<span class="hljs-number">-1</span>])&#123;<br>                    dp[i][j] = dp[i<span class="hljs-number">-1</span>][j<span class="hljs-number">-1</span>]+<span class="hljs-number">1</span>;<br>                &#125;<br>                <span class="hljs-keyword">if</span>(dp[i][j] &gt; res) res = dp[i][j];<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><ul><li>求<strong>不连续</strong>公共子数组：</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">longestCommonSubsequence</span><span class="hljs-params">(string text1, string text2)</span> </span>&#123;<br>        vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">dp</span>(text1.<span class="hljs-built_in">size</span>()+<span class="hljs-number">1</span>,<span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">int</span>&gt;(text2.<span class="hljs-built_in">size</span>()+<span class="hljs-number">1</span>,<span class="hljs-number">0</span>));<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=text1.<span class="hljs-built_in">size</span>();i++)&#123;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">1</span>;j&lt;=text2.<span class="hljs-built_in">size</span>();j++)&#123;<br>                <span class="hljs-keyword">if</span>(text1[i<span class="hljs-number">-1</span>] == text2[j<span class="hljs-number">-1</span>])&#123;<br>                    dp[i][j] = dp[i<span class="hljs-number">-1</span>][j<span class="hljs-number">-1</span>] + <span class="hljs-number">1</span>;<br>                &#125;<span class="hljs-keyword">else</span>&#123;<br>                    dp[i][j] = <span class="hljs-built_in">max</span>(dp[i<span class="hljs-number">-1</span>][j],dp[i][j<span class="hljs-number">-1</span>]);<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> dp[text1.<span class="hljs-built_in">size</span>()][text2.<span class="hljs-built_in">size</span>()];<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><ul><li>思考<code>d[i][j]</code>是一个数，表示什么意思？公共长度？最多重复数量？最少删除次数？视情况而定。</li></ul><h3 id="单调栈"><a href="#单调栈" class="headerlink" title="单调栈"></a>单调栈</h3><ul><li><p><strong>要寻找任一个元素的右边或者左边第一个比自己大或者小的元素的位置。</strong></p></li><li><p>栈里只存递增或递减的 index，遇到逆序就弹出栈内元素，从而得到第一个大于或小于元素的 index。</p></li><li><p>设置两个数组，顺序和逆序遍历，得到左边&#x2F;右边最大数字：</p></li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// 记录每个柱子左边柱子最大高度</span><br>maxLeft[<span class="hljs-number">0</span>] = height[<span class="hljs-number">0</span>];<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt; size; i++) &#123;<br>    maxLeft[i] = <span class="hljs-built_in">max</span>(height[i], maxLeft[i - <span class="hljs-number">1</span>]);<br>&#125;<br><span class="hljs-comment">// 记录每个柱子右边柱子最大高度</span><br>maxRight[size - <span class="hljs-number">1</span>] = height[size - <span class="hljs-number">1</span>];<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = size - <span class="hljs-number">2</span>; i &gt;= <span class="hljs-number">0</span>; i--) &#123;<br>    maxRight[i] = <span class="hljs-built_in">max</span>(height[i], maxRight[i + <span class="hljs-number">1</span>]);<br>&#125;<br></code></pre></td></tr></table></figure><p>待续……</p>]]></content>
    
    
    <categories>
      
      <category>刷题笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>cpp</tag>
      
      <tag>note</tag>
      
      <tag>algorithm</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>论文笔记之 pSCAN</title>
    <link href="/pSCAN.html"/>
    <url>/pSCAN.html</url>
    
    <content type="html"><![CDATA[<p>pSCAN 研究了结构图聚类问题，这是图数据管理和分析的基本问题。给定一个无向无权图，结构图聚类就是将顶点分配给簇，并识别中心顶点和离群顶点的集合，使得同一簇中的顶点彼此紧密连接，而不同簇中的顶点松散连接。</p><span id="more"></span><blockquote><p>pSCAN: Fast and Exact Structural Graph Clustering.Lijun Chang, Wei Li, Lu Qin, Wenjie Zhang, and Shiyu Yang.</p></blockquote><h2 id="1-Contributions："><a href="#1-Contributions：" class="headerlink" title="1.Contributions："></a>1.Contributions：</h2><ul><li>作者证明了现有的 SCAN 算法在最坏情况下最优的。</li><li>作者对结构图聚类做了三个观察，提出了可扩展结的两步范式，减少结构相似性计算。</li><li>此外，作者提供了优化技术加速检查两个顶点是否结构相似。</li></ul><h2 id="2-Three-observations"><a href="#2-Three-observations" class="headerlink" title="2.Three observations:"></a>2.Three observations:</h2><ol><li>结构图聚类中的聚类可能存在重叠。</li><li>核顶点的集群不相交。</li><li>非核心顶点的簇由核心顶点唯一确定。</li></ol><h2 id="3-Definition"><a href="#3-Definition" class="headerlink" title="3.Definition:"></a>3.Definition:</h2><ul><li>顶点 u 的结构领域 N[u] 为 u 的闭领域，即：N[u] &#x3D; {v ∈ V|(u,v) ∈ E} ∪ {u}。</li><li>顶点 u 和 v 之间的结构相似性定义为：N[u]和 N[v]中共有顶点的数量按其基数的几个平均值归一化。</li><li>给定相似度阈值 0 &lt; $\epsilon$ &lt;&#x3D; 1 和一个整数 $\mu$ ≥ 2，一个顶点是核心顶点如果 $N_{eps}$[u] ≥ $\mu$。</li><li>集群 C 是 V 的一个子集，它至少有两个顶点，则：<ul><li>（最大化）如果核心顶点 u∈C，那么所欲有从 u 到结构可达的顶点 v 也属于 C。</li><li>（连通性）对于任意两个顶点 $v_1$,$v_2$ ∈ C，有顶点 u ∈ C，使得 $v_1$ 和 $v_2$ 都可以从 u 可达。</li></ul></li><li>给定聚类 C，C 中不属于任何集群的顶点 u，如果它的邻居属于两个或者两个以上的集群，则为 hub，否则为 outlier。</li></ul><h2 id="4-Two-step-Paradigm"><a href="#4-Two-step-Paradigm" class="headerlink" title="4.Two-step Paradigm:"></a>4.Two-step Paradigm:</h2><ul><li>step-1：<u>聚类核心顶点</u>，把所有核心顶点分类到对应簇。</li><li>step-2：<u>聚类非核心顶点</u>，是 non-core 且和邻点 core 相似，分到 core 的簇中。</li></ul><img src="https://cdn.jsdelivr.net/gh/gejoyy/Pictures@main/image-20230627152627744.png" alt="pscan-algorithm-2" style="zoom: 67%;" /><h2 id="5-Algorithm"><a href="#5-Algorithm" class="headerlink" title="5.Algorithm"></a>5.Algorithm</h2><h3 id="5-1-pSCAN"><a href="#5-1-pSCAN" class="headerlink" title="5.1 pSCAN"></a>5.1 pSCAN</h3><p>算法目标是减少结构相似性计算的次数，把边分为 $E_{c,c}$，$E_{c,n}$，分别讨论。</p><img src="https://cdn.jsdelivr.net/gh/gejoyy/Pictures@main/image-20230627153257747.png" alt="pscan-algorithm-3" style="zoom:67%;" /><ul><li>行 1，初始化每个顶点成单个子集。</li><li>行 2-4，初始化每个顶点 sd(u), ed(u)。</li><li>行 5-7，按有效度 ed(u) 非递增顺序遍历顶点 u，检测 u 是否为 core，如果 u 是 core，把 u 和已经确定为 core 的邻点聚类到一起。</li><li>行 8-9，得到 core 顶点聚类 $C_c$，再聚类 non-core 顶点集合。</li><li>用不相交数据结构(disjoint-set data) 聚类 $G_c$ 中的 core，形成多个不相交的集合 S &#x3D; {s1, s2,…}<ul><li>find-subset：查看元素在哪一个子集中。</li><li>union：合并两个子集。</li></ul></li><li>union(u, v) 相当于在 $G_c$ 中添加一条边(u, v)。</li><li>两个顶点 u，v 属于同一连接组件（聚类）当且仅当 u，v 所在的子集相同，即：find-subset(u) &#x3D; find-subset(v)。</li></ul><p><strong>effective-degree: ed(u)</strong></p><ul><li>目的：为了减少相似度计算，按 ed(u) <strong>非递增</strong>顺序排序顶点。</li><li>定义：|N[u]|减去与 u 不相似的邻点的数量，得到可能相似的邻点的数量，满足 |$N_{eps}[u]$| ≤ ed(u)，ed(u) 是上界。</li><li>如果 ed(u) ≤ $\mu$，上界小于 $\mu$，则 u 是 non-core，从而减少<strong>顶点对 $E_{n,n}$ 的计算次数</strong>，对两个 non-core 顶点，不用计算它们之间相似度。</li></ul><p><strong>similar-degree: sd(u)</strong></p><ul><li>目的：为了有效检查一个顶点是否为 core。</li><li>定义：sd(u) 是已经确定与 u 相似的邻居的数量，满足|$N_{eps}[u]$| ≥ sd(u)，sd(u) 是下界。</li><li>如果 sd(u) ≥ $\mu$，下界大于 $\mu$，则 u 是 core。</li></ul><h3 id="5-2-CheckCore"><a href="#5-2-CheckCore" class="headerlink" title="5.2 CheckCore"></a>5.2 CheckCore</h3><p>目的：检测一个顶点是否为 core，减少顶点对 $E_{n,n}$的计算。</p><img src="https://cdn.jsdelivr.net/gh/gejoyy/Pictures@main/image-20230627153654828.png" alt="pscan-algorithm-4" style="zoom:67%;" /><ul><li>行 1，对于 ed(u) &lt; $\mu$（确定为 non-core）和 sd(u) ≥ $\mu$（确定 core）两种情况无需讨论，因为 ed(u) ≥ sd(u)，所以讨论第三种情况，ed(u) ≥ $\mu$ &gt;sd(u)，需要计算 u 和其邻居的相似性，<strong>以检测 u 是否为core</strong>。</li><li>行 2，初始化 ed(u)，sd(u)。</li><li>行 3-6，计算相似度，然后更新 ed(u)，sd(u)。</li><li>行 7-9，如果邻点 v 还没有被探索，更新 ed(v)，sd(v)，如果 ed(u) &lt; $\mu$ 或者 sd(u) ≥ $\mu$，则<strong>后面不需要探索 v</strong>，即可确定 v 是 core 还是 non-core。</li><li>行 10，知道确定 u 是 core 还是 non-core。</li><li>最后，标记 u 已被探索过，之后不需要更新 ed(u)，sd(u)。</li></ul><h3 id="5-3-ClusterCore"><a href="#5-3-ClusterCore" class="headerlink" title="5.3 ClusterCore"></a>5.3 ClusterCore</h3><p>目的：聚类核心顶点的邻居顶点（也是核心顶点），减少了 $E_{c,c}$ 相似对的计算。</p><img src="https://cdn.jsdelivr.net/gh/gejoyy/Pictures@main/image-20230627154338133.png" alt="pscan-algorithm-5" style="zoom:67%;" /><ul><li>行 1-3，将与 u 结构相似的核心顶点（同时也是 u 的邻居顶点）分配到与 u 相同的集群中。</li><li>行 4-6，N’[u] 表示已经被计算过结构相似性邻居顶点 v 的集合，对于每个尚未被计算的 u 的结构相似邻居 v，如果 u 和 v 尚未分配给相同的集群，并且 v 可能是 core，则计算相似度(u, v)。</li><li>行 7-9，若 v 未被探索，如果(u, v)结构相似，更新 sd，否则不相似，更新 ed。</li><li>行 10，若 v 确定为 core，并且(u, v)相似，合并 u，v 到同一个集群中，属于同一聚类。</li></ul><h3 id="5-4-ClusterNoncore"><a href="#5-4-ClusterNoncore" class="headerlink" title="5.4 ClusterNoncore"></a>5.4 ClusterNoncore</h3><p>目的：减少 $E_{c,n}$ 相似对的计算。</p><img src="https://cdn.jsdelivr.net/gh/gejoyy/Pictures@main/image-20230627154711792.png" alt="pscan-algorithm-6" style="zoom:60%;" /><ul><li>行 4-7，遍历核心顶点的每个邻居 v，如果 v 是 non-core 并且 v 不在 u 的集群（可能包含 non-core）里，计算相似度(u,v)，如果还没计算的话。</li><li>行 8，如果（u，v）相似，把 v 加入 u 的集群。</li><li>行 6，如果 sd(v) ≥ $\mu$（v 为 core）或者 v 属于 u 的集群，则不需要计算 u，v 的相似度。</li><li>思考：计算 core 的时候，能够得出其邻居是 non-core（ed &lt; $\mu$），则不需要探索 non-core。</li></ul><p><strong>bin-sort</strong>: 桶排序，桶号 i 表示有效度 ed(u) &#x3D; i，顶点放入对应桶里，有效度 ed 只会减少，每一个桶是单链表。</p><p><strong>adjacency list</strong>: 输入图存储为邻接表，N(u)以顶点 id 排序，实践中计算 N[u] ∩ N[v] 表现更好。</p><h3 id="5-5-Optimization-Techniques"><a href="#5-5-Optimization-Techniques" class="headerlink" title="5.5 Optimization Techniques"></a>5.5 Optimization Techniques</h3><ol><li><strong>Criss link：</strong> 交叉连接 (u,v) 和 (v,u)，相似度计算减少一半，对于 N[u] 和 (u,v)，用二分查找 N[v] 中相反边(v,u)</li><li><strong>Pruning Rule：</strong> 修剪规则有效决定 u，v 是否相似，若 d[u] &lt; $\epsilon^2$·d[v] 或者 d[v] &lt; $\epsilon^2$·d[u]，则 $\sigma$(u, v) &lt; $\mu$。</li></ol><img src="https://cdn.jsdelivr.net/gh/gejoyy/Pictures@main/image-20230627155057753.png" alt="pscan-algorithm-6" style="zoom:67%;" /><ol start="3"><li><strong>Adaptive Structural Similarity Checking：</strong><ul><li>cn(u, v) 是满足 u，v 相似的<strong>最小公共邻居数量</strong>。</li><li>cn(u, v) &#x3D; $\lceil\sigma\cdot\sqrt{d[u]\cdot d[v]}\rceil$。</li><li>顶点相似等价于 |N[u] ∩ N[v]| ≥ cn(u,v)。</li></ul></li></ol><img src="https://cdn.jsdelivr.net/gh/gejoyy/Pictures@main/image-20230627155232123.png" alt="pscan-algorithm-7" style="zoom:67%;" /><ul><li><strong>cn(u,v) &lt; min{$d_u,d_v$} 不可能相似（提前结束）</strong></li><li><strong>只要满足 公共邻居数量 ≥ cn(u,v)，退出 while，返回 true（提前结束）</strong></li></ul><h2 id="6-Dynameically-cluster-maintenance"><a href="#6-Dynameically-cluster-maintenance" class="headerlink" title="6.Dynameically cluster maintenance"></a>6.Dynameically cluster maintenance</h2><ul><li>经过 pSCAN 算法，我们已知道 1. 顶点 u 是否为 core，2.部分顶点是否相似。</li><li>由于剪枝算法，1) 存在一些顶点间是否相似并不知道 ；2) 一些顶点间具体相似值不知道。</li><li>为了维护聚类，维持以下两个数据：<ul><li>每个顶点，维护 sd(u)，或者说<strong>维护核心顶点的集合</strong>。、</li><li>每个边，维护 t(u, v) &#x3D; |N[u] ∩ N[v]|，t(u, v) 的值可能为 0(没有边)，为 1（没有边但有一个共同邻居）。</li></ul></li><li>在 pSCAN 算法过程中，维护 t(u, v)：<ul><li>若 u，v 相似，则 t(u, v) &gt; 0，反之 t &gt; 0，不一定相似（t&#x3D;1）。</li><li>若 u，v 不相似，则 t(u, v) &lt; 0 （不存在边，或者有边且有多个共同邻居但<strong>不相似</strong>，此时为负整数）。</li><li>其他情况，t(u, v) &#x3D; 0，对与未知的 t(x,y)值，默认 t(x,y)&#x3D;0。</li><li>此外 |t(u, v) | ≥ 2，则 |t(u, v) | &#x3D; |N[u] ∩ N[v]|，注意是<strong>绝对值</strong>，t 可能为负数（-2，-3，···）</li></ul></li></ul><h3 id="6-1-ClusterMaintenance"><a href="#6-1-ClusterMaintenance" class="headerlink" title="6.1 ClusterMaintenance"></a>6.1 ClusterMaintenance</h3><img src="https://cdn.jsdelivr.net/gh/gejoyy/Pictures@main/image-20230627155758739.png" alt="pscan-algorithm-8" style="zoom:67%;" /><h3 id="6-2-Maintaining-Core-Vertices"><a href="#6-2-Maintaining-Core-Vertices" class="headerlink" title="6.2 Maintaining Core Vertices"></a>6.2 Maintaining Core Vertices</h3><ul><li>定义 N[u, v] &#x3D; N[u] ∪ N[v]。</li><li>在插入或删除边（u，v）后，只有边相关顶点相似值可能改变，那些不在 N[u,v]的顶点相似值不变，可能从 core 变为 non-core，或相反，因此考虑 N[u,v] 中的顶点，维护核心顶点集合。</li></ul><h4 id="6-2-1-Edge-insert"><a href="#6-2-1-Edge-insert" class="headerlink" title="6.2.1 Edge insert"></a>6.2.1 <strong>Edge insert</strong></h4><p>对每个 w ∈ N[u, v]，维护 sd(w)，N[u, v]划分四个集合分别考虑。</p><ul><li><strong>w ∈ N(u) 但不属于 N(v)：</strong><ul><li>若 t(w, u) ≤ 0，则 t(w, u)，sd(w) 不改变，因为 $\sigma$(w, u) 变小了，不存在 u 从 non-core 变为 core。</li><li>若 t(w, u) &gt; 0 且 sd(w) &lt; $\mu$，即 w 是 non-core，则 w 还是 non-core，需要更新 t(w,u)，sd(w)。</li><li>若 t(w, u) &gt; 0 且 sd(w) ≥ $\mu$，即 w 是 core，需要更新 t(w,u)，sd(w)，如果 $sd’$(w) &lt; $\mu$，需要计算相似性，对那些 w 的邻接点 x，满足 t(w, x) &#x3D; 0，去检查 w 是否仍然为 core。</li></ul></li><li><strong>w ∈ N(v) 但不属于 N(u)，做法同上。</strong></li><li><strong>w ∈ N(u) ∩ N(v)：</strong><ul><li>w 是共同邻接点，则 $\sigma’$(w, u) &gt; $\sigma$(w, u)，相似度变大了，同理 $\sigma$(w,v) 也变大（三角形数加一）。</li><li>若更新前 w 是 core，更新后仍然为 core，也要更新 t(w, u), t(w,v)。</li><li>若更新前 w 是 non-core，则需要更新 t(w,u), t(w, v)，其他邻接点 x 满足 t(w,x) &#x3D; 0 决定 w 是一个 core 更新后。</li></ul></li><li><strong>对于顶点 u，v：</strong><ul><li>考虑 u，由于 sd(u) &lt; $\mu$ 并且 邻接点 x 满足 t(u, x) &#x3D; 0，即在更新后（删除边 x,u）u 可能成为 core，则计算|N[u] ∩ N[v]|，更新 t(u, x) 和 sd(u)。</li><li>对于其他 邻接点 y 满足 t(u, y) $\neq$ 0，t(u, y)已经被更新过，在插入边 (u,x) 时候。</li><li>对于 v，做法一样。</li></ul></li></ul><p><strong>MaintainCoreVertices</strong>: </p><ul><li>对应上面四种处理方法</li></ul><img src="https://cdn.jsdelivr.net/gh/gejoyy/Pictures@main/image-20230627160221009.png" alt="pscan-algorithm-9" style="zoom:80%;" /><ul><li>行 2-10，w ∈ N(v)\N(u)；</li><li>行 12-22，w ∈ N(u)∩N(v)；</li><li>行 23-26，处理 u，v。</li><li>三角形 t(u, v) &#x3D; |N[u] ∩ N[v]|，若（u，v）确定不相似（可以没有边），则 t(u, v) &#x3D; - t(u, v)，变成负数。</li><li>行 27-29，若 |t(x, y)| ≤ 1，则重新计算 |N[x] ∩ N[y]|，否则更新 t(x,y) &#x3D; |t(x,y)| + 三角形。</li><li>行 30，判断 x，y 是否相似，赋值 t(x, y) 正负号。</li></ul><h4 id="6-2-2-Edge-Deletion"><a href="#6-2-2-Edge-Deletion" class="headerlink" title="6.2.2 Edge Deletion"></a>6.2.2 Edge Deletion</h4><ul><li>对 w ∈ N[u,v]，维护 sd(w)，与 insert edge 做法相似。</li><li>w ∈ N[u] \ N[v]，有 $\sigma’$(w, u) &gt; $\sigma$(w, u)。</li><li>w ∈ N[u] ∩ N[v]，有 $\sigma’$(w, u) &lt; $\sigma$(w, u)。</li></ul><h3 id="6-3-Maintaining-Structral-Similarities"><a href="#6-3-Maintaining-Structral-Similarities" class="headerlink" title="6.3 Maintaining Structral Similarities"></a>6.3 Maintaining Structral Similarities</h3><ul><li>考虑 t (x, y) 不在 N[u, v]：<ul><li>t(x,y)可能为 0 ，对（x,y）∈ E，在运行 pSCAN，维护聚类时候，例如删除边(x,y)，则 t()&#x3D;0。</li><li>聚类 C 可能分成两部分，由于里面一些边从相似 <strong>变为</strong> 不相似。</li><li>存在一个边在 C 中，满足 t(x,y)&#x3D;0 且 $\sigma$(x, y) ≥ $\epsilon$，把两个集合连接成一个聚类。</li></ul></li><li>因此要考虑 t(x,y)&#x3D;0，但不是对所有 edge（x,y）满足 t(x,y)&#x3D;0 ，都要更新，会延迟更新信息时间，因此关键在于如何选取哪些边 t&#x3D;0。</li><li>若聚类 C 中所有边满足 t&gt;0，聚类能够获得通过 BFS，基于 sd()，t()。</li><li>对于聚类 C，如果满足以下条件，不需要探索聚类 C 中顶点去更新 t()：<ul><li>不存在边 从 t&gt;0 变成 t&lt;0；</li><li>不存在核心顶点的邻接边，满足 t() &#x3D; 0；</li></ul></li><li>因此对每一个 core，提出一个平衡值 AllCh，<code>AllCh(x) = true</code> 当且仅当聚类 C 中不存在核心顶点邻接边 t &#x3D; 0。</li></ul><img src="https://cdn.jsdelivr.net/gh/gejoyy/Pictures@main/image-20230627160648438.png" alt="pscan-algorithm-10" style="zoom:80%" align="center" /><ul><li>edge(x,y) 从 t(x,y)&gt;0 变成 t(x,y)&lt;0：<ul><li>若更新前 x 是 core，则对所有与 x 结构可达的 core 满足 <code>AllCh() = true</code>，计算所有未知的 t(·,·)（即 t&#x3D;0）。</li><li>对 y 做法同上。</li><li>若更新后 x 或 y，从 non-core 变成 core，则必定存在另一个邻接边从 t ≤ 0 变成 t ≥ 0。</li></ul></li><li>edge(x,y) 从 t(x,y)≤0 变成 t(x,y)&gt;0：<ul><li>若 x 从 non-core 变成 core，则计算未知 t(·,·)，对所有临界边。</li><li>对 y 做法同上。</li><li>若更新后 x 和 y 都是 core 且 AllCh(x) $\neq$ AllCh(y)，则计算未知的 t( , )，即 t 值为 0。</li></ul></li><li>AllCh(x) 初始化每个点为 <code>false</code>。</li><li>若 x 是 core，UpdateReachable(x)计算未知 t() 值，对所有聚类中的 core 且满足 <code>AllCh() = true</code>；否则 UpdateReachable(x) 等价于 UpdateReachable(y)，对每一个 y 的 core 邻接点。</li><li>注意如果 <code>AllCh(x) = true</code>，调用 UpdateReachable(x) 将什么都不做。</li></ul>]]></content>
    
    
    <categories>
      
      <category>论文笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>SCAN</tag>
      
      <tag>graph</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
