<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>论文笔记之 pSCAN</title>
    <link href="/pSCAN.html"/>
    <url>/pSCAN.html</url>
    
    <content type="html"><![CDATA[<p>pSCAN 研究了结构图聚类问题，这是图数据管理和分析的基本问题。给定一个无向无权图，结构图聚类就是将顶点分配给簇，并识别中心顶点和离群顶点的集合，使得同一簇中的顶点彼此紧密连接，而不同簇中的顶点松散连接。</p><span id="more"></span><blockquote><p>pSCAN: Fast and Exact Structural Graph Clustering.Lijun Chang, Wei Li, Lu Qin, Wenjie Zhang, and Shiyu Yang.</p></blockquote><h2 id="1-Contributions："><a href="#1-Contributions：" class="headerlink" title="1.Contributions："></a>1.Contributions：</h2><ul><li>作者证明了现有的 SCAN 算法在最坏情况下最优的。</li><li>作者对结构图聚类做了三个观察，提出了可扩展结的两步范式，减少结构相似性计算。</li><li>此外，作者提供了优化技术加速检查两个顶点是否结构相似。</li></ul><h2 id="2-Three-observations"><a href="#2-Three-observations" class="headerlink" title="2.Three observations:"></a>2.Three observations:</h2><ol><li>结构图聚类中的聚类可能存在重叠。</li><li>核顶点的集群不相交。</li><li>非核心顶点的簇由核心顶点唯一确定。</li></ol><h2 id="3-Definition"><a href="#3-Definition" class="headerlink" title="3.Definition:"></a>3.Definition:</h2><ul><li>顶点 u 的结构领域 N[u] 为 u 的闭领域，即：N[u] &#x3D; {v ∈ V|(u,v) ∈ E} ∪ {u}。</li><li>顶点 u 和 v 之间的结构相似性定义为：N[u]和 N[v]中共有顶点的数量按其基数的几个平均值归一化。</li><li>给定相似度阈值 0 &lt; $\epsilon$ &lt;&#x3D; 1 和一个整数 $\mu$ ≥ 2，一个顶点是核心顶点如果 $N_{eps}$[u] ≥ $\mu$。</li><li>集群 C 是 V 的一个子集，它至少有两个顶点，则：<ul><li>（最大化）如果核心顶点 u∈C，那么所欲有从 u 到结构可达的顶点 v 也属于 C。</li><li>（连通性）对于任意两个顶点 $v_1$,$v_2$ ∈ C，有顶点 u ∈ C，使得 $v_1$ 和 $v_2$ 都可以从 u 可达。</li></ul></li><li>给定聚类 C，C 中不属于任何集群的顶点 u，如果它的邻居属于两个或者两个以上的集群，则为 hub，否则为 outlier。</li></ul><h2 id="4-Two-step-Paradigm"><a href="#4-Two-step-Paradigm" class="headerlink" title="4.Two-step Paradigm:"></a>4.Two-step Paradigm:</h2><ul><li>step-1：<u>聚类核心顶点</u>，把所有核心顶点分类到对应簇。</li><li>step-2：<u>聚类非核心顶点</u>，是 non-core 且和邻点 core 相似，分到 core 的簇中。</li></ul><img src="https://cdn.jsdelivr.net/gh/gejoyy/Pictures@main/image-20230627152627744.png" alt="pscan-algorithm-2" style="zoom: 67%;" /><h2 id="5-Algorithm"><a href="#5-Algorithm" class="headerlink" title="5.Algorithm"></a>5.Algorithm</h2><h3 id="5-1-pSCAN"><a href="#5-1-pSCAN" class="headerlink" title="5.1 pSCAN"></a>5.1 pSCAN</h3><p>算法目标是减少结构相似性计算的次数，把边分为 $E_{c,c}$，$E_{c,n}$，分别讨论。</p><img src="https://cdn.jsdelivr.net/gh/gejoyy/Pictures@main/image-20230627153257747.png" alt="pscan-algorithm-3" style="zoom:67%;" /><ul><li>行 1，初始化每个顶点成单个子集。</li><li>行 2-4，初始化每个顶点 sd(u), ed(u)。</li><li>行 5-7，按有效度 ed(u) 非递增顺序遍历顶点 u，检测 u 是否为 core，如果 u 是 core，把 u 和已经确定为 core 的邻点聚类到一起。</li><li>行 8-9，得到 core 顶点聚类 $C_c$，再聚类 non-core 顶点集合。</li><li>用不相交数据结构(disjoint-set data) 聚类 $G_c$ 中的 core，形成多个不相交的集合 S &#x3D; {s1, s2,…}<ul><li>find-subset：查看元素在哪一个子集中。</li><li>union：合并两个子集。</li></ul></li><li>union(u, v) 相当于在 $G_c$ 中添加一条边(u, v)。</li><li>两个顶点 u，v 属于同一连接组件（聚类）当且仅当 u，v 所在的子集相同，即：find-subset(u) &#x3D; find-subset(v)。</li></ul><p><strong>effective-degree: ed(u)</strong></p><ul><li>目的：为了减少相似度计算，按 ed(u) <strong>非递增</strong>顺序排序顶点。</li><li>定义：|N[u]|减去与 u 不相似的邻点的数量，得到可能相似的邻点的数量，满足 |$N_{eps}[u]$| ≤ ed(u)，ed(u) 是上界。</li><li>如果 ed(u) ≤ $\mu$，上界小于 $\mu$，则 u 是 non-core，从而减少<strong>顶点对 $E_{n,n}$ 的计算次数</strong>，对两个 non-core 顶点，不用计算它们之间相似度。</li></ul><p><strong>similar-degree: sd(u)</strong></p><ul><li>目的：为了有效检查一个顶点是否为 core。</li><li>定义：sd(u) 是已经确定与 u 相似的邻居的数量，满足|$N_{eps}[u]$| ≥ sd(u)，sd(u) 是下界。</li><li>如果 sd(u) ≥ $\mu$，下界大于 $\mu$，则 u 是 core。</li></ul><h3 id="5-2-CheckCore"><a href="#5-2-CheckCore" class="headerlink" title="5.2 CheckCore"></a>5.2 CheckCore</h3><p>目的：检测一个顶点是否为 core，减少顶点对 $E_{n,n}$的计算。</p><img src="https://cdn.jsdelivr.net/gh/gejoyy/Pictures@main/image-20230627153654828.png" alt="pscan-algorithm-4" style="zoom:67%;" /><ul><li>行 1，对于 ed(u) &lt; $\mu$（确定为 non-core）和 sd(u) ≥ $\mu$（确定 core）两种情况无需讨论，因为 ed(u) ≥ sd(u)，所以讨论第三种情况，ed(u) ≥ $\mu$ &gt;sd(u)，需要计算 u 和其邻居的相似性，<strong>以检测 u 是否为core</strong>。</li><li>行 2，初始化 ed(u)，sd(u)。</li><li>行 3-6，计算相似度，然后更新 ed(u)，sd(u)。</li><li>行 7-9，如果邻点 v 还没有被探索，更新 ed(v)，sd(v)，如果 ed(u) &lt; $\mu$ 或者 sd(u) ≥ $\mu$，则<strong>后面不需要探索 v</strong>，即可确定 v 是 core 还是 non-core。</li><li>行 10，知道确定 u 是 core 还是 non-core。</li><li>最后，标记 u 已被探索过，之后不需要更新 ed(u)，sd(u)。</li></ul><h3 id="5-3-ClusterCore"><a href="#5-3-ClusterCore" class="headerlink" title="5.3 ClusterCore"></a>5.3 ClusterCore</h3><p>目的：聚类核心顶点的邻居顶点（也是核心顶点），减少了 $E_{c,c}$ 相似对的计算。</p><img src="https://cdn.jsdelivr.net/gh/gejoyy/Pictures@main/image-20230627154338133.png" alt="pscan-algorithm-5" style="zoom:67%;" /><ul><li>行 1-3，将与 u 结构相似的核心顶点（同时也是 u 的邻居顶点）分配到与 u 相同的集群中。</li><li>行 4-6，N’[u] 表示已经被计算过结构相似性邻居顶点 v 的集合，对于每个尚未被计算的 u 的结构相似邻居 v，如果 u 和 v 尚未分配给相同的集群，并且 v 可能是 core，则计算相似度(u, v)。</li><li>行 7-9，若 v 未被探索，如果(u, v)结构相似，更新 sd，否则不相似，更新 ed。</li><li>行 10，若 v 确定为 core，并且(u, v)相似，合并 u，v 到同一个集群中，属于同一聚类。</li></ul><h3 id="5-4-ClusterNoncore"><a href="#5-4-ClusterNoncore" class="headerlink" title="5.4 ClusterNoncore"></a>5.4 ClusterNoncore</h3><p>目的：减少 $E_{c,n}$ 相似对的计算。</p><img src="https://cdn.jsdelivr.net/gh/gejoyy/Pictures@main/image-20230627154711792.png" alt="pscan-algorithm-6" style="zoom:60%;" /><ul><li>行 4-7，遍历核心顶点的每个邻居 v，如果 v 是 non-core 并且 v 不在 u 的集群（可能包含 non-core）里，计算相似度(u,v)，如果还没计算的话。</li><li>行 8，如果（u，v）相似，把 v 加入 u 的集群。</li><li>行 6，如果 sd(v) ≥ $\mu$（v 为 core）或者 v 属于 u 的集群，则不需要计算 u，v 的相似度。</li><li>思考：计算 core 的时候，能够得出其邻居是 non-core（ed &lt; $\mu$），则不需要探索 non-core。</li></ul><p><strong>bin-sort</strong>: 桶排序，桶号 i 表示有效度 ed(u) &#x3D; i，顶点放入对应桶里，有效度 ed 只会减少，每一个桶是单链表。</p><p><strong>adjacency list</strong>: 输入图存储为邻接表，N(u)以顶点 id 排序，实践中计算 N[u] ∩ N[v] 表现更好。</p><h3 id="5-5-Optimization-Techniques"><a href="#5-5-Optimization-Techniques" class="headerlink" title="5.5 Optimization Techniques"></a>5.5 Optimization Techniques</h3><ol><li><strong>Criss link：</strong> 交叉连接 (u,v) 和 (v,u)，相似度计算减少一半，对于 N[u] 和 (u,v)，用二分查找 N[v] 中相反边(v,u)</li><li><strong>Pruning Rule：</strong> 修剪规则有效决定 u，v 是否相似，若 d[u] &lt; $\epsilon^2$·d[v] 或者 d[v] &lt; $\epsilon^2$·d[u]，则 $\sigma$(u, v) &lt; $\mu$。</li></ol><img src="https://cdn.jsdelivr.net/gh/gejoyy/Pictures@main/image-20230627155057753.png" alt="pscan-algorithm-6" style="zoom:67%;" /><ol start="3"><li><strong>Adaptive Structural Similarity Checking：</strong><ul><li>cn(u, v) 是满足 u，v 相似的<strong>最小公共邻居数量</strong>。</li><li>cn(u, v) &#x3D; $\lceil\sigma\cdot\sqrt{d[u]\cdot d[v]}\rceil$。</li><li>顶点相似等价于 |N[u] ∩ N[v]| ≥ cn(u,v)。</li></ul></li></ol><img src="https://cdn.jsdelivr.net/gh/gejoyy/Pictures@main/image-20230627155232123.png" alt="pscan-algorithm-7" style="zoom:67%;" /><ul><li><strong>cn(u,v) &lt; min{$d_u,d_v$} 不可能相似（提前结束）</strong></li><li><strong>只要满足 公共邻居数量 ≥ cn(u,v)，退出 while，返回 true（提前结束）</strong></li></ul><h2 id="6-Dynameically-cluster-maintenance"><a href="#6-Dynameically-cluster-maintenance" class="headerlink" title="6.Dynameically cluster maintenance"></a>6.Dynameically cluster maintenance</h2><ul><li>经过 pSCAN 算法，我们已知道 1. 顶点 u 是否为 core，2.部分顶点是否相似。</li><li>由于剪枝算法，1) 存在一些顶点间是否相似并不知道 ；2) 一些顶点间具体相似值不知道。</li><li>为了维护聚类，维持以下两个数据：<ul><li>每个顶点，维护 sd(u)，或者说<strong>维护核心顶点的集合</strong>。、</li><li>每个边，维护 t(u, v) &#x3D; |N[u] ∩ N[v]|，t(u, v) 的值可能为 0(没有边)，为 1（没有边但有一个共同邻居）。</li></ul></li><li>在 pSCAN 算法过程中，维护 t(u, v)：<ul><li>若 u，v 相似，则 t(u, v) &gt; 0，反之 t &gt; 0，不一定相似（t&#x3D;1）。</li><li>若 u，v 不相似，则 t(u, v) &lt; 0 （不存在边，或者有边且有多个共同邻居但<strong>不相似</strong>，此时为负整数）。</li><li>其他情况，t(u, v) &#x3D; 0，对与未知的 t(x,y)值，默认 t(x,y)&#x3D;0。</li><li>此外 |t(u, v) | ≥ 2，则 |t(u, v) | &#x3D; |N[u] ∩ N[v]|，注意是<strong>绝对值</strong>，t 可能为负数（-2，-3，···）</li></ul></li></ul><h3 id="6-1-ClusterMaintenance"><a href="#6-1-ClusterMaintenance" class="headerlink" title="6.1 ClusterMaintenance"></a>6.1 ClusterMaintenance</h3><img src="https://cdn.jsdelivr.net/gh/gejoyy/Pictures@main/image-20230627155758739.png" alt="pscan-algorithm-8" style="zoom:67%;" /><h3 id="6-2-Maintaining-Core-Vertices"><a href="#6-2-Maintaining-Core-Vertices" class="headerlink" title="6.2 Maintaining Core Vertices"></a>6.2 Maintaining Core Vertices</h3><ul><li>定义 N[u, v] &#x3D; N[u] ∪ N[v]。</li><li>在插入或删除边（u，v）后，只有边相关顶点相似值可能改变，那些不在 N[u,v]的顶点相似值不变，可能从 core 变为 non-core，或相反，因此考虑 N[u,v] 中的顶点，维护核心顶点集合。</li></ul><h4 id="6-2-1-edge-insert"><a href="#6-2-1-edge-insert" class="headerlink" title="6.2.1 edge insert"></a>6.2.1 <strong>edge insert</strong></h4><p>对每个 w ∈ N[u, v]，维护 sd(w)，N[u, v]划分四个集合分别考虑。</p><ul><li><strong>w ∈ N(u) 但不属于 N(v)：</strong><ul><li>若 t(w, u) ≤ 0，则 t(w, u)，sd(w) 不改变，因为 $\sigma$(w, u) 变小了，不存在 u 从 non-core 变为 core。</li><li>若 t(w, u) &gt; 0 且 sd(w) &lt; $\mu$，即 w 是 non-core，则 w 还是 non-core，需要更新 t(w,u)，sd(w)。</li><li>若 t(w, u) &gt; 0 且 sd(w) ≥ $\mu$，即 w 是 core，需要更新 t(w,u)，sd(w)，如果 $sd’$(w) &lt; $\mu$，需要计算相似性，对那些 w 的邻接点 x，满足 t(w, x) &#x3D; 0，去检查 w 是否仍然为 core。</li></ul></li><li><strong>w ∈ N(v) 但不属于 N(u)，做法同上。</strong></li><li><strong>w ∈ N(u) ∩ N(v)：</strong><ul><li>w 是共同邻接点，则 $\sigma’$(w, u) &gt; $\sigma$(w, u)，相似度变大了，同理 $\sigma$(w,v) 也变大（三角形数加一）。</li><li>若更新前 w 是 core，更新后仍然为 core，也要更新 t(w, u), t(w,v)。</li><li>若更新前 w 是 non-core，则需要更新 t(w,u), t(w, v)，其他邻接点 x 满足 t(w,x) &#x3D; 0 决定 w 是一个 core 更新后。</li></ul></li><li><strong>对于顶点 u，v：</strong><ul><li>考虑 u，由于 sd(u) &lt; $\mu$ 并且 邻接点 x 满足 t(u, x) &#x3D; 0，即在更新后（删除边 x,u）u 可能成为 core，则计算|N[u] ∩ N[v]|，更新 t(u, x) 和 sd(u)。</li><li>对于其他 邻接点 y 满足 t(u, y) $\neq$ 0，t(u, y)已经被更新过，在插入边 (u,x) 时候。</li><li>对于 v，做法一样。</li></ul></li></ul><p><strong>MaintainCoreVertices</strong>: </p><ul><li>对应上面四种处理方法</li></ul><img src="https://cdn.jsdelivr.net/gh/gejoyy/Pictures@main/image-20230627160221009.png" alt="pscan-algorithm-9" style="zoom:80%;" /><ul><li>行 2-10，w ∈ N(v)\N(u)；</li><li>行 12-22，w ∈ N(u)∩N(v)；</li><li>行 23-26，处理 u，v。</li><li>三角形 t(u, v) &#x3D; |N[u] ∩ N[v]|，若（u，v）确定不相似（可以没有边），则 t(u, v) &#x3D; - t(u, v)，变成负数。</li><li>行 27-29，若 |t(x, y)| ≤ 1，则重新计算 |N[x] ∩ N[y]|，否则更新 t(x,y) &#x3D; |t(x,y)| + 三角形。</li><li>行 30，判断 x，y 是否相似，赋值 t(x, y) 正负号。</li></ul><h4 id="6-2-2-Edge-Deletion"><a href="#6-2-2-Edge-Deletion" class="headerlink" title="6.2.2 Edge Deletion"></a>6.2.2 Edge Deletion</h4><ul><li>对 w ∈ N[u,v]，维护 sd(w)，与 insert edge 做法相似。</li><li>w ∈ N[u] \ N[v]，有 $\sigma’$(w, u) &gt; $\sigma$(w, u)。</li><li>w ∈ N[u] ∩ N[v]，有 $\sigma’$(w, u) &lt; $\sigma$(w, u)。</li></ul><h3 id="6-3-Maintaining-Structral-Similarities"><a href="#6-3-Maintaining-Structral-Similarities" class="headerlink" title="6.3 Maintaining Structral Similarities"></a>6.3 Maintaining Structral Similarities</h3><ul><li>考虑 t (x, y) 不在 N[u, v]：<ul><li>t(x,y)可能为 0 ，对（x,y）∈ E，在运行 pSCAN，维护聚类时候，例如删除边(x,y)，则 t()&#x3D;0。</li><li>聚类 C 可能分成两部分，由于里面一些边从相似 <strong>变为</strong> 不相似。</li><li>存在一个边在 C 中，满足 t(x,y)&#x3D;0 且 $\sigma$(x, y) ≥ $\epsilon$，把两个集合连接成一个聚类。</li></ul></li><li>因此要考虑 t(x,y)&#x3D;0，但不是对所有 edge（x,y）满足 t(x,y)&#x3D;0 ，都要更新，会延迟更新信息时间，因此关键在于如何选取哪些边 t&#x3D;0。</li><li>若聚类 C 中所有边满足 t&gt;0，聚类能够获得通过 BFS，基于 sd()，t()。</li><li>对于聚类 C，如果满足以下条件，不需要探索聚类 C 中顶点去更新 t()：<ul><li>不存在边 从 t&gt;0 变成 t&lt;0；</li><li>不存在核心顶点的邻接边，满足 t() &#x3D; 0；</li></ul></li><li>因此对每一个 core，提出一个平衡值 AllCh，<code>AllCh(x) = true</code> 当且仅当聚类 C 中不存在核心顶点邻接边 t &#x3D; 0。</li></ul><img src="https://cdn.jsdelivr.net/gh/gejoyy/Pictures@main/image-20230627160648438.png" alt="pscan-algorithm-10" style="zoom:80%" align="center" /><ul><li>edge(x,y) 从 t(x,y)&gt;0 变成 t(x,y)&lt;0：<ul><li>若更新前 x 是 core，则对所有与 x 结构可达的 core 满足 <code>AllCh() = true</code>，计算所有未知的 t(·,·)（即 t&#x3D;0）。</li><li>对 y 做法同上。</li><li>若更新后 x 或 y，从 non-core 变成 core，则必定存在另一个邻接边从 t ≤ 0 变成 t ≥ 0。</li></ul></li><li>edge(x,y) 从 t(x,y)≤0 变成 t(x,y)&gt;0：<ul><li>若 x 从 non-core 变成 core，则计算未知 t(·,·)，对所有临界边。</li><li>对 y 做法同上。</li><li>若更新后 x 和 y 都是 core 且 AllCh(x) $\neq$ AllCh(y)，则计算未知的 t( , )，即 t 值为 0。</li></ul></li><li>AllCh(x) 初始化每个点为 <code>false</code>。</li><li>若 x 是 core，UpdateReachable(x)计算未知 t() 值，对所有聚类中的 core 且满足 <code>AllCh() = true</code>；否则 UpdateReachable(x) 等价于 UpdateReachable(y)，对每一个 y 的 core 邻接点。</li><li>注意如果 <code>AllCh(x) = true</code>，调用 UpdateReachable(x) 将什么都不做。</li></ul>]]></content>
    
    
    <categories>
      
      <category>论文笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>SCAN</tag>
      
      <tag>graph</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>从源码理解 TinyWebServer 之 threadpool</title>
    <link href="/TinyWebServer-threadpool.html"/>
    <url>/TinyWebServer-threadpool.html</url>
    
    <content type="html"><![CDATA[<p>服务器并发模型通常可分为单线程和多线程模型，这里的线程通常是指“I&#x2F;O 线程”，即负责 I&#x2F;O 操作，协调分配任务的“管理线程”，而实际的请求和任务通常交由所谓“工作者线程”处理。通常多线程模型下，每个线程既是 I&#x2F;O 线程又是工作者线程。所以这里讨论的是，单 I&#x2F;O 线程+多工作者线程的模型，这也是最常用的一种服务器并发模型。</p><span id="more"></span><h2 id="threadpool-h"><a href="#threadpool-h" class="headerlink" title="threadpool.h"></a>threadpool.h</h2><h3 id="设计思路"><a href="#设计思路" class="headerlink" title="设计思路"></a>设计思路</h3><p>该项目使用线程池（半同步半反应堆模式）并发处理用户请求，主线程负责读写，工作线程（线程池中的线程）负责处理逻辑（HTTP 请求报文的解析等等）。</p><p>所谓线程池一个<code>pthread_t</code>类型的普通数组，通过<code>pthread_create()</code>函数创建<code>m_thread_number</code>个<strong>线程</strong>，用来执行<code>worker()</code>函数以执行每个请求处理函数（HTTP 请求的<code>process</code>函数），通过<code>pthread_detach()</code>将线程设置成脱离态（detached）后，当这一线程运行结束时，它的资源会被系统自动回收，而不再需要在其它线程中对其进行 <code>pthread_join()</code> 操作。</p><p><strong>为什么要使用线程池？</strong><br>当你需要限制你应用程序中同时运行的线程数时，线程池非常有用。因为启动一个新线程会带来性能开销，每个线程也会为其堆栈分配一些内存等。为了任务的并发执行，我们可以将这些任务任务传递到线程池，而不是为每个任务动态开启一个新的线程。</p><p><strong>线程池类最关键的两个成员：</strong></p><ul><li><code>pthread_t *m_threads;</code>，线程池的数组。</li><li><code>std::list&lt;T *&gt; m_workqueue;</code>，请求队列。</li></ul><p>在 WebServer 中调用<code>append_p</code>和<code>append</code>函数把新任务放到<code>list</code>的尾部，然后所有线程争夺<code>list</code>中的任务（这里要使用条件变量），争夺到的线程先对任务队列加互斥锁然后从<code>list</code>头取出任务结构体，在这个任务结构体内有一个回调函数，这个函数就是真正的工作（包括解析<code>http</code>请求报文，对请求资源的检查，搓响应报文一条龙）当然这个函数放在<code>http</code>模块以更加模块化，从线程的角度就是拿到任务然后调用这个函数。</p><p>然后是线程池数组，这个线程池还是比较简单的线程池（没有对线程的动态删减等等），那么我们就是在线程池构造的时候就创建好约定个数的线程储存在线程数组里，并且把线程<code>detach</code>掉，这样我们就不需要对线程进行回收等等操作。线程的关键是线程的工作函数<code>run()</code>，这个函数不断<code>while</code>循环直到被条件变量唤醒然后上锁从<code>list</code>头取出任务，开始执行任务。</p><h3 id="代码详解"><a href="#代码详解" class="headerlink" title="代码详解"></a>代码详解</h3><p>在 webserver 模块中线程池这样创建：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">WebServer::thread_pool</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-comment">//线程池</span><br>    m_pool = <span class="hljs-keyword">new</span> <span class="hljs-built_in">threadpool</span>&lt;http_conn&gt;(m_actormodel, m_connPool, m_thread_num);<br>&#125;<br></code></pre></td></tr></table></figure><ol><li>构造函数完成线程池的初始化，产生了 8 个线程（默认）并且作出了分离。</li><li><code>m_poll</code>这个指针可以调用<code>append</code>函数来完成将事件入队的任务。</li><li><code>http_conn</code>给到了一个入口的作用，通过等待信号量来进入到<code>http</code>类里写出的<code>process</code>函数完成对于事务的处理。</li></ol><blockquote><p>作者的代码中没有涉及惊群效应！</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">ifndef</span> THREADPOOL_H</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> THREADPOOL_H</span><br><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;list&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cstdio&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;exception&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;pthread.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;../lock/locker.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;../CGImysql/sql_connection_pool.h&quot;</span></span><br><br><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">threadpool</span><br>&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-comment">/*thread_number是线程池中线程的数量，max_requests是请求队列中最多允许的、等待处理的请求的数量*/</span><br>    <span class="hljs-comment">//connPool是数据库连接池指针</span><br>    <span class="hljs-built_in">threadpool</span>(<span class="hljs-type">int</span> actor_model, connection_pool *connPool, <span class="hljs-type">int</span> thread_number = <span class="hljs-number">8</span>, <span class="hljs-type">int</span> max_request = <span class="hljs-number">10000</span>);<br>    ~<span class="hljs-built_in">threadpool</span>();<br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">append</span><span class="hljs-params">(T *request, <span class="hljs-type">int</span> state)</span></span>;<br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">append_p</span><span class="hljs-params">(T *request)</span></span>;<br><br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-comment">/*工作线程运行的函数，它不断从工作队列中取出任务并执行之*/</span><br>    <span class="hljs-function"><span class="hljs-type">static</span> <span class="hljs-type">void</span> *<span class="hljs-title">worker</span><span class="hljs-params">(<span class="hljs-type">void</span> *arg)</span></span>;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span></span>;<br><br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-type">int</span> m_thread_number;        <span class="hljs-comment">//线程池中的线程数</span><br>    <span class="hljs-type">int</span> m_max_requests;         <span class="hljs-comment">//请求队列中允许的最大请求数</span><br>    <span class="hljs-type">pthread_t</span> *m_threads;       <span class="hljs-comment">//描述线程池的数组，其大小为m_thread_number</span><br>    std::list&lt;T *&gt; m_workqueue; <span class="hljs-comment">//请求队列</span><br>    locker m_queuelocker;       <span class="hljs-comment">//保护请求队列的互斥锁</span><br>    sem m_queuestat;            <span class="hljs-comment">//是否有任务需要处理</span><br>    connection_pool *m_connPool;  <span class="hljs-comment">//数据库</span><br>    <span class="hljs-type">int</span> m_actor_model;          <span class="hljs-comment">//模型切换</span><br>&#125;;<br><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt;<br>threadpool&lt;T&gt;::<span class="hljs-built_in">threadpool</span>( <span class="hljs-type">int</span> actor_model, connection_pool *connPool, <span class="hljs-type">int</span> thread_number, <span class="hljs-type">int</span> max_requests) : <span class="hljs-built_in">m_actor_model</span>(actor_model),<span class="hljs-built_in">m_thread_number</span>(thread_number), <span class="hljs-built_in">m_max_requests</span>(max_requests), <span class="hljs-built_in">m_threads</span>(<span class="hljs-literal">NULL</span>),<span class="hljs-built_in">m_connPool</span>(connPool)<br>&#123;<br>    <span class="hljs-keyword">if</span> (thread_number &lt;= <span class="hljs-number">0</span> || max_requests &lt;= <span class="hljs-number">0</span>)<br>        <span class="hljs-keyword">throw</span> std::<span class="hljs-built_in">exception</span>();<br>    m_threads = <span class="hljs-keyword">new</span> <span class="hljs-type">pthread_t</span>[m_thread_number];<br>    <span class="hljs-keyword">if</span> (!m_threads)<br>        <span class="hljs-keyword">throw</span> std::<span class="hljs-built_in">exception</span>();<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; thread_number; ++i)<br>    &#123;<br>        <span class="hljs-comment">//循环创建线程，并将工作线程按要求进行运行</span><br>        <span class="hljs-keyword">if</span> (<span class="hljs-built_in">pthread_create</span>(m_threads + i, <span class="hljs-literal">NULL</span>, worker, <span class="hljs-keyword">this</span>) != <span class="hljs-number">0</span>)<br>        &#123;<br>            <span class="hljs-keyword">delete</span>[] m_threads;<br>            <span class="hljs-keyword">throw</span> std::<span class="hljs-built_in">exception</span>();<br>        &#125;<br>        <span class="hljs-comment">//将线程进行分离后，不用单独对工作线程进行回收</span><br>        <span class="hljs-keyword">if</span> (<span class="hljs-built_in">pthread_detach</span>(m_threads[i]))<br>        &#123;<br>            <span class="hljs-keyword">delete</span>[] m_threads;<br>            <span class="hljs-keyword">throw</span> std::<span class="hljs-built_in">exception</span>();<br>        &#125;<br>    &#125;<br>&#125;<br><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt;<br>threadpool&lt;T&gt;::~<span class="hljs-built_in">threadpool</span>()<br>&#123;<br>    <span class="hljs-keyword">delete</span>[] m_threads;<br>&#125;<br><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt;<br><span class="hljs-type">bool</span> threadpool&lt;T&gt;::<span class="hljs-built_in">append</span>(T *request, <span class="hljs-type">int</span> state)<br>&#123;<br>    m_queuelocker.<span class="hljs-built_in">lock</span>();<br>    <span class="hljs-keyword">if</span> (m_workqueue.<span class="hljs-built_in">size</span>() &gt;= m_max_requests)<br>    &#123;<br>        m_queuelocker.<span class="hljs-built_in">unlock</span>();<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br>    request-&gt;m_state = state;<br>    m_workqueue.<span class="hljs-built_in">push_back</span>(request);<br>    m_queuelocker.<span class="hljs-built_in">unlock</span>();<br>    m_queuestat.<span class="hljs-built_in">post</span>();<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br><span class="hljs-comment">//将“待办工作”加入到请求队列</span><br><span class="hljs-comment">//传入的是fd</span><br><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt;<br><span class="hljs-type">bool</span> threadpool&lt;T&gt;::<span class="hljs-built_in">append_p</span>(T *request)<br>&#123;<br>    m_queuelocker.<span class="hljs-built_in">lock</span>();<br>    <span class="hljs-keyword">if</span> (m_workqueue.<span class="hljs-built_in">size</span>() &gt;= m_max_requests)<br>    &#123;<br>        m_queuelocker.<span class="hljs-built_in">unlock</span>();<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br>    m_workqueue.<span class="hljs-built_in">push_back</span>(request);<br>    m_queuelocker.<span class="hljs-built_in">unlock</span>();<br>    m_queuestat.<span class="hljs-built_in">post</span>();<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br><span class="hljs-comment">//线程回调函数/工作函数，arg其实是this</span><br><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt;<br><span class="hljs-type">void</span> *threadpool&lt;T&gt;::<span class="hljs-built_in">worker</span>(<span class="hljs-type">void</span> *arg)<br>&#123;<br>    threadpool *pool = (threadpool *)arg;<br>    pool-&gt;<span class="hljs-built_in">run</span>();<br>    <span class="hljs-keyword">return</span> pool;<br>&#125;<br><span class="hljs-comment">//回调函数会调用这个函数工作</span><br><span class="hljs-comment">//工作线程就是不断地等任务队列有新任务，然后就加锁取任务-&gt;取到任务解锁-&gt;执行任务</span><br><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt;<br><span class="hljs-type">void</span> threadpool&lt;T&gt;::<span class="hljs-built_in">run</span>()<br>&#123;<br>    <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>)<br>    &#123;<br>        <span class="hljs-comment">//信号量等待</span><br>        m_queuestat.<span class="hljs-built_in">wait</span>();<br>        <span class="hljs-comment">//被唤醒后先加互斥锁</span><br>        m_queuelocker.<span class="hljs-built_in">lock</span>();<br>        <span class="hljs-keyword">if</span> (m_workqueue.<span class="hljs-built_in">empty</span>())<br>        &#123;<br>            m_queuelocker.<span class="hljs-built_in">unlock</span>();<br>            <span class="hljs-keyword">continue</span>;<br>        &#125;<br>        <span class="hljs-comment">//从请求队列中取出第一个任务</span><br>        <span class="hljs-comment">//将任务从请求队列删除</span><br>        T *request = m_workqueue.<span class="hljs-built_in">front</span>();<br>        m_workqueue.<span class="hljs-built_in">pop_front</span>();<br>        m_queuelocker.<span class="hljs-built_in">unlock</span>();<br>        <span class="hljs-keyword">if</span> (!request)<br>            <span class="hljs-keyword">continue</span>;<br>        <span class="hljs-comment">//proactor reactor</span><br>        <span class="hljs-keyword">if</span> (<span class="hljs-number">1</span> == m_actor_model)<br>        &#123;<br>            <span class="hljs-keyword">if</span> (<span class="hljs-number">0</span> == request-&gt;m_state)<br>            &#123;<br>                <span class="hljs-keyword">if</span> (request-&gt;<span class="hljs-built_in">read_once</span>())<br>                &#123;<br>                    request-&gt;improv = <span class="hljs-number">1</span>;<br>                    <span class="hljs-function">connectionRAII <span class="hljs-title">mysqlcon</span><span class="hljs-params">(&amp;request-&gt;mysql, m_connPool)</span></span>;<br>                    request-&gt;<span class="hljs-built_in">process</span>();<br>                &#125;<br>                <span class="hljs-keyword">else</span><br>                &#123;<br>                    request-&gt;improv = <span class="hljs-number">1</span>;<br>                    request-&gt;timer_flag = <span class="hljs-number">1</span>;<br>                &#125;<br>            &#125;<br>            <span class="hljs-keyword">else</span><br>            &#123;<br>                <span class="hljs-keyword">if</span> (request-&gt;<span class="hljs-built_in">write</span>())<br>                &#123;<br>                    request-&gt;improv = <span class="hljs-number">1</span>;<br>                &#125;<br>                <span class="hljs-keyword">else</span><br>                &#123;<br>                    request-&gt;improv = <span class="hljs-number">1</span>;<br>                    request-&gt;timer_flag = <span class="hljs-number">1</span>;<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">else</span><br>        &#123;<br>            connectionRAII <span class="hljs-built_in">mysqlcon</span>(&amp;request-&gt;mysql, m_connPool);<br>            request-&gt;<span class="hljs-built_in">process</span>();<br>        &#125;<br>    &#125;<br>&#125;<br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br><br></code></pre></td></tr></table></figure><p><strong>总结</strong>：整体流程就是封装一个简易的线程池类，创建固定数目的线程（例如跟核心数目相同），然后类内部维护一个生产者-消费者队列，提供相应的添加任务（生产者）和执行任务接口（消费者），按生产者—消费者模型维护增减队列任务（使用<code>mutex</code>和<code>semaphore</code>）。<code>mutex</code>用于互斥，保证任意时刻只有一个线程读写队列，<code>semaphore</code>用于同步，保证执行顺序（队列为空时不要读，队列满了不要写）。</p><p><strong>参考</strong>：<a href="https://huixxi.github.io/2020/06/02/%E5%B0%8F%E7%99%BD%E8%A7%86%E8%A7%92%EF%BC%9A%E4%B8%80%E6%96%87%E8%AF%BB%E6%87%82%E7%A4%BE%E9%95%BF%E7%9A%84TinyWebServer/#more">小白视角：一文读懂社长的TinyWebServer(Raw_Version)</a></p>]]></content>
    
    
    <categories>
      
      <category>webserverber</category>
      
    </categories>
    
    
    <tags>
      
      <tag>cpp</tag>
      
      <tag>linux</tag>
      
      <tag>网络编程</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>从源码理解 TinyWebServer 之 webserver</title>
    <link href="/TinyWebServer-webserver.html"/>
    <url>/TinyWebServer-webserver.html</url>
    
    <content type="html"><![CDATA[<p>本文从源码开始解读开源 TinyWebserver 项目，彻底理解客户端连接服务端的过程发生了什么，服务器又是如何处理来自客户端的请求。</p><span id="more"></span><h2 id="TinyWebServer"><a href="#TinyWebServer" class="headerlink" title="TinyWebServer"></a>TinyWebServer</h2><p>Linux 下 C++轻量级 Web 服务器，助力初学者快速实践网络编程，搭建属于自己的服务器。</p><ul><li>使用线程池+非阻塞 socket+epoll(ET 和 LT 均实现)+事件处理(Reactor 和模拟 Proactor 均实现)的并发模型。</li><li>使用<strong>状态机</strong>解析 HTTP 请求报文，支持解析 <strong>GET 和 POST</strong> 请求。</li><li>访问服务器数据库实现 web 端用户<strong>注册、登录</strong>功能，可以请求服务器<strong>图片和视频文件</strong>。</li><li>实现<strong>同步&#x2F;异步日志系统</strong>，记录服务器运行状态。</li><li>经 Webbench 压力测试可以实现<strong>上万的并发连接</strong>数据交换。</li></ul><blockquote><p> 参考的源代码 <a href="https://github.com/qinguoyi/TinyWebServer/tree/codeRefactorCGI_version">TinyWebServer</a></p></blockquote><h2 id="config-模块"><a href="#config-模块" class="headerlink" title="config 模块"></a>config 模块</h2><p>打开源文件首先看到 config 的头文件，根据标识可以知道这是一个用户自定义头，里面是一些默认参数配置。</p><h3 id="config-h"><a href="#config-h" class="headerlink" title="config.h"></a>config.h</h3><p>这里体现出整个项目的优点：<strong>模式切换</strong>，也就是说这是一个复合的 ET&#x2F;LT。作者在 Listenfd 上和 connfd 上都建立了两种模式，意味着共有四种组合方式。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">ifndef</span> CONFIG_H</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> CONFIG_H</span><br><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;webserver.h&quot;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Config</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">Config</span>();<br><br>    ~<span class="hljs-built_in">Config</span>() &#123;&#125;;<br><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">parse_arg</span><span class="hljs-params">(<span class="hljs-type">int</span> argc, <span class="hljs-type">char</span> *argv[])</span></span>;<br><br>    <span class="hljs-comment">//端口号</span><br>    <span class="hljs-type">int</span> PORT;<br><br>    <span class="hljs-comment">//数据库校验方式</span><br>    <span class="hljs-type">int</span> SQLVerify;<br><br>    <span class="hljs-comment">//日志写入方式</span><br>    <span class="hljs-type">int</span> LOGWrite;<br><br>    <span class="hljs-comment">//触发组合模式</span><br>    <span class="hljs-type">int</span> TRIGMode;<br><br>    <span class="hljs-comment">//listenfd触发模式</span><br>    <span class="hljs-type">int</span> LISTENTrigmode;<br><br>    <span class="hljs-comment">//connfd触发模式</span><br>    <span class="hljs-type">int</span> CONNTrigmode;<br><br>    <span class="hljs-comment">//优雅关闭链接</span><br>    <span class="hljs-type">int</span> OPT_LINGER;<br><br>    <span class="hljs-comment">//数据库连接池数量</span><br>    <span class="hljs-type">int</span> sql_num;<br><br>    <span class="hljs-comment">//线程池内的线程数量</span><br>    <span class="hljs-type">int</span> thread_num;<br><br>    <span class="hljs-comment">//是否关闭日志</span><br>    <span class="hljs-type">int</span> close_log;<br><br>    <span class="hljs-comment">//并发模型选择</span><br>    <span class="hljs-type">int</span> actor_model;<br>&#125;;<br><br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br></code></pre></td></tr></table></figure><h3 id="config-cpp"><a href="#config-cpp" class="headerlink" title="config.cpp"></a>config.cpp</h3><p>构造参数里作出了对于各种初始模式的设定，并且在并发模式处理中，作者给出了 reactor 和 proactor 两种方式。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;config.h&quot;</span></span><br><br>Config::<span class="hljs-built_in">Config</span>() &#123;<br>    <span class="hljs-comment">//端口号,默认9006</span><br>    PORT = <span class="hljs-number">9006</span>;<br><br>    <span class="hljs-comment">//数据库校验方式，默认同步</span><br>    SQLVerify = <span class="hljs-number">0</span>;<br><br>    <span class="hljs-comment">//日志写入方式，默认同步</span><br>    LOGWrite = <span class="hljs-number">0</span>;<br><br>    <span class="hljs-comment">//触发组合模式,默认listenfd LT + connfd LT</span><br>    TRIGMode = <span class="hljs-number">0</span>;<br><br>    <span class="hljs-comment">//listenfd触发模式，默认LT</span><br>    LISTENTrigmode = <span class="hljs-number">0</span>;<br><br>    <span class="hljs-comment">//connfd触发模式，默认LT</span><br>    CONNTrigmode = <span class="hljs-number">0</span>;<br><br>    <span class="hljs-comment">//优雅关闭链接，默认不使用</span><br>    OPT_LINGER = <span class="hljs-number">0</span>;<br><br>    <span class="hljs-comment">//数据库连接池数量,默认8</span><br>    sql_num = <span class="hljs-number">8</span>;<br><br>    <span class="hljs-comment">//线程池内的线程数量,默认8</span><br>    thread_num = <span class="hljs-number">8</span>;<br><br>    <span class="hljs-comment">//关闭日志,默认不关闭</span><br>    close_log = <span class="hljs-number">0</span>;<br><br>    <span class="hljs-comment">//并发模型,默认是proactor</span><br>    actor_model = <span class="hljs-number">0</span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Config::parse_arg</span><span class="hljs-params">(<span class="hljs-type">int</span> argc, <span class="hljs-type">char</span> *argv[])</span> </span>&#123;<br>    <span class="hljs-type">int</span> opt;<br>    <span class="hljs-type">const</span> <span class="hljs-type">char</span> *str = <span class="hljs-string">&quot;p:v:l:m:o:s:t:c:a:&quot;</span>;<br>    <span class="hljs-keyword">while</span> ((opt = <span class="hljs-built_in">getopt</span>(argc, argv, str)) != <span class="hljs-number">-1</span>) &#123;<br>        <span class="hljs-keyword">switch</span> (opt) &#123;<br>            <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;p&#x27;</span>: &#123;<br>                PORT = <span class="hljs-built_in">atoi</span>(optarg);<br>                <span class="hljs-keyword">break</span>;<br>            &#125;<br>            <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;v&#x27;</span>: &#123;<br>                SQLVerify = <span class="hljs-built_in">atoi</span>(optarg);<br>                <span class="hljs-keyword">break</span>;<br>            &#125;<br>            <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;l&#x27;</span>: &#123;<br>                LOGWrite = <span class="hljs-built_in">atoi</span>(optarg);<br>                <span class="hljs-keyword">break</span>;<br>            &#125;<br>            <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;m&#x27;</span>: &#123;<br>                TRIGMode = <span class="hljs-built_in">atoi</span>(optarg);<br>                <span class="hljs-keyword">break</span>;<br>            &#125;<br>            <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;o&#x27;</span>: &#123;<br>                OPT_LINGER = <span class="hljs-built_in">atoi</span>(optarg);<br>                <span class="hljs-keyword">break</span>;<br>            &#125;<br>            <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;s&#x27;</span>: &#123;<br>                sql_num = <span class="hljs-built_in">atoi</span>(optarg);<br>                <span class="hljs-keyword">break</span>;<br>            &#125;<br>            <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;t&#x27;</span>: &#123;<br>                thread_num = <span class="hljs-built_in">atoi</span>(optarg);<br>                <span class="hljs-keyword">break</span>;<br>            &#125;<br>            <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;c&#x27;</span>: &#123;<br>                close_log = <span class="hljs-built_in">atoi</span>(optarg);<br>                <span class="hljs-keyword">break</span>;<br>            &#125;<br>            <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;a&#x27;</span>: &#123;<br>                actor_model = <span class="hljs-built_in">atoi</span>(optarg);<br>                <span class="hljs-keyword">break</span>;<br>            &#125;<br>            <span class="hljs-keyword">default</span>:<br>                <span class="hljs-keyword">break</span>;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="main-模块"><a href="#main-模块" class="headerlink" title="main 模块"></a>main 模块</h2><p>main 模块的主要功能是驱动 Sever。WebServer 被单独作为一个类实现，并且封装好了调度函数。也就是说，main 函数相当于一个开关，打开服务器让它进入了 listen 状态，同时也打开了数据库的开关。当然，这个开关的信息，来自于 config。</p><h3 id="main-cpp"><a href="#main-cpp" class="headerlink" title="main.cpp"></a>main.cpp</h3><p>这里的命令行解析是给数据库的运行方式传参，当然可以什么都不传，不传默认使用 config 的参数配置。首先初始化一个服务器对象，启动日志服务，连接数据库，初始化线程池，然后设置运行模式，之后就是启动监听和进入工作循环（事务循环）。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;config.h&quot;</span></span><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-type">int</span> argc, <span class="hljs-type">char</span> *argv[])</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-comment">//需要修改的数据库信息,登录名,密码,库名</span><br>    string user = <span class="hljs-string">&quot;root&quot;</span>;<br>    string passwd = <span class="hljs-string">&quot;root&quot;</span>;<br>    string databasename = <span class="hljs-string">&quot;qgydb&quot;</span>;<br><br>    <span class="hljs-comment">//命令行解析</span><br>    Config config;<br>    config.<span class="hljs-built_in">parse_arg</span>(argc, argv);<br><br>    WebServer server;<br><br>    <span class="hljs-comment">//初始化</span><br>    server.<span class="hljs-built_in">init</span>(config.PORT, user, passwd, databasename, config.LOGWrite, config.SQLVerify,<br>                config.OPT_LINGER, config.TRIGMode,  config.sql_num,  config.thread_num,<br>                config.close_log, config.actor_model);<br><br><br>    <span class="hljs-comment">//日志</span><br>    server.<span class="hljs-built_in">log_write</span>();<br><br>    <span class="hljs-comment">//数据库</span><br>    server.<span class="hljs-built_in">sql_pool</span>();<br><br>    <span class="hljs-comment">//线程池</span><br>    server.<span class="hljs-built_in">thread_pool</span>();<br><br>    <span class="hljs-comment">//触发模式</span><br>    server.<span class="hljs-built_in">trig_mode</span>();<br><br>    <span class="hljs-comment">//监听</span><br>    server.<span class="hljs-built_in">eventListen</span>();<br><br>    <span class="hljs-comment">//运行</span><br>    server.<span class="hljs-built_in">eventLoop</span>();<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="WebServer-模块"><a href="#WebServer-模块" class="headerlink" title="WebServer 模块"></a>WebServer 模块</h2><p>这是服务器的关键部分，集成了各种复杂模块，按顺序依次调度。</p><h3 id="trig-mode-函数"><a href="#trig-mode-函数" class="headerlink" title="trig_mode 函数"></a>trig_mode 函数</h3><p>对应四种组合模式</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">WebServer::trig_mode</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-comment">//LT + LT</span><br>    <span class="hljs-keyword">if</span> (<span class="hljs-number">0</span> == m_TRIGMode)<br>    &#123;<br>        m_LISTENTrigmode = <span class="hljs-number">0</span>;<br>        m_CONNTrigmode = <span class="hljs-number">0</span>;<br>    &#125;<br>    <span class="hljs-comment">//LT + ET</span><br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (<span class="hljs-number">1</span> == m_TRIGMode)<br>    &#123;<br>        m_LISTENTrigmode = <span class="hljs-number">0</span>;<br>        m_CONNTrigmode = <span class="hljs-number">1</span>;<br>    &#125;<br>    <span class="hljs-comment">//ET + LT</span><br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (<span class="hljs-number">2</span> == m_TRIGMode)<br>    &#123;<br>        m_LISTENTrigmode = <span class="hljs-number">1</span>;<br>        m_CONNTrigmode = <span class="hljs-number">0</span>;<br>    &#125;<br>    <span class="hljs-comment">//ET + ET</span><br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (<span class="hljs-number">3</span> == m_TRIGMode)<br>    &#123;<br>        m_LISTENTrigmode = <span class="hljs-number">1</span>;<br>        m_CONNTrigmode = <span class="hljs-number">1</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="eventListen-函数"><a href="#eventListen-函数" class="headerlink" title="eventListen 函数"></a>eventListen 函数</h3><p>eventListen 根据名字知道是实现监听事务的部分。</p><ul><li>首先是处理连接关闭部分，将剩余未处理完的数据发送完成再退出，或者在内核停留一段时间确保消息传达。</li><li>其次调用 epoll，将 lfd 上树，这里的上树封装 addfd 目的是为了可以更改模式。</li><li>之后就是创建了管道，这里牵扯到进程间通信的问题。这么做的好处就是统一事件源。因为正常情况下，信号处理与 IO 处理不走一条路。</li></ul><p><strong>这里的信号主要是超时问题</strong>，具体的做法是，信号处理函数使用管道将信号传递给主循环，信号处理函数往管道的写端写入信号值，主循环则从管道的读端读出信号值，使用 I&#x2F;O 复用系统调用来监听管道读端的可读事件，这样信号事件与其他文件描述符都可以通过 epoll 来监测，从而实现统一处理。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">WebServer::eventListen</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-comment">//网络编程基础步骤</span><br>    m_listenfd = <span class="hljs-built_in">socket</span>(PF_INET, SOCK_STREAM, <span class="hljs-number">0</span>);<br>    <span class="hljs-comment">//如果它的条件返回错误，则终止程序执行</span><br>    <span class="hljs-built_in">assert</span>(m_listenfd &gt;= <span class="hljs-number">0</span>);<br><br>    <span class="hljs-comment">//优雅关闭连接</span><br>    <span class="hljs-keyword">if</span> (<span class="hljs-number">0</span> == m_OPT_LINGER)<br>    &#123;<br>        <span class="hljs-comment">//底层会将未发送完的数据发送完成后再释放资源，也就是优雅的退出</span><br>        <span class="hljs-keyword">struct</span> <span class="hljs-title class_">linger</span> tmp = &#123;<span class="hljs-number">0</span>, <span class="hljs-number">1</span>&#125;;<br>        <span class="hljs-built_in">setsockopt</span>(m_listenfd, SOL_SOCKET, SO_LINGER, &amp;tmp, <span class="hljs-built_in">sizeof</span>(tmp));<br>    &#125;<br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (<span class="hljs-number">1</span> == m_OPT_LINGER)<br>    &#123;<br>        <span class="hljs-comment">//这种方式下，在调用closesocket的时候不会立刻返回，内核会延迟一段时间，这个时间就由l_linger得值来决定。</span><br>        <span class="hljs-comment">//如果超时时间到达之前，发送完未发送的数据(包括FIN包)并得到另一端的确认，closesocket会返回正确，socket描述符优雅性退出。</span><br>        <span class="hljs-comment">//否则，closesocket会直接返回 错误值，未发送数据丢失，socket描述符被强制性退出。需要注意的时，如果socket描述符被设置为非堵塞型，则closesocket会直接返回值。</span><br>        <span class="hljs-keyword">struct</span> linger tmp = &#123;<span class="hljs-number">1</span>, <span class="hljs-number">1</span>&#125;;<br>        <span class="hljs-built_in">setsockopt</span>(m_listenfd, SOL_SOCKET, SO_LINGER, &amp;tmp, <span class="hljs-built_in">sizeof</span>(tmp));<br>    &#125;<br><br>    <span class="hljs-type">int</span> ret = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">struct</span> <span class="hljs-title class_">sockaddr_in</span> address;<br>    <span class="hljs-comment">// bzero() 会将内存块（字符串）的前n个字节清零;</span><br>    <span class="hljs-comment">// s为内存（字符串）指针，n 为需要清零的字节数。</span><br>    <span class="hljs-comment">// 在网络编程中会经常用到。</span><br>    <span class="hljs-built_in">bzero</span>(&amp;address, <span class="hljs-built_in">sizeof</span>(address));<br>    address.sin_family = AF_INET;<br>    address.sin_addr.s_addr = <span class="hljs-built_in">htonl</span>(INADDR_ANY);<br>    address.sin_port = <span class="hljs-built_in">htons</span>(m_port);<br><br>    <span class="hljs-type">int</span> flag = <span class="hljs-number">1</span>;<br>    <span class="hljs-comment">//允许重用本地地址和端口</span><br>    <span class="hljs-built_in">setsockopt</span>(m_listenfd, SOL_SOCKET, SO_REUSEADDR, &amp;flag, <span class="hljs-built_in">sizeof</span>(flag));<br>    <span class="hljs-comment">//传统绑定步骤</span><br>    ret = <span class="hljs-built_in">bind</span>(m_listenfd, (<span class="hljs-keyword">struct</span> sockaddr *)&amp;address, <span class="hljs-built_in">sizeof</span>(address));<br>    <span class="hljs-built_in">assert</span>(ret &gt;= <span class="hljs-number">0</span>);<br>    <span class="hljs-comment">//传统监听步骤</span><br>    ret = <span class="hljs-built_in">listen</span>(m_listenfd, <span class="hljs-number">5</span>);<br>    <span class="hljs-built_in">assert</span>(ret &gt;= <span class="hljs-number">0</span>);<br><br>    <span class="hljs-comment">//工具类,信号和描述符基础操作</span><br>    Utils::u_pipefd = m_pipefd;<br>    Utils::u_epollfd = m_epollfd;<br><br>    utils.<span class="hljs-built_in">init</span>(TIMESLOT);<br><br>    <span class="hljs-comment">//epoll创建内核事件表</span><br>    epoll_event events[MAX_EVENT_NUMBER];<br>    m_epollfd = <span class="hljs-built_in">epoll_create</span>(<span class="hljs-number">5</span>);<br>    <span class="hljs-built_in">assert</span>(m_epollfd != <span class="hljs-number">-1</span>);<br><br>    <span class="hljs-comment">//将lfd上树</span><br>    utils.<span class="hljs-built_in">addfd</span>(m_epollfd, m_listenfd, <span class="hljs-literal">false</span>, m_LISTENTrigmode);<br>    http_conn::m_epollfd = m_epollfd;<br><br>    <span class="hljs-comment">//创建管道套接字</span><br>    ret = <span class="hljs-built_in">socketpair</span>(PF_UNIX, SOCK_STREAM, <span class="hljs-number">0</span>, m_pipefd);<br>    <span class="hljs-built_in">assert</span>(ret != <span class="hljs-number">-1</span>);<br>    <span class="hljs-comment">//设置管道写端为非阻塞，为什么写端要非阻塞？</span><br>    <span class="hljs-comment">//send是将信息发送给套接字缓冲区，如果缓冲区满了，则会阻塞，</span><br>    <span class="hljs-comment">//这时候会进一步增加信号处理函数的执行时间，为此，将其修改为非阻塞。</span><br>    utils.<span class="hljs-built_in">setnonblocking</span>(m_pipefd[<span class="hljs-number">1</span>]);<br>    <span class="hljs-comment">//设置管道读端为ET非阻塞 统一事件源</span><br>    utils.<span class="hljs-built_in">addfd</span>(m_epollfd, m_pipefd[<span class="hljs-number">0</span>], <span class="hljs-literal">false</span>, <span class="hljs-number">0</span>);<br><br>    utils.<span class="hljs-built_in">addsig</span>(SIGPIPE, SIG_IGN);<br>    <span class="hljs-comment">//传递给主循环的信号值，这里只关注SIGALRM和SIGTERM</span><br>    utils.<span class="hljs-built_in">addsig</span>(SIGALRM, utils.sig_handler, <span class="hljs-literal">false</span>);<br>    utils.<span class="hljs-built_in">addsig</span>(SIGTERM, utils.sig_handler, <span class="hljs-literal">false</span>);<br><br>    <span class="hljs-comment">//每隔TIMESLOT时间触发SIGALRM信号</span><br>    <span class="hljs-built_in">alarm</span>(TIMESLOT);<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="eventLoop-函数"><a href="#eventLoop-函数" class="headerlink" title="eventLoop 函数"></a>eventLoop 函数</h3><p>这个函数可以说是始终伴随着程序始终。只要服务器不关，我就一直不退出，因为我退出了，main 也退出了。可以看出，这一函数的逻辑就是不断的处理产生事件的节点，而在 epoll_wait 返回后，我们主要处理三种事件：io 事件，信号，新的连接，也就是在 for 循环中的三次判断，并且每次处理完一组后，我们会刷新定时。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">WebServer::eventLoop</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">bool</span> timeout = <span class="hljs-literal">false</span>;<br>    <span class="hljs-type">bool</span> stop_server = <span class="hljs-literal">false</span>;<br><br>    <span class="hljs-keyword">while</span> (!stop_server)<br>    &#123;<br>        <span class="hljs-comment">//监测发生事件的文件描述符</span><br>        <span class="hljs-type">int</span> number = <span class="hljs-built_in">epoll_wait</span>(m_epollfd, events, MAX_EVENT_NUMBER, <span class="hljs-number">-1</span>);<br>        <span class="hljs-keyword">if</span> (number &lt; <span class="hljs-number">0</span> &amp;&amp; errno != EINTR)<br>        &#123;<br>            <span class="hljs-built_in">LOG_ERROR</span>(<span class="hljs-string">&quot;%s&quot;</span>, <span class="hljs-string">&quot;epoll failure&quot;</span>);<br>            <span class="hljs-keyword">break</span>;<br>        &#125;<br><br>        <span class="hljs-comment">//轮询有事件产生的文件描述符</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; number; i++)<br>        &#123;<br>            <span class="hljs-type">int</span> sockfd = events[i].data.fd;<br><br>            <span class="hljs-comment">//处理新到的客户连接</span><br>            <span class="hljs-keyword">if</span> (sockfd == m_listenfd)<br>            &#123;<br>                <span class="hljs-type">bool</span> flag = <span class="hljs-built_in">dealclinetdata</span>();<br>                <span class="hljs-keyword">if</span> (<span class="hljs-literal">false</span> == flag)<br>                    <span class="hljs-keyword">continue</span>;<br>            &#125;<br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (events[i].events &amp; (EPOLLRDHUP | EPOLLHUP | EPOLLERR))<br>            &#123;<br>                <span class="hljs-comment">//服务器端关闭连接，移除对应的定时器</span><br>                util_timer *timer = users_timer[sockfd].timer;<br>                <span class="hljs-built_in">deal_timer</span>(timer, sockfd);<br>            &#125;<br>            <span class="hljs-comment">//处理信号</span><br>            <span class="hljs-comment">//管道读端对应文件描述符发生读事件</span><br>            <span class="hljs-comment">//因为统一了事件源，信号处理当成读事件来处理</span><br>            <span class="hljs-comment">//就是信号回调函数哪里不立即处理而是写到：pipe的写端</span><br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> ((sockfd == m_pipefd[<span class="hljs-number">0</span>]) &amp;&amp; (events[i].events &amp; EPOLLIN))<br>            &#123;<br>                <span class="hljs-type">bool</span> flag = <span class="hljs-built_in">dealwithsignal</span>(timeout, stop_server);<br>                <span class="hljs-keyword">if</span> (<span class="hljs-literal">false</span> == flag)<br>                    <span class="hljs-built_in">LOG_ERROR</span>(<span class="hljs-string">&quot;%s&quot;</span>, <span class="hljs-string">&quot;dealclientdata failure&quot;</span>);<br>            &#125;<br>            <span class="hljs-comment">//处理客户连接上接收到的数据</span><br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (events[i].events &amp; EPOLLIN)<br>            &#123;<br>                <span class="hljs-built_in">dealwithread</span>(sockfd);<br>            &#125;<br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (events[i].events &amp; EPOLLOUT)<br>            &#123;<br>                <span class="hljs-built_in">dealwithwrite</span>(sockfd);<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">if</span> (timeout)<br>        &#123;<br>            utils.<span class="hljs-built_in">timer_handler</span>();<br><br>            <span class="hljs-built_in">LOG_INFO</span>(<span class="hljs-string">&quot;%s&quot;</span>, <span class="hljs-string">&quot;timer tick&quot;</span>);<br><br>            timeout = <span class="hljs-literal">false</span>;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="dealclinetdata-函数"><a href="#dealclinetdata-函数" class="headerlink" title="dealclinetdata 函数"></a>dealclinetdata 函数</h3><p>函数处理数据连接部分，建立连接分为两种模式 ET 和 LT：</p><blockquote><p>LT 模式：即<strong>水平触发模式</strong>，当 epoll_wait 检测到监听文件描述符上有事件发生时通知应用程序，应用程序可以不理解处理该事件，下次调用 epoll_wait 时该事件还会被通告直到该事件被处理。</p><p>ET 模式：即<strong>边缘触发模式</strong>，当 epoll_wait 检测到事件发生告知应用程序后应用程序必须立即处理该事件，后续的 epoll_wait 将不会再向应用程序告知这一事件。</p></blockquote><p>LT 是系统默认，工作在这种方式下，程序员不易出问题，在接收数据时，只要 socket 输入缓存有数据，都能够获得 EPOLLIN 的持续通知， 同样在发送数据时，只要发送缓存够用，都会有持续不间断的 EPOLLOUT 通知。</p><p>ET 是另外一种触发方式，比 EPOLLLT 要高效很多，对程序员的要求也多些，程序员必须小心使用，因为工作在此种方式下时，在接收数据时，如果有数据只会通知一次，假如 read 时未读完数据，那么不会再有 EPOLLIN 的通知了，直到下次有新的数据到达时为止；当发送数据时，如果发送缓存未满也只有一次 EPOLLOUT 的通知，除非你把发送缓存塞满了，才会有第二次 EPOLLOUT 通知的机会，所以在此方式下 read 和 write 时都要处理好。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">WebServer::dealclinetdata</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">struct</span> <span class="hljs-title class_">sockaddr_in</span> client_address;<br>    <span class="hljs-type">socklen_t</span> client_addrlength = <span class="hljs-built_in">sizeof</span>(client_address);<br>    <span class="hljs-comment">//LT</span><br>    <span class="hljs-keyword">if</span> (<span class="hljs-number">0</span> == m_LISTENTrigmode)<br>    &#123;<br>        <span class="hljs-type">int</span> connfd = <span class="hljs-built_in">accept</span>(m_listenfd, (<span class="hljs-keyword">struct</span> sockaddr *)&amp;client_address, &amp;client_addrlength);<br>        <span class="hljs-keyword">if</span> (connfd &lt; <span class="hljs-number">0</span>)<br>        &#123;<br>            <span class="hljs-built_in">LOG_ERROR</span>(<span class="hljs-string">&quot;%s:errno is:%d&quot;</span>, <span class="hljs-string">&quot;accept error&quot;</span>, errno);<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        &#125;<br>        <span class="hljs-keyword">if</span> (http_conn::m_user_count &gt;= MAX_FD)<br>        &#123;<br>            utils.<span class="hljs-built_in">show_error</span>(connfd, <span class="hljs-string">&quot;Internal server busy&quot;</span>);<br>            <span class="hljs-built_in">LOG_ERROR</span>(<span class="hljs-string">&quot;%s&quot;</span>, <span class="hljs-string">&quot;Internal server busy&quot;</span>);<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        &#125;<br>        <span class="hljs-built_in">timer</span>(connfd, client_address);<br>    &#125;<br><br>    <span class="hljs-comment">//ET</span><br>    <span class="hljs-keyword">else</span><br>    &#123;<br>        <span class="hljs-keyword">while</span> (<span class="hljs-number">1</span>)<br>        &#123;<br>            <span class="hljs-type">int</span> connfd = <span class="hljs-built_in">accept</span>(m_listenfd, (<span class="hljs-keyword">struct</span> sockaddr *)&amp;client_address, &amp;client_addrlength);<br>            <span class="hljs-keyword">if</span> (connfd &lt; <span class="hljs-number">0</span>)<br>            &#123;<br>                <span class="hljs-built_in">LOG_ERROR</span>(<span class="hljs-string">&quot;%s:errno is:%d&quot;</span>, <span class="hljs-string">&quot;accept error&quot;</span>, errno);<br>                <span class="hljs-keyword">break</span>;<br>            &#125;<br>            <span class="hljs-keyword">if</span> (http_conn::m_user_count &gt;= MAX_FD)<br>            &#123;<br>                utils.<span class="hljs-built_in">show_error</span>(connfd, <span class="hljs-string">&quot;Internal server busy&quot;</span>);<br>                <span class="hljs-built_in">LOG_ERROR</span>(<span class="hljs-string">&quot;%s&quot;</span>, <span class="hljs-string">&quot;Internal server busy&quot;</span>);<br>                <span class="hljs-keyword">break</span>;<br>            &#125;<br>            <span class="hljs-built_in">timer</span>(connfd, client_address);<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="dealwithread-函数"><a href="#dealwithread-函数" class="headerlink" title="dealwithread 函数"></a>dealwithread 函数</h3><p>按照之前的思想，对于整个并发模式的思路，存在两个模式的切换：reactor 与 preactor：</p><ul><li><strong>Reactor 是非阻塞同步网络模式，感知的是就绪可读写事件</strong>。在每次感知到有事件发生（比如可读就绪事件）后，就需要应用进程主动调用 read 方法来完成数据的读取，也就是要应用进程主动将 socket 接收缓存中的数据读到应用进程内存中，这个过程是同步的，读取完数据后应用进程才能处理数据。</li><li><strong>Proactor 是异步网络模式，感知的是已完成的读写事件</strong>。在发起异步读写请求时，需要传入数据缓冲区的地址（用来存放结果数据）等信息，这样系统内核才可以自动帮我们把数据的读写工作完成，这里的读写工作全程由操作系统来做，并不需要像 Reactor 那样还需要应用进程主动发起 read&#x2F;write 来读写数据，操作系统完成读写工作后，就会通知应用进程直接处理数据。</li></ul><p>因此，<strong>Reactor 可以理解为「来了事件操作系统通知应用进程，让应用进程来处理」</strong>，而 <strong>Proactor 可以理解为「来了事件操作系统来处理，处理完再通知应用进程」</strong>。这里的「事件」就是有新连接、有数据可读、有数据可写的这些 I&#x2F;O 事件这里的「处理」包含从驱动读取到内核以及从内核读取到用户空间。</p><p>它们的区别是对于数据的读取者是谁，对于 reactor 是同步线程来完成，整个读就绪放在请求列表上；而对于 preactor 则是由主线程，也就是当前的 WebServer 进行一次调用，读取后将读完成放入请求队列上。同样，对于当前的 fd 我们要对他进行时间片的调整。同样的，当时间到期时，在定时器对象中，会有对应的下树操作。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">WebServer::dealwithread</span><span class="hljs-params">(<span class="hljs-type">int</span> sockfd)</span></span><br><span class="hljs-function"></span>&#123;<br>    util_timer *timer = users_timer[sockfd].timer;<br><br>    <span class="hljs-comment">//reactor</span><br>    <span class="hljs-keyword">if</span> (<span class="hljs-number">1</span> == m_actormodel)<br>    &#123;<br>        <span class="hljs-keyword">if</span> (timer)<br>        &#123;<br>            <span class="hljs-built_in">adjust_timer</span>(timer);<br>        &#125;<br><br>        <span class="hljs-comment">//若监测到读事件，将该事件放入请求队列</span><br>        m_pool-&gt;<span class="hljs-built_in">append</span>(users + sockfd, <span class="hljs-number">0</span>);<br><br>        <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>)<br>        &#123;<br>            <span class="hljs-keyword">if</span> (<span class="hljs-number">1</span> == users[sockfd].improv)<br>            &#123;<br>                <span class="hljs-keyword">if</span> (<span class="hljs-number">1</span> == users[sockfd].timer_flag)<br>                &#123;<br>                    <span class="hljs-built_in">deal_timer</span>(timer, sockfd);<br>                    users[sockfd].timer_flag = <span class="hljs-number">0</span>;<br>                &#125;<br>                users[sockfd].improv = <span class="hljs-number">0</span>;<br>                <span class="hljs-keyword">break</span>;<br>            &#125;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">else</span><br>    &#123;<br>        <span class="hljs-comment">//proactor</span><br>        <span class="hljs-keyword">if</span> (users[sockfd].<span class="hljs-built_in">read_once</span>())<br>        &#123;<br>            <span class="hljs-built_in">LOG_INFO</span>(<span class="hljs-string">&quot;deal with the client(%s)&quot;</span>, <span class="hljs-built_in">inet_ntoa</span>(users[sockfd].<span class="hljs-built_in">get_address</span>()-&gt;sin_addr));<br><br>            <span class="hljs-comment">//若监测到读事件，将该事件放入请求队列</span><br>            m_pool-&gt;<span class="hljs-built_in">append_p</span>(users + sockfd);<br><br>            <span class="hljs-keyword">if</span> (timer)<br>            &#123;<br>                <span class="hljs-built_in">adjust_timer</span>(timer);<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">else</span><br>        &#123;<br>            <span class="hljs-built_in">deal_timer</span>(timer, sockfd);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="dealwithwrite-函数"><a href="#dealwithwrite-函数" class="headerlink" title="dealwithwrite 函数"></a>dealwithwrite 函数</h3><p>逻辑与模式大致相同</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">WebServer::dealwithwrite</span><span class="hljs-params">(<span class="hljs-type">int</span> sockfd)</span></span><br><span class="hljs-function"></span>&#123;<br>    util_timer *timer = users_timer[sockfd].timer;<br>    <span class="hljs-comment">//reactor</span><br>    <span class="hljs-keyword">if</span> (<span class="hljs-number">1</span> == m_actormodel)<br>    &#123;<br>        <span class="hljs-keyword">if</span> (timer)<br>        &#123;<br>            <span class="hljs-built_in">adjust_timer</span>(timer);<br>        &#125;<br><br>        m_pool-&gt;<span class="hljs-built_in">append</span>(users + sockfd, <span class="hljs-number">1</span>);<br><br>        <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>)<br>        &#123;<br>            <span class="hljs-keyword">if</span> (<span class="hljs-number">1</span> == users[sockfd].improv)<br>            &#123;<br>                <span class="hljs-keyword">if</span> (<span class="hljs-number">1</span> == users[sockfd].timer_flag)<br>                &#123;<br>                    <span class="hljs-built_in">deal_timer</span>(timer, sockfd);<br>                    users[sockfd].timer_flag = <span class="hljs-number">0</span>;<br>                &#125;<br>                users[sockfd].improv = <span class="hljs-number">0</span>;<br>                <span class="hljs-keyword">break</span>;<br>            &#125;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">else</span><br>    &#123;<br>        <span class="hljs-comment">//proactor</span><br>        <span class="hljs-keyword">if</span> (users[sockfd].<span class="hljs-built_in">write</span>())<br>        &#123;<br>            <span class="hljs-built_in">LOG_INFO</span>(<span class="hljs-string">&quot;send data to the client(%s)&quot;</span>, <span class="hljs-built_in">inet_ntoa</span>(users[sockfd].<span class="hljs-built_in">get_address</span>()-&gt;sin_addr));<br><br>            <span class="hljs-keyword">if</span> (timer)<br>            &#123;<br>                <span class="hljs-built_in">adjust_timer</span>(timer);<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">else</span><br>        &#123;<br>            <span class="hljs-built_in">deal_timer</span>(timer, sockfd);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="dealwithsignal-函数"><a href="#dealwithsignal-函数" class="headerlink" title="dealwithsignal 函数"></a>dealwithsignal 函数</h3><p>与读写不同的是，这里的 signal 是处理函数，它不需要上队列。这里是通过管道的方式来告知 WebServer，管道由 epoll 监控。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">WebServer::dealwithsignal</span><span class="hljs-params">(<span class="hljs-type">bool</span> &amp;timeout, <span class="hljs-type">bool</span> &amp;stop_server)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span> ret = <span class="hljs-number">0</span>;<br>    <span class="hljs-type">int</span> sig;<br>    <span class="hljs-type">char</span> signals[<span class="hljs-number">1024</span>];<br>    <span class="hljs-comment">//从管道读端读出信号值，成功返回字节数，失败返回-1</span><br>    <span class="hljs-comment">//正常情况下，这里的ret返回值总是1，只有14和15两个ASCII码对应的字符</span><br>    ret = <span class="hljs-built_in">recv</span>(m_pipefd[<span class="hljs-number">0</span>], signals, <span class="hljs-built_in">sizeof</span>(signals), <span class="hljs-number">0</span>);<br>    <span class="hljs-keyword">if</span> (ret == <span class="hljs-number">-1</span>)<br>    &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (ret == <span class="hljs-number">0</span>)<br>    &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br>    <span class="hljs-keyword">else</span><br>    &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; ret; ++i)<br>        &#123;<br>            <span class="hljs-comment">//处理信号值对应的逻辑</span><br>            <span class="hljs-keyword">switch</span> (signals[i])<br>            &#123;<br>            <span class="hljs-keyword">case</span> SIGALRM:<br>            &#123;<br>                timeout = <span class="hljs-literal">true</span>;<br>                <span class="hljs-keyword">break</span>;<br>            &#125;<br>            <span class="hljs-keyword">case</span> SIGTERM:<br>            &#123;<br>                stop_server = <span class="hljs-literal">true</span>;<br>                <span class="hljs-keyword">break</span>;<br>            &#125;<br>            &#125;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="timer-函数"><a href="#timer-函数" class="headerlink" title="timer 函数"></a>timer 函数</h3><p>timer 在 accept 得到 cfd 的时候调用，这里不仅初始化了 cfd 的时间，而且也整体初始化了，即服务器完成三次握手，允许传输数据，并设置了超时时间。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">WebServer::timer</span><span class="hljs-params">(<span class="hljs-type">int</span> connfd, <span class="hljs-keyword">struct</span> sockaddr_in client_address)</span></span><br><span class="hljs-function"></span>&#123;<br>    users[connfd].<span class="hljs-built_in">init</span>(connfd, client_address, m_root, m_SQLVerify, m_CONNTrigmode, m_close_log, m_user, m_passWord, m_databaseName);<br><br>    <span class="hljs-comment">//初始化client_data数据</span><br>    <span class="hljs-comment">//创建定时器，设置回调函数和超时时间，绑定用户数据，将定时器添加到链表中</span><br>    users_timer[connfd].address = client_address;<br>    users_timer[connfd].sockfd = connfd;<br>    util_timer *timer = <span class="hljs-keyword">new</span> util_timer;<br>    timer-&gt;user_data = &amp;users_timer[connfd];<br>    timer-&gt;cb_func = cb_func;<br>    <span class="hljs-type">time_t</span> cur = <span class="hljs-built_in">time</span>(<span class="hljs-literal">NULL</span>);<br>    timer-&gt;expire = cur + <span class="hljs-number">3</span> * TIMESLOT;<br>    users_timer[connfd].timer = timer;<br>    utils.m_timer_lst.<span class="hljs-built_in">add_timer</span>(timer);<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="adjust-timer-函数"><a href="#adjust-timer-函数" class="headerlink" title="adjust_timer 函数"></a>adjust_timer 函数</h3><p>若有数据传输，则将定时器往后延迟 3 个单位，并对新的定时器在链表上的位置进行调整。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">WebServer::adjust_timer</span><span class="hljs-params">(util_timer *timer)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">time_t</span> cur = <span class="hljs-built_in">time</span>(<span class="hljs-literal">NULL</span>);<br>    timer-&gt;expire = cur + <span class="hljs-number">3</span> * TIMESLOT;<br>    utils.m_timer_lst.<span class="hljs-built_in">adjust_timer</span>(timer);<br><br>    <span class="hljs-built_in">LOG_INFO</span>(<span class="hljs-string">&quot;%s&quot;</span>, <span class="hljs-string">&quot;adjust timer once&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>webserverber</category>
      
    </categories>
    
    
    <tags>
      
      <tag>cpp</tag>
      
      <tag>linux</tag>
      
      <tag>网络编程</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>cpp 笔记</title>
    <link href="/cpp-note.html"/>
    <url>/cpp-note.html</url>
    
    <content type="html"><![CDATA[<p>刷代码随想录过程中记得笔记。</p><span id="more"></span><h3 id="常用函数"><a href="#常用函数" class="headerlink" title="常用函数"></a>常用函数</h3><ul><li><p>在<code>sort</code>中使用 lambda 表示式：<code>sort(arr.begin(), arr.end(), [](int a, int b)-&gt;bool &#123;return a &gt; b; &#125;);</code>。</p></li><li><p><code>s = s1.substr(pos, len)</code>从 pos 位置开始，长度为 len 的子串。</p></li><li><p><code>str[i] = tolower(str[i]);</code>大写字母转小写，<code>str[i] = toupper(str[i]);</code>小写字母转大写。</p></li><li><p><code>bool binary_search(arr.begin(), arrr.end(), 3)</code>返回 <strong>bool</strong>。</p></li><li><p>getline 按逗号分割字符串：</p></li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs cpp">vector&lt;string&gt; strs;<br><span class="hljs-function">stringstream <span class="hljs-title">ss</span><span class="hljs-params">(line)</span></span>;<br>string str;<br><span class="hljs-keyword">while</span> (<span class="hljs-built_in">getline</span>(ss, str, <span class="hljs-string">&#x27;,&#x27;</span>)) &#123;<br>     strs.<span class="hljs-built_in">push_back</span>(str);<br>&#125;<br></code></pre></td></tr></table></figure><ul><li><p>把 “ab” 换成 “####”：<code>str=str.replace(str.find(&quot;a&quot;),2,&quot;####&quot;);</code></p></li><li><p>有序列表中二分查找 <code>lower_bound (begin, last, val, compare)</code> 找到<mark>大于等于 val</mark>的位置，<code>upper_bound (begin, last, val, compare)</code>找到<mark>大于 val</mark>的位置。</p></li><li><p><code>uique (begin,last)</code> 左闭右开区间。</p></li><li><p><code>string.erase(pos)</code> <code>string.erase(first, last)</code>通过迭代器删除元素。</p></li><li><p><strong>remove 和 rease 搭配删除所有指定值，remove 将元素移到末尾，没有改变 size</strong>：</p></li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs cpp">vector&lt;<span class="hljs-type">int</span>&gt; vec = &#123; <span class="hljs-number">1</span>,<span class="hljs-number">1</span>,<span class="hljs-number">1</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>,<span class="hljs-number">6</span>,<span class="hljs-number">7</span>,<span class="hljs-number">8</span>&#125;;<br>vec.<span class="hljs-built_in">erase</span>(<span class="hljs-built_in">remove</span>(vec.<span class="hljs-built_in">begin</span>(), vec.<span class="hljs-built_in">end</span>(), <span class="hljs-number">1</span>), vec.<span class="hljs-built_in">end</span>());<br><span class="hljs-comment">// vec = &#123;3,4,5,6,7,8&#125;</span><br></code></pre></td></tr></table></figure><ul><li><p><code>nth_element(begin, last, nth, comp)</code>默认升序排列，找到第 nth 大的元素，移到第 nth 的位置。</p></li><li><p>利用 bitset 进行任意进制转二进制：</p></li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// stol() 第二个参数默认为 NULL，第三个默认 10 进制，可 8/16 进制</span><br><span class="hljs-function">bitset&lt;16&gt; <span class="hljs-title">bin</span><span class="hljs-params">(stol(t, <span class="hljs-literal">nullptr</span>, <span class="hljs-number">16</span>))</span></span>;   先转为 <span class="hljs-type">long</span>，通过 bitset 转为二进制 <span class="hljs-number">16</span> 位<br>string s = bin.<span class="hljs-built_in">to_string</span>();<br></code></pre></td></tr></table></figure><h3 id="ACM-模式输入输出"><a href="#ACM-模式输入输出" class="headerlink" title="ACM 模式输入输出"></a>ACM 模式输入输出</h3><ul><li><p>用 while 循环读取字符串时，输入<code>Ctrl+X</code>标志终止输入。</p></li><li><p><code>#include &lt;bits/stdc++.h&gt;</code>，万能头文件。</p></li><li><p><code>using namespace std;</code>，定义域名空间。</p></li><li><p><code>while (getchar() != &#39;\n&#39;) &#123; 判断换行符号&#125;</code>，<strong>读取一行内任意个数元素</strong>。</p></li><li><p><code>getchar()</code>，从缓冲区取一个字符，缓冲区少一个字符。</p></li></ul><h3 id="List"><a href="#List" class="headerlink" title="List"></a>List</h3><ul><li><p>list 的成员函数 remove, erase, pop_front, pop_back, clear 自动释放元素内存空间，同时元素迭代器失效。</p></li><li><p>删除某个元素，仅仅会删除元素的迭代器失效。插入、删除元素不会对其他元素造成影响。</p></li></ul><h3 id="二分法"><a href="#二分法" class="headerlink" title="二分法"></a>二分法</h3><p>注意<code>while (left &lt;= right)</code>取<strong>等号</strong>，查找值是否存在。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">search</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums, <span class="hljs-type">int</span> target)</span> </span>&#123;<br>    <span class="hljs-type">int</span> left = <span class="hljs-number">0</span>;<br>    <span class="hljs-type">int</span> right = nums.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>; <span class="hljs-comment">// 定义 target 在左闭右闭的间里，[left, right]</span><br>    <span class="hljs-keyword">while</span> (left &lt;= right) &#123; <span class="hljs-comment">// 当 left==right，区间 [left, right] 依然有效，所以用 &lt;=</span><br>        <span class="hljs-type">int</span> mid = left + ((right - left) / <span class="hljs-number">2</span>); <span class="hljs-comment">// 防止溢出 等同于 (left + right)/2</span><br>        <span class="hljs-keyword">if</span> (nums[mid] &gt; target) right = middle - <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (nums[mid] &lt; target) left = middle + <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">return</span> mid;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h3><p>注意<code>while (left &lt; right)</code>，交换左右元素，至少有<strong>两个</strong>元素，才能交换，因此不能取等号。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">partition</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums, <span class="hljs-type">int</span> left, <span class="hljs-type">int</span> right)</span> </span>&#123;<br>        <span class="hljs-type">int</span> pivot = nums[left];<br>        <span class="hljs-keyword">while</span> (left &lt; right) &#123;<br>            <span class="hljs-keyword">while</span> (left &lt; right &amp;&amp; pivot &lt;= nums[right])    right--;<br>            nums[left] = nums[right];<br>            <span class="hljs-keyword">while</span> (left &lt; right &amp;&amp; pivot &gt;= nums[left])     left++;<br>            nums[right] = nums[left];<br>        &#125;<br>        nums[left] = pivot;<br>        <span class="hljs-keyword">return</span> left;<br>    &#125;<br><span class="hljs-comment">// 递归</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">quicksort</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums, <span class="hljs-type">int</span> left, <span class="hljs-type">int</span> right)</span> </span>&#123;<br>    <span class="hljs-type">int</span> pivot;<br>    <span class="hljs-keyword">if</span> (left &lt; right) &#123;<br>        pivot = <span class="hljs-built_in">partition</span>(nums, left, right);<br>        <span class="hljs-built_in">quicksort</span>(nums, left, pivot - <span class="hljs-number">1</span>);<br>        <span class="hljs-built_in">quicksort</span>(nums, pivot + <span class="hljs-number">1</span>, right);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>有重复元素时多加 ‘&#x3D;‘ ，<strong>多加不会出错</strong>。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">while</span> (left &lt; right &amp;&amp; pivot &lt;= nums[right])    right--;<br><span class="hljs-keyword">while</span> (left &lt; right &amp;&amp; pivot &gt;= nums[left])     left++;<br></code></pre></td></tr></table></figure><h3 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h3><ul><li><p><code>for (int i = 0; i &lt;= arr.size() - k; i += k)</code>，每次遍历 k 个元素，注意 <code>i&lt;=arr.size()-k</code>。</p></li><li><p><code>priority_queue&lt;int,vector&lt;int&gt;，less&lt;int&gt;&gt;</code>，第二个参数是存储容器，第三个是比较函数，默认<code>less&lt;int&gt;</code>大顶堆，自顶向下变小，<code>greater&lt;int&gt;</code>小顶堆，自顶向下变大。</p></li><li><p>求数组中三数之和（固定第一个，再用双指针），四数之和，<strong>先排序</strong>，方便后面剪枝。</p></li></ul><h3 id="链表"><a href="#链表" class="headerlink" title="链表"></a>链表</h3><ul><li>自定义链表结构：</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">ListNode</span> &#123;<br>    <span class="hljs-type">int</span> val;<br>    ListNode* next;<br>    <span class="hljs-built_in">ListNode</span>(<span class="hljs-type">int</span> val):<span class="hljs-built_in">val</span>(val), <span class="hljs-built_in">next</span>(<span class="hljs-literal">nullptr</span>)&#123;&#125;<br>&#125;;<br>ListNode* node = <span class="hljs-keyword">new</span> <span class="hljs-built_in">ListNode</span>(val);<br><br><span class="hljs-comment">//使用虚拟头节点</span><br>ListNode* dummyHead = <span class="hljs-keyword">new</span> <span class="hljs-built_in">ListNode</span>(<span class="hljs-number">0</span>);<br>dummyHead-&gt;next = head;<br>ListNode* cur = dummyHead;<br></code></pre></td></tr></table></figure><ul><li>定义指针数组（哈希）：</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs cpp">vector&lt;ListNode*&gt; vec;<br>ListNode* cur=head;<br><span class="hljs-keyword">while</span>(cur)&#123;<br>    vec.<span class="hljs-built_in">push_back</span>(cur);<br>    cur=cur-&gt;next;<br>&#125;<br></code></pre></td></tr></table></figure><p>应用：对链表每 K 个结点翻转，定义一个指针数组，对数组翻转，变相对链表操作。</p><h3 id="String"><a href="#String" class="headerlink" title="String"></a>String</h3><ul><li>双指针法判断<strong>回文</strong>：</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">countSubstrings</span><span class="hljs-params">(string s)</span> </span>&#123;<br>    <span class="hljs-type">int</span> result = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; s.<span class="hljs-built_in">size</span>(); i++) &#123;<br>        result += <span class="hljs-built_in">extend</span>(s, i, i); <span class="hljs-comment">// 以 i 为中心</span><br>        result += <span class="hljs-built_in">extend</span>(s, i, i + <span class="hljs-number">1</span>); <span class="hljs-comment">// 以 i 和 i+1 为中心</span><br>    &#125;<br>    <span class="hljs-keyword">return</span> result;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">extend</span><span class="hljs-params">(<span class="hljs-type">const</span> string&amp; s, <span class="hljs-type">int</span> i, <span class="hljs-type">int</span> j)</span> </span>&#123;<br>    <span class="hljs-type">int</span> res = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">while</span> (i &gt;= <span class="hljs-number">0</span> &amp;&amp; j &lt; s.<span class="hljs-built_in">size</span>() &amp;&amp; s[i] == s[j]) &#123;<br>        i--;<br>        j++;<br>        res++;<br>    &#125;<br>    <span class="hljs-keyword">return</span> res;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li><p><code>if(str.find(&quot;a&quot;) != -1)</code>返回结果是 <strong>-1</strong> 不是 end()。</p></li><li><p><code>s.substr(start,len)</code>，从 start 位置取长度为 len 的子串。</p></li><li><p>查找字符串 S 是否包含子串 sub，S+S 拼接破环头尾，判断<code>S.find(sub)</code>存在。</p></li><li><p><strong>stoll</strong>：string 型变量转换为 long long 型变量（常用），兼容 int long；<br><strong>stod</strong>：string 型变量转换为 double 型变量（常用），兼容 float。</p></li></ul><h3 id="优先队列（堆）"><a href="#优先队列（堆）" class="headerlink" title="优先队列（堆）"></a>优先队列（堆）</h3><ul><li><code>priority_queue&lt;int, vector&lt;int&gt;, cmp&gt; p_queue</code>默认底层容器 vector，默认大顶堆 less。</li><li>自定义比较函数 class：</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">cmp</span>&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">operator</span><span class="hljs-params">()</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp;a,vector&lt;<span class="hljs-type">int</span>&gt;&amp;b)</span></span>&#123;<br>        <span class="hljs-keyword">return</span> a[<span class="hljs-number">0</span>]&gt;b[<span class="hljs-number">0</span>];   小顶堆<br>    &#125;<br>&#125;;<br>priority_queue&lt;vector&lt;<span class="hljs-type">int</span>&gt;,vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt;,cmp&gt; q;<br></code></pre></td></tr></table></figure><ul><li>自定义比较结构体 struct:</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">cmp</span> &#123;<br>     <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">operator</span><span class="hljs-params">()</span><span class="hljs-params">(pair&lt;<span class="hljs-type">int</span>,<span class="hljs-type">int</span>&gt;&amp; a,pair&lt;<span class="hljs-type">int</span>,<span class="hljs-type">int</span>&gt;&amp; b)</span></span>&#123;<br>         <span class="hljs-keyword">return</span> a.second &gt; b.second;<br>    &#125;<br>&#125;;<br>priority_queue&lt;pair&lt;<span class="hljs-type">int</span>,<span class="hljs-type">int</span>&gt;, vector&lt;pair&lt;<span class="hljs-type">int</span>,<span class="hljs-type">int</span>&gt;&gt;, cmp&gt; q;<br></code></pre></td></tr></table></figure><ul><li>两种自定义比较函数，小顶堆，注意符号（默认大顶堆），第二个参数设置底层容器，必填，否则第三个参数不起作用。</li></ul><h3 id="二叉树"><a href="#二叉树" class="headerlink" title="二叉树"></a>二叉树</h3><ul><li>数据结构模板：</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">TreeNode</span> &#123;<br>    <span class="hljs-type">int</span> val;<br>    TreeNode *left;<br>    TreeNode *right;<br>    <span class="hljs-built_in">TreeNode</span>(<span class="hljs-type">int</span> x) : <span class="hljs-built_in">val</span>(x), <span class="hljs-built_in">left</span>(<span class="hljs-literal">nullptr</span>), <span class="hljs-built_in">right</span>(<span class="hljs-literal">nullptr</span>) &#123;&#125;<br>&#125;;<br></code></pre></td></tr></table></figure><ul><li>二叉树递归参数传值 val，切忌不要用引用 &amp;val，不能改变 val 值，<strong>方便回溯</strong>。</li><li>递归遍历函数是否需要返回值？<ul><li>若只要找到一条路径，不用全部遍历，则要返回值 bool。</li><li>若找到所有满足条件路径，要求全部遍历，则不需要返回值。</li></ul></li><li>递归返回<code>TreeNode*</code>，可以<code>return nullptr</code>。</li><li><strong>删除</strong>二叉树节点，<strong>增加</strong>二叉树节点，都是用<strong>递归函数的返回值</strong>来完成。</li><li>根据有序数组创建<strong>二叉搜索树</strong>，同时也是平衡树：</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function">TreeNode* <span class="hljs-title">createTree</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; vec,<span class="hljs-type">int</span> left,<span class="hljs-type">int</span> right)</span></span>&#123;<br>    <span class="hljs-keyword">if</span>(left &gt; right) <span class="hljs-keyword">return</span> <span class="hljs-literal">nullptr</span>;<br>    <span class="hljs-type">int</span> mid = (left+right)/<span class="hljs-number">2</span>;<br>    TreeNode* node = <span class="hljs-keyword">new</span> <span class="hljs-built_in">TreeNode</span>(vec[mid]);<br>    node-&gt;left = <span class="hljs-built_in">createTree</span>(vec,left,mid<span class="hljs-number">-1</span>);<br>    node-&gt;right = <span class="hljs-built_in">createTree</span>(vec,mid+<span class="hljs-number">1</span>,right);<br>    <span class="hljs-keyword">return</span> node;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>求公共最近公共邻居 leetcode.236：</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">TreeNode* <span class="hljs-title">lowestCommonAncestor</span><span class="hljs-params">(TreeNode* root, TreeNode* p, TreeNode* q)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (root == q || root == p || root == <span class="hljs-literal">NULL</span>) <span class="hljs-keyword">return</span> root;<br>        TreeNode* left = <span class="hljs-built_in">lowestCommonAncestor</span>(root-&gt;left, p, q);<br>        TreeNode* right = <span class="hljs-built_in">lowestCommonAncestor</span>(root-&gt;right, p, q);<br>        <span class="hljs-keyword">if</span> (left != <span class="hljs-literal">NULL</span> &amp;&amp; right != <span class="hljs-literal">NULL</span>) <span class="hljs-keyword">return</span> root;<br><br>        <span class="hljs-keyword">if</span> (left == <span class="hljs-literal">NULL</span> &amp;&amp; right != <span class="hljs-literal">NULL</span>) <span class="hljs-keyword">return</span> right;<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (left != <span class="hljs-literal">NULL</span> &amp;&amp; right == <span class="hljs-literal">NULL</span>) <span class="hljs-keyword">return</span> left;<br>        <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;<br>        &#125;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><ul><li><p>考虑设置 全局变量<code>public: TreeNode* pre</code>递归过程更新全局指针变量。</p></li><li><p><strong>递归一定看函数返回什么，指针？整数？，利用起来<code>root-&gt;left = deleteNode(root-&gt;left,key);</code>。</strong></p></li></ul><h3 id="回溯法"><a href="#回溯法" class="headerlink" title="回溯法"></a>回溯法</h3><ul><li><p><strong>关键词：返回所有可能方案。</strong></p></li><li><p><strong>回溯是递归的副产品，只要有递归就会有回溯。</strong></p></li><li><p>回溯法就是暴力搜索，并不是什么高效的算法，最多在剪枝一下（解决多层 for 循环）。</p></li><li><p>通用模板：</p></li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-type">void</span> backtracking（参数） &#123;<br>    <span class="hljs-keyword">if</span> （终止条件） &#123;<br>        存放结果；<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br>    <span class="hljs-keyword">for</span> （选择：本层集合中元素（树中节点孩子的数量就是集合的大小）) &#123;<br>        处理节点；<br>        backtracking（路径，选择列表）; <span class="hljs-comment">// 递归</span><br>        回溯，撤销处理结果！!!<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>在终止条件前加入剪枝，即进入递归后提前<code>return</code>：</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">private</span>:<br>    vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; result; <span class="hljs-comment">// 存放符合条件结果的集合</span><br>    vector&lt;<span class="hljs-type">int</span>&gt; path; <span class="hljs-comment">// 用来存放符合条件结果</span><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">backtracking</span><span class="hljs-params">(<span class="hljs-type">int</span> n, <span class="hljs-type">int</span> k, <span class="hljs-type">int</span> startIndex)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (path.<span class="hljs-built_in">size</span>() == k) &#123;<br>            result.<span class="hljs-built_in">push_back</span>(path);<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = startIndex; i &lt;= n; i++) &#123;<br>            path.<span class="hljs-built_in">push_back</span>(i); <span class="hljs-comment">// 处理节点</span><br>            <span class="hljs-built_in">backtracking</span>(n, k, i + <span class="hljs-number">1</span>);   <span class="hljs-comment">//注意 传 i+1, 不是 startIndex</span><br>            path.<span class="hljs-built_in">pop_back</span>(); <span class="hljs-comment">// 回溯，撤销处理的节点</span><br>        &#125;<br>    &#125;<br><span class="hljs-keyword">public</span>:<br>    vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">combine</span>(<span class="hljs-type">int</span> n, <span class="hljs-type">int</span> k) &#123;<br>        result.<span class="hljs-built_in">clear</span>();<br>        path.<span class="hljs-built_in">clear</span>();<br>        <span class="hljs-built_in">backtracking</span>(n, k, <span class="hljs-number">1</span>);<br>        <span class="hljs-keyword">return</span> result;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><ul><li><p>经典组合题，注意<code>backtracking(n, k, i + 1)</code>; 传 <strong>i+1</strong>, 回溯部分<code>path.pop_back()</code>以及相应处理。</p></li><li><p>善用<code>used[]</code>，标记已访问的元素。</p></li><li><p>全组合用<code>startIndex</code>（无顺序且组合不能重复）;</p><p>全排列<strong>不需要</strong><code>startIndex</code>，而是用<code>used[ ]</code>（有顺序且同一元素不能重复选取）。</p></li><li><p><strong>对于结果有重复子集，需去重，则先排序，通过判断相邻结点是否重复使用过。</strong></p></li><li><p><code>if (i &gt; 0 &amp;&amp; nums[i] == nums[i - 1] &amp;&amp; used[i - 1] == false) continue;</code>, 先排序，对于{1, 1, 2}, <code>used[0]=false</code>表示同一数层上 n[0] 已被用过，而 n[0]&#x3D;&#x3D;n[1]，所以跳过；对于<code>used[0]=true</code>，表示 n[0] 在<strong>上一层</strong>，同一条树枝上，不在同一层，可重复使用。</p></li><li><p>经典排列题，含去重：</p></li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">private</span>:<br>    vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; result;<br>    vector&lt;<span class="hljs-type">int</span>&gt; path;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">backtracking</span> <span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums, vector&lt;<span class="hljs-type">bool</span>&gt;&amp; used)</span> </span>&#123;<br>        <span class="hljs-comment">// 此时说明找到了一组</span><br>        <span class="hljs-keyword">if</span> (path.<span class="hljs-built_in">size</span>() == nums.<span class="hljs-built_in">size</span>()) &#123;<br>            result.<span class="hljs-built_in">push_back</span>(path);<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; nums.<span class="hljs-built_in">size</span>(); i++) &#123;<br>            <span class="hljs-comment">// used[i - 1] == true，说明同一树枝 nums[i - 1] 使用过</span><br>            <span class="hljs-comment">// used[i - 1] == false，说明同一树层 nums[i - 1] 使用过</span><br>            <span class="hljs-comment">// 如果同一树层 nums[i - 1] 使用过则直接跳过</span><br>            <span class="hljs-keyword">if</span> (i &gt; <span class="hljs-number">0</span> &amp;&amp; nums[i] == nums[i - <span class="hljs-number">1</span>] &amp;&amp; used[i - <span class="hljs-number">1</span>] == <span class="hljs-literal">false</span>) &#123;<br>                <span class="hljs-keyword">continue</span>;<br>            &#125;<br>            <span class="hljs-comment">//if ( used[i] == true ) continue;</span><br>            <span class="hljs-keyword">if</span> (used[i] == <span class="hljs-literal">false</span>) &#123;<br>                used[i] = <span class="hljs-literal">true</span>;<br>                path.<span class="hljs-built_in">push_back</span>(nums[i]);<br>                <span class="hljs-built_in">backtracking</span>(nums, used);<br>                path.<span class="hljs-built_in">pop_back</span>();<br>                used[i] = <span class="hljs-literal">false</span>;<br>            &#125;<br>        &#125;<br>    &#125;<br><span class="hljs-keyword">public</span>:<br>    vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">permuteUnique</span>(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums) &#123;<br>        result.<span class="hljs-built_in">clear</span>();<br>        path.<span class="hljs-built_in">clear</span>();<br>        <span class="hljs-built_in">sort</span>(nums.<span class="hljs-built_in">begin</span>(), nums.<span class="hljs-built_in">end</span>()); <span class="hljs-comment">// 排序</span><br>        <span class="hljs-function">vector&lt;<span class="hljs-type">bool</span>&gt; <span class="hljs-title">used</span><span class="hljs-params">(nums.size(), <span class="hljs-literal">false</span>)</span></span>;<br>        <span class="hljs-built_in">backtracking</span>(nums, used);<br>        <span class="hljs-keyword">return</span> result;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><ul><li><p><code>if (used[i] == false) &#123; ... &#125;</code>，记住前提条件，<strong>上一层已选过，就不考虑啦</strong>，或者改为<code>if (used[i] == true) continue;</code>。</p></li><li><p>递归和回溯：<br>1）要遍历所有元素找全部结果，函数 void 无返回值。<br>2）只要找到一条路径&#x2F;结果，函数有返回值 bool（同二叉树）。</p></li></ul><h3 id="贪心算法"><a href="#贪心算法" class="headerlink" title="贪心算法"></a>贪心算法</h3><ul><li><p>贪心的本质是选择每一阶段的局部最优，从而达到全局最优。</p></li><li><p><strong>提前排序给定数组！降低难度！</strong></p></li><li><p>加关键词 static 才能在 sort 使用 cmp 函数，sort 要求 cmp 函数为 static，或者声明类外作为全局函数。</p></li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">static</span> <span class="hljs-type">bool</span> <span class="hljs-title">cmp</span><span class="hljs-params">(<span class="hljs-type">int</span> a,<span class="hljs-type">int</span> b)</span></span>&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">abs</span>(a) &gt; <span class="hljs-built_in">abs</span>(b);<br>&#125;<br><span class="hljs-built_in">sort</span>(nums.<span class="hljs-built_in">begin</span>(),nums.<span class="hljs-built_in">end</span>(),cmp);<br></code></pre></td></tr></table></figure><ul><li><strong>左右排序两次问题，区间问题，或数组中当前元素与左右元素比较时</strong>，先顺序遍历，在逆序遍历，两次遍历不能同时兼顾左右（lc.135），换句话说，遇到两个维度权衡的时候，一定要先确定一个维度，再确定另一个维度。</li></ul><h3 id="动态规划"><a href="#动态规划" class="headerlink" title="动态规划"></a>动态规划</h3><blockquote><ol><li><p>确定 dp 数组以及下标的含义</p></li><li><p>确定递推公式</p></li><li><p>dp 数组如何初始化</p></li><li><p>确定遍历顺序</p></li><li><p>举例推导 dp 数组</p></li></ol></blockquote><p><strong>debug 最好方式就是把 dp 数组打印出来，看看究竟是不是按照自己思路推导的！</strong></p><p>dp 初始化后，遍历数组考虑初始值，避免越界。</p><h3 id="经典01背包问题"><a href="#经典01背包问题" class="headerlink" title="经典01背包问题"></a>经典01背包问题</h3><ul><li><p>每个物品只能放入一次。</p></li><li><p>外层遍历物品，<strong>内层遍历容量</strong>。</p></li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// 二维数组</span><br>vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">dp</span>(weight.<span class="hljs-built_in">size</span>(), <span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">int</span>&gt;(bagweight + <span class="hljs-number">1</span>, <span class="hljs-number">0</span>));<br><span class="hljs-comment">// 初始化</span><br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = weight[<span class="hljs-number">0</span>]; j &lt;= bagweight; j++) &#123;<br>    dp[<span class="hljs-number">0</span>][j] = value[<span class="hljs-number">0</span>];<br>&#125;<br><span class="hljs-comment">// weight 数组的大小 就是物品个数</span><br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt; weight.<span class="hljs-built_in">size</span>(); i++) &#123; <span class="hljs-comment">// 遍历物品</span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt;= bagweight; j++) &#123; <span class="hljs-comment">// 遍历背包容量</span><br>        放不下 i 重量<br>        <span class="hljs-keyword">if</span> (j &lt; weight[i]) dp[i][j] = dp[i - <span class="hljs-number">1</span>][j];<br>        <span class="hljs-keyword">else</span> dp[i][j] = <span class="hljs-built_in">max</span>(dp[i - <span class="hljs-number">1</span>][j], dp[i - <span class="hljs-number">1</span>][j - weight[i]] + value[i]);<br>    &#125;<br>&#125;<br>cout &lt;&lt; dp[weight.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>][bagweight] &lt;&lt; endl;<br></code></pre></td></tr></table></figure><ul><li><strong>滚动数组</strong>：降低空间复杂度。先正序遍历物品，在倒序遍历背包容量，dp[j] 表示：容量维 j 的背包，所背的物品价值最大为 dp[j]，<strong>倒序遍历是为了保证物品 i 只被放入一次！</strong></li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// 初始化</span><br><span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">dp</span><span class="hljs-params">(bagWeight + <span class="hljs-number">1</span>, <span class="hljs-number">0</span>)</span></span>;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; weight.<span class="hljs-built_in">size</span>(); i++) &#123; <span class="hljs-comment">// 遍历物品</span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = bagWeight; j &gt;= weight[i]; j--) &#123; <span class="hljs-comment">// 遍历背包容量</span><br>        dp[j] = <span class="hljs-built_in">max</span>(dp[j], dp[j - weight[i]] + value[i]);<br>    &#125;<br>&#125;<br>cout &lt;&lt; dp[bagWeight] &lt;&lt; endl;<br></code></pre></td></tr></table></figure><ul><li><p><code>dp[i]</code>表示不放物体，相当于<code>dp[i-1][j]</code>，不放物体 i，<code>dp[j - weight[i]] + value[i]</code>表示放物体 i，为放物体前容量的最大价值 + 物体 i 的价值。</p></li><li><p>为什么第二次循环<code>j&gt;=weight[i]</code>，因为<code>dp[j - weight[i]]</code>表示放物体前的容量，不能为负数，考虑能放下的情况，放还是不放；对于不能放下就默认等于上一次值，不考虑。</p></li><li><p>注意第二重<strong>循环 j 初始值</strong>，为 dp 容量最大值。</p></li></ul><h3 id="完全背包问题"><a href="#完全背包问题" class="headerlink" title="完全背包问题"></a>完全背包问题</h3><ul><li>每件物品无限件，可重复放入背包。</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// 先遍历物品，再遍历背包</span><br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; weight.<span class="hljs-built_in">size</span>(); i++) &#123; <span class="hljs-comment">// 遍历物品</span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = weight[i]; j &lt;= bagWeight ; j++) &#123; <span class="hljs-comment">// 遍历背包容量</span><br>        dp[j] = <span class="hljs-built_in">max</span>(dp[j], dp[j - weight[i]] + value[i]);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li><p><strong>内循环 从小到大遍历，因为每件物品添加多次</strong>。</p></li><li><p><strong>理解 内循环 dp[j]：每次容量为 j 的时候，所以后面内容都是考虑当前容量为 j</strong>。</p></li><li><p><strong>如果求<mark>组合数</mark>就是外层 for 循环遍历物品，内层 for 遍历背包</strong>。</p><p><strong>如果求<mark>排列数</mark>就是外层 for 遍历背包，内层 for 循环遍历物品</strong>。</p></li><li><p>滚动数组为了取代二维数组，但<strong>内循环一般是倒序</strong>的，防止重复选取。</p></li></ul><h3 id="求连续公共子序列"><a href="#求连续公共子序列" class="headerlink" title="求连续公共子序列"></a>求连续公共子序列</h3><ul><li><p><code>dp[i][j]</code>：以下标 <strong>i-1</strong> 为结尾的 A，和以下标 <strong>j-1</strong> 为结尾的 B，最长重复子数组<strong>长度</strong>为<code>dp[i][j]</code>。</p></li><li><p>求<strong>连续</strong>最长重复子数组：</p></li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">findLength</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums1, vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums2)</span> </span>&#123;<br>        vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">dp</span>(nums1.<span class="hljs-built_in">size</span>()+<span class="hljs-number">1</span>,<span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">int</span>&gt;(nums2.<span class="hljs-built_in">size</span>()+<span class="hljs-number">1</span>,<span class="hljs-number">0</span>));<br>        <span class="hljs-type">int</span> res = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i &lt;=nums1.<span class="hljs-built_in">size</span>();i++)&#123;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">1</span>;j&lt;=nums2.<span class="hljs-built_in">size</span>();j++)&#123;<br>                <span class="hljs-keyword">if</span>(nums1[i<span class="hljs-number">-1</span>] == nums2[j<span class="hljs-number">-1</span>])&#123;<br>                    dp[i][j] = dp[i<span class="hljs-number">-1</span>][j<span class="hljs-number">-1</span>]+<span class="hljs-number">1</span>;<br>                &#125;<br>                <span class="hljs-keyword">if</span>(dp[i][j] &gt; res) res = dp[i][j];<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><ul><li>求<strong>不连续</strong>公共子数组：</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">longestCommonSubsequence</span><span class="hljs-params">(string text1, string text2)</span> </span>&#123;<br>        vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">dp</span>(text1.<span class="hljs-built_in">size</span>()+<span class="hljs-number">1</span>,<span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">int</span>&gt;(text2.<span class="hljs-built_in">size</span>()+<span class="hljs-number">1</span>,<span class="hljs-number">0</span>));<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=text1.<span class="hljs-built_in">size</span>();i++)&#123;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">1</span>;j&lt;=text2.<span class="hljs-built_in">size</span>();j++)&#123;<br>                <span class="hljs-keyword">if</span>(text1[i<span class="hljs-number">-1</span>] == text2[j<span class="hljs-number">-1</span>])&#123;<br>                    dp[i][j] = dp[i<span class="hljs-number">-1</span>][j<span class="hljs-number">-1</span>] + <span class="hljs-number">1</span>;<br>                &#125;<span class="hljs-keyword">else</span>&#123;<br>                    dp[i][j] = <span class="hljs-built_in">max</span>(dp[i<span class="hljs-number">-1</span>][j],dp[i][j<span class="hljs-number">-1</span>]);<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> dp[text1.<span class="hljs-built_in">size</span>()][text2.<span class="hljs-built_in">size</span>()];<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><ul><li>思考<code>d[i][j]</code>是一个数，表示什么意思？公共长度？最多重复数量？最少删除次数？视情况而定。</li></ul><h3 id="单调栈"><a href="#单调栈" class="headerlink" title="单调栈"></a>单调栈</h3><ul><li><p><strong>要寻找任一个元素的右边或者左边第一个比自己大或者小的元素的位置。</strong></p></li><li><p>栈里只存递增或递减的 index，遇到逆序就弹出栈内元素，从而得到第一个大于或小于元素的 index。</p></li><li><p>设置两个数组，顺序和逆序遍历，得到左边&#x2F;右边最大数字：</p></li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// 记录每个柱子左边柱子最大高度</span><br>maxLeft[<span class="hljs-number">0</span>] = height[<span class="hljs-number">0</span>];<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt; size; i++) &#123;<br>    maxLeft[i] = <span class="hljs-built_in">max</span>(height[i], maxLeft[i - <span class="hljs-number">1</span>]);<br>&#125;<br><span class="hljs-comment">// 记录每个柱子右边柱子最大高度</span><br>maxRight[size - <span class="hljs-number">1</span>] = height[size - <span class="hljs-number">1</span>];<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = size - <span class="hljs-number">2</span>; i &gt;= <span class="hljs-number">0</span>; i--) &#123;<br>    maxRight[i] = <span class="hljs-built_in">max</span>(height[i], maxRight[i + <span class="hljs-number">1</span>]);<br>&#125;<br></code></pre></td></tr></table></figure><p>待续……</p>]]></content>
    
    
    <categories>
      
      <category>刷题笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>cpp</tag>
      
      <tag>note</tag>
      
      <tag>algorithm</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
